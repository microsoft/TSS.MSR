"""
 * Copyright(c) Microsoft Corporation. All rights reserved. 
 * Licensed under the MIT License. 
 * See the LICENSE file in the project root for full license information. 
"""

"""
 * This file is automatically generated from the TPM 2.0 rev. 1.62 specification documents.
 * Do not edit it directly.
"""

from .TpmBase import *

class Tpm(TpmBase):
    def Startup(self, startupType):
        """ TPM2_Startup() is always preceded by _TPM_Init, which is the
        physical indication that TPM initialization is necessary because of a
        system-wide reset. TPM2_Startup() is only valid after _TPM_Init.
        Additional TPM2_Startup() commands are not allowed after it has
        completed successfully. If a TPM requires TPM2_Startup() and another
        command is received, or if the TPM receives TPM2_Startup() when it is
        not required, the TPM shall return TPM_RC_INITIALIZE.

        Args:
            startupType (TPM_SU): TPM_SU_CLEAR or TPM_SU_STATE
        """
        req = TPM2_Startup_REQUEST(startupType)
        respBuf = self.dispatchCommand(TPM_CC.Startup, req)
        return self.processResponse(respBuf)
    # Startup()

    def Shutdown(self, shutdownType):
        """ This command is used to prepare the TPM for a power cycle. The
        shutdownType parameter indicates how the subsequent TPM2_Startup() will
        be processed.

        Args:
            shutdownType (TPM_SU): TPM_SU_CLEAR or TPM_SU_STATE
        """
        req = TPM2_Shutdown_REQUEST(shutdownType)
        respBuf = self.dispatchCommand(TPM_CC.Shutdown, req)
        return self.processResponse(respBuf)
    # Shutdown()

    def SelfTest(self, fullTest):
        """ This command causes the TPM to perform a test of its capabilities.
        If the fullTest is YES, the TPM will test all functions. If fullTest =
        NO, the TPM will only test those functions that have not previously been
        tested.

        Args:
            fullTest (int): YES if full test to be performed
                NO if only test of untested functions required
        """
        req = TPM2_SelfTest_REQUEST(fullTest)
        respBuf = self.dispatchCommand(TPM_CC.SelfTest, req)
        return self.processResponse(respBuf)
    # SelfTest()

    def IncrementalSelfTest(self, toTest):
        """ This command causes the TPM to perform a test of the selected algorithms.

        Args:
            toTest (TPM_ALG_ID[]): List of algorithms that should be tested

        Returns:
            toDoList - List of algorithms that need testing
        """
        req = TPM2_IncrementalSelfTest_REQUEST(toTest)
        respBuf = self.dispatchCommand(TPM_CC.IncrementalSelfTest, req)
        res = self.processResponse(respBuf, IncrementalSelfTestResponse)
        return res.toDoList if res else None
    # IncrementalSelfTest()

    def GetTestResult(self):
        """ This command returns manufacturer-specific information regarding the
        results of a self-test and an indication of the test status.

        Returns:
            outData - Test result data
                      contains manufacturer-specific information
            testResult - TBD
        """
        req = TPM2_GetTestResult_REQUEST()
        respBuf = self.dispatchCommand(TPM_CC.GetTestResult, req)
        return self.processResponse(respBuf, GetTestResultResponse)
    # GetTestResult()

    def StartAuthSession(self, tpmKey, bind, nonceCaller, encryptedSalt, sessionType, symmetric, authHash):
        """ This command is used to start an authorization session using
        alternative methods of establishing the session key (sessionKey). The
        session key is then used to derive values used for authorization and for
        encrypting parameters.

        Args:
            tpmKey (TPM_HANDLE): Handle of a loaded decrypt key used to encrypt salt
                may be TPM_RH_NULL
                Auth Index: None
            bind (TPM_HANDLE): Entity providing the authValue
                may be TPM_RH_NULL
                Auth Index: None
            nonceCaller (bytes): Initial nonceCaller, sets nonceTPM size for the
                session
                shall be at least 16 octets
            encryptedSalt (bytes): Value encrypted according to the type of tpmKey
                If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
            sessionType (TPM_SE): Indicates the type of the session; simple HMAC
                or policy (including a trial policy)
            symmetric (TPMT_SYM_DEF): The algorithm and key size for parameter
                encryption
                may select TPM_ALG_NULL
            authHash (TPM_ALG_ID): Hash algorithm to use for the session
                Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL

        Returns:
            handle - Handle for the newly created session
            nonceTPM - The initial nonce from the TPM, used in the computation
                       of the sessionKey
        """
        req = TPM2_StartAuthSession_REQUEST(tpmKey, bind, nonceCaller, encryptedSalt, sessionType, symmetric, authHash)
        respBuf = self.dispatchCommand(TPM_CC.StartAuthSession, req)
        return self.processResponse(respBuf, StartAuthSessionResponse)
    # StartAuthSession()

    def PolicyRestart(self, sessionHandle):
        """ This command allows a policy authorization session to be returned to
        its initial state. This command is used after the TPM returns
        TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail
        because the PCR have changed after TPM2_PolicyPCR() was executed.
        Restarting the session allows the authorizations to be replayed because
        the session restarts with the same nonceTPM. If the PCR are valid for
        the policy, the policy may then succeed.

        Args:
            sessionHandle (TPM_HANDLE): The handle for the policy session
        """
        req = TPM2_PolicyRestart_REQUEST(sessionHandle)
        respBuf = self.dispatchCommand(TPM_CC.PolicyRestart, req)
        return self.processResponse(respBuf)
    # PolicyRestart()

    def Create(self, parentHandle, inSensitive, inPublic, outsideInfo, creationPCR):
        """ This command is used to create an object that can be loaded into a
        TPM using TPM2_Load(). If the command completes successfully, the TPM
        will create the new object and return the objects creation data
        (creationData), its public area (outPublic), and its encrypted sensitive
        area (outPrivate). Preservation of the returned data is the
        responsibility of the caller. The object will need to be loaded
        (TPM2_Load()) before it may be used. The only difference between the
        inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in
        the unique field.

        Args:
            parentHandle (TPM_HANDLE): Handle of parent for new object
                Auth Index: 1
                Auth Role: USER
            inSensitive (TPMS_SENSITIVE_CREATE): The sensitive data
            inPublic (TPMT_PUBLIC): The public template
            outsideInfo (bytes): Data that will be included in the creation data
                for this object to provide permanent, verifiable linkage between
                this object and some object owner data
            creationPCR (TPMS_PCR_SELECTION[]): PCR that will be used in
                creation data

        Returns:
            outPrivate - The private portion of the object
            outPublic - The public portion of the created object
            creationData - Contains a TPMS_CREATION_DATA
            creationHash - Digest of creationData using nameAlg of outPublic
            creationTicket - Ticket used by TPM2_CertifyCreation() to validate
                             that the creation data was produced by the TPM
        """
        req = TPM2_Create_REQUEST(parentHandle, inSensitive, inPublic, outsideInfo, creationPCR)
        respBuf = self.dispatchCommand(TPM_CC.Create, req)
        return self.processResponse(respBuf, CreateResponse)
    # Create()

    def Load(self, parentHandle, inPrivate, inPublic):
        """ This command is used to load objects into the TPM. This command is
        used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If
        only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.

        Args:
            parentHandle (TPM_HANDLE): TPM handle of parent key; shall not be a
                reserved handle
                Auth Index: 1
                Auth Role: USER
            inPrivate (TPM2B_PRIVATE): The private portion of the object
            inPublic (TPMT_PUBLIC): The public portion of the object

        Returns:
            handle - Handle of type TPM_HT_TRANSIENT for the loaded object
        """
        req = TPM2_Load_REQUEST(parentHandle, inPrivate, inPublic)
        respBuf = self.dispatchCommand(TPM_CC.Load, req)
        res = self.processResponse(respBuf, LoadResponse)
        return res.handle if res else None
    # Load()

    def LoadExternal(self, inPrivate, inPublic, hierarchy):
        """ This command is used to load an object that is not a Protected
        Object into the TPM. The command allows loading of a public area or both
        a public and sensitive area.

        Args:
            inPrivate (TPMT_SENSITIVE): The sensitive portion of the object (optional)
            inPublic (TPMT_PUBLIC): The public portion of the object
            hierarchy (TPM_HANDLE): Hierarchy with which the object area is associated

        Returns:
            handle - Handle of type TPM_HT_TRANSIENT for the loaded object
        """
        req = TPM2_LoadExternal_REQUEST(inPrivate, inPublic, hierarchy)
        respBuf = self.dispatchCommand(TPM_CC.LoadExternal, req)
        res = self.processResponse(respBuf, LoadExternalResponse)
        return res.handle if res else None
    # LoadExternal()

    def ReadPublic(self, objectHandle):
        """ This command allows access to the public area of a loaded object.

        Args:
            objectHandle (TPM_HANDLE): TPM handle of an object
                Auth Index: None

        Returns:
            outPublic - Structure containing the public area of an object
            name - Name of the object
            qualifiedName - The Qualified Name of the object
        """
        req = TPM2_ReadPublic_REQUEST(objectHandle)
        respBuf = self.dispatchCommand(TPM_CC.ReadPublic, req)
        return self.processResponse(respBuf, ReadPublicResponse)
    # ReadPublic()

    def ActivateCredential(self, activateHandle, keyHandle, credentialBlob, secret):
        """ This command enables the association of a credential with an object
        in a way that ensures that the TPM has validated the parameters of the
        credentialed object.

        Args:
            activateHandle (TPM_HANDLE): Handle of the object associated with
                certificate in credentialBlob
                Auth Index: 1
                Auth Role: ADMIN
            keyHandle (TPM_HANDLE): Loaded key used to decrypt the
                TPMS_SENSITIVE in credentialBlob
                Auth Index: 2
                Auth Role: USER
            credentialBlob (TPMS_ID_OBJECT): The credential
            secret (bytes): KeyHandle algorithm-dependent encrypted seed that
                protects credentialBlob

        Returns:
            certInfo - The decrypted certificate information
                       the data should be no larger than the size of the digest
                       of the nameAlg associated with keyHandle
        """
        req = TPM2_ActivateCredential_REQUEST(activateHandle, keyHandle, credentialBlob, secret)
        respBuf = self.dispatchCommand(TPM_CC.ActivateCredential, req)
        res = self.processResponse(respBuf, ActivateCredentialResponse)
        return res.certInfo if res else None
    # ActivateCredential()

    def MakeCredential(self, handle, credential, objectName):
        """ This command allows the TPM to perform the actions required of a
        Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an
        activation credential.

        Args:
            handle (TPM_HANDLE): Loaded public area, used to encrypt the
                sensitive area containing the credential key
                Auth Index: None
            credential (bytes): The credential information
            objectName (bytes): Name of the object to which the credential applies

        Returns:
            credentialBlob - The credential
            secret - Handle algorithm-dependent data that wraps the key that
                     encrypts credentialBlob
        """
        req = TPM2_MakeCredential_REQUEST(handle, credential, objectName)
        respBuf = self.dispatchCommand(TPM_CC.MakeCredential, req)
        return self.processResponse(respBuf, MakeCredentialResponse)
    # MakeCredential()

    def Unseal(self, itemHandle):
        """ This command returns the data in a loaded Sealed Data Object.

        Args:
            itemHandle (TPM_HANDLE): Handle of a loaded data object
                Auth Index: 1
                Auth Role: USER

        Returns:
            outData - Unsealed data
                      Size of outData is limited to be no more than 128 octets.
        """
        req = TPM2_Unseal_REQUEST(itemHandle)
        respBuf = self.dispatchCommand(TPM_CC.Unseal, req)
        res = self.processResponse(respBuf, UnsealResponse)
        return res.outData if res else None
    # Unseal()

    def ObjectChangeAuth(self, objectHandle, parentHandle, newAuth):
        """ This command is used to change the authorization secret for a
        TPM-resident object.

        Args:
            objectHandle (TPM_HANDLE): Handle of the object
                Auth Index: 1
                Auth Role: ADMIN
            parentHandle (TPM_HANDLE): Handle of the parent
                Auth Index: None
            newAuth (bytes): New authorization value

        Returns:
            outPrivate - Private area containing the new authorization value
        """
        req = TPM2_ObjectChangeAuth_REQUEST(objectHandle, parentHandle, newAuth)
        respBuf = self.dispatchCommand(TPM_CC.ObjectChangeAuth, req)
        res = self.processResponse(respBuf, ObjectChangeAuthResponse)
        return res.outPrivate if res else None
    # ObjectChangeAuth()

    def CreateLoaded(self, parentHandle, inSensitive, inPublic):
        """ This command creates an object and loads it in the TPM. This command
        allows creation of any type of object (Primary, Ordinary, or Derived)
        depending on the type of parentHandle. If parentHandle references a
        Primary Seed, then a Primary Object is created; if parentHandle
        references a Storage Parent, then an Ordinary Object is created; and if
        parentHandle references a Derivation Parent, then a Derived Object is
        generated.

        Args:
            parentHandle (TPM_HANDLE): Handle of a transient storage key, a
                persistent storage key, TPM_RH_ENDORSEMENT, TPM_RH_OWNER,
                TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
                Auth Index: 1
                Auth Role: USER
            inSensitive (TPMS_SENSITIVE_CREATE): The sensitive data, see TPM 2.0
                Part 1 Sensitive Values
            inPublic (bytes): The public template

        Returns:
            handle - Handle of type TPM_HT_TRANSIENT for created object
            outPrivate - The sensitive area of the object (optional)
            outPublic - The public portion of the created object
            name - The name of the created object
        """
        req = TPM2_CreateLoaded_REQUEST(parentHandle, inSensitive, inPublic)
        respBuf = self.dispatchCommand(TPM_CC.CreateLoaded, req)
        return self.processResponse(respBuf, CreateLoadedResponse)
    # CreateLoaded()

    def Duplicate(self, objectHandle, newParentHandle, encryptionKeyIn, symmetricAlg):
        """ This command duplicates a loaded object so that it may be used in a
        different hierarchy. The new parent key for the duplicate may be on the
        same or different TPM or TPM_RH_NULL. Only the public area of
        newParentHandle is required to be loaded.

        Args:
            objectHandle (TPM_HANDLE): Loaded object to duplicate
                Auth Index: 1
                Auth Role: DUP
            newParentHandle (TPM_HANDLE): Shall reference the public area of an
                asymmetric key
                Auth Index: None
            encryptionKeyIn (bytes): Optional symmetric encryption key
                The size for this key is set to zero when the TPM is to generate
                the key. This parameter may be encrypted.
            symmetricAlg (TPMT_SYM_DEF_OBJECT): Definition for the symmetric
                algorithm to be used for the inner wrapper
                may be TPM_ALG_NULL if no inner wrapper is applied

        Returns:
            encryptionKeyOut - If the caller provided an encryption key or if
                               symmetricAlg was TPM_ALG_NULL, then this will be
                               the Empty Buffer; otherwise, it shall contain the
                               TPM-generated, symmetric encryption key for the
                               inner wrapper.
            duplicate - Private area that may be encrypted by encryptionKeyIn;
                        and may be doubly encrypted
            outSymSeed - Seed protected by the asymmetric algorithms of new
                         parent (NP)
        """
        req = TPM2_Duplicate_REQUEST(objectHandle, newParentHandle, encryptionKeyIn, symmetricAlg)
        respBuf = self.dispatchCommand(TPM_CC.Duplicate, req)
        return self.processResponse(respBuf, DuplicateResponse)
    # Duplicate()

    def Rewrap(self, oldParent, newParent, inDuplicate, name, inSymSeed):
        """ This command allows the TPM to serve in the role as a Duplication
        Authority. If proper authorization for use of the oldParent is provided,
        then an HMAC key and a symmetric key are recovered from inSymSeed and
        used to integrity check and decrypt inDuplicate. A new protection seed
        value is generated according to the methods appropriate for newParent
        and the blob is re-encrypted and a new integrity value is computed. The
        re-encrypted blob is returned in outDuplicate and the symmetric key
        returned in outSymKey.

        Args:
            oldParent (TPM_HANDLE): Parent of object
                Auth Index: 1
                Auth Role: User
            newParent (TPM_HANDLE): New parent of the object
                Auth Index: None
            inDuplicate (TPM2B_PRIVATE): An object encrypted using symmetric key
                derived from inSymSeed
            name (bytes): The Name of the object being rewrapped
            inSymSeed (bytes): The seed for the symmetric key and HMAC key
                needs oldParent private key to recover the seed and generate the
                symmetric key

        Returns:
            outDuplicate - An object encrypted using symmetric key derived from
                           outSymSeed
            outSymSeed - Seed for a symmetric key protected by newParent
                         asymmetric key
        """
        req = TPM2_Rewrap_REQUEST(oldParent, newParent, inDuplicate, name, inSymSeed)
        respBuf = self.dispatchCommand(TPM_CC.Rewrap, req)
        return self.processResponse(respBuf, RewrapResponse)
    # Rewrap()

    def Import(self, parentHandle, encryptionKey, objectPublic, duplicate, inSymSeed, symmetricAlg):
        """ This command allows an object to be encrypted using the symmetric
        encryption values of a Storage Key. After encryption, the object may be
        loaded and used in the new hierarchy. The imported object (duplicate)
        may be singly encrypted, multiply encrypted, or unencrypted.

        Args:
            parentHandle (TPM_HANDLE): The handle of the new parent for the object
                Auth Index: 1
                Auth Role: USER
            encryptionKey (bytes): The optional symmetric encryption key used as
                the inner wrapper for duplicate
                If symmetricAlg is TPM_ALG_NULL, then this parameter shall be
                the Empty Buffer.
            objectPublic (TPMT_PUBLIC): The public area of the object to be imported
                This is provided so that the integrity value for duplicate and
                the object attributes can be checked.
                NOTE Even if the integrity value of the object is not checked on
                input, the object Name is required to create the integrity value
                for the imported object.
            duplicate (TPM2B_PRIVATE): The symmetrically encrypted duplicate
                object that may contain an inner symmetric wrapper
            inSymSeed (bytes): The seed for the symmetric key and HMAC key
                inSymSeed is encrypted/encoded using the algorithms of newParent.
            symmetricAlg (TPMT_SYM_DEF_OBJECT): Definition for the symmetric
                algorithm to use for the inner wrapper
                If this algorithm is TPM_ALG_NULL, no inner wrapper is present
                and encryptionKey shall be the Empty Buffer.

        Returns:
            outPrivate - The sensitive area encrypted with the symmetric key of
                         parentHandle
        """
        req = TPM2_Import_REQUEST(parentHandle, encryptionKey, objectPublic, duplicate, inSymSeed, symmetricAlg)
        respBuf = self.dispatchCommand(TPM_CC.Import, req)
        res = self.processResponse(respBuf, ImportResponse)
        return res.outPrivate if res else None
    # Import()

    def RSA_Encrypt(self, keyHandle, message, inScheme, label):
        """ This command performs RSA encryption using the indicated padding
        scheme according to IETF RFC 8017. If the scheme of keyHandle is
        TPM_ALG_NULL, then the caller may use inScheme to specify the padding
        scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall
        either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).

        Args:
            keyHandle (TPM_HANDLE): Reference to public portion of RSA key to
                use for encryption
                Auth Index: None
            message (bytes): Message to be encrypted
                NOTE 1 The data type was chosen because it limits the overall
                size of the input to no greater than the size of the largest RSA
                public key. This may be larger than allowed for keyHandle.
            inScheme (TPMU_ASYM_SCHEME): The padding scheme to use if scheme
                associated with keyHandle is TPM_ALG_NULL
                One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV,
                TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH,
                TPMS_NULL_ASYM_SCHEME.
            label (bytes): Optional label L to be associated with the message
                Size of the buffer is zero if no label is present
                NOTE 2 See description of label above.

        Returns:
            outData - Encrypted output
        """
        req = TPM2_RSA_Encrypt_REQUEST(keyHandle, message, inScheme, label)
        respBuf = self.dispatchCommand(TPM_CC.RSA_Encrypt, req)
        res = self.processResponse(respBuf, RSA_EncryptResponse)
        return res.outData if res else None
    # RSA_Encrypt()

    def RSA_Decrypt(self, keyHandle, cipherText, inScheme, label):
        """ This command performs RSA decryption using the indicated padding
        scheme according to IETF RFC 8017 ((PKCS#1).

        Args:
            keyHandle (TPM_HANDLE): RSA key to use for decryption
                Auth Index: 1
                Auth Role: USER
            cipherText (bytes): Cipher text to be decrypted
                NOTE An encrypted RSA data block is the size of the public modulus.
            inScheme (TPMU_ASYM_SCHEME): The padding scheme to use if scheme
                associated with keyHandle is TPM_ALG_NULL
                One of: TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV,
                TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH,
                TPMS_NULL_ASYM_SCHEME.
            label (bytes): Label whose association with the message is to be verified

        Returns:
            message - Decrypted output
        """
        req = TPM2_RSA_Decrypt_REQUEST(keyHandle, cipherText, inScheme, label)
        respBuf = self.dispatchCommand(TPM_CC.RSA_Decrypt, req)
        res = self.processResponse(respBuf, RSA_DecryptResponse)
        return res.message if res else None
    # RSA_Decrypt()

    def ECDH_KeyGen(self, keyHandle):
        """ This command uses the TPM to generate an ephemeral key pair (de, Qe
        where Qe [de]G). It uses the private ephemeral key and a loaded public
        key (QS) to compute the shared secret value (P [hde]QS).

        Args:
            keyHandle (TPM_HANDLE): Handle of a loaded ECC key public area.
                Auth Index: None

        Returns:
            zPoint - Results of P h[de]Qs
            pubPoint - Generated ephemeral public point (Qe)
        """
        req = TPM2_ECDH_KeyGen_REQUEST(keyHandle)
        respBuf = self.dispatchCommand(TPM_CC.ECDH_KeyGen, req)
        return self.processResponse(respBuf, ECDH_KeyGenResponse)
    # ECDH_KeyGen()

    def ECDH_ZGen(self, keyHandle, inPoint):
        """ This command uses the TPM to recover the Z value from a public point
        (QB) and a private key (ds). It will perform the multiplication of the
        provided inPoint (QB) with the private key (ds) and return the
        coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h is
        the cofactor of the curve).

        Args:
            keyHandle (TPM_HANDLE): Handle of a loaded ECC key
                Auth Index: 1
                Auth Role: USER
            inPoint (TPMS_ECC_POINT): A public key

        Returns:
            outPoint - X and Y coordinates of the product of the multiplication
                       Z = (xZ , yZ) [hdS]QB
        """
        req = TPM2_ECDH_ZGen_REQUEST(keyHandle, inPoint)
        respBuf = self.dispatchCommand(TPM_CC.ECDH_ZGen, req)
        res = self.processResponse(respBuf, ECDH_ZGenResponse)
        return res.outPoint if res else None
    # ECDH_ZGen()

    def ECC_Parameters(self, curveID):
        """ This command returns the parameters of an ECC curve identified by
        its TCG-assigned curveID.

        Args:
            curveID (TPM_ECC_CURVE): Parameter set selector

        Returns:
            parameters - ECC parameters for the selected curve
        """
        req = TPM2_ECC_Parameters_REQUEST(curveID)
        respBuf = self.dispatchCommand(TPM_CC.ECC_Parameters, req)
        res = self.processResponse(respBuf, ECC_ParametersResponse)
        return res.parameters if res else None
    # ECC_Parameters()

    def ZGen_2Phase(self, keyA, inQsB, inQeB, inScheme, counter):
        """ This command supports two-phase key exchange protocols. The command
        is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral()
        generates an ephemeral key and returns the public point of that
        ephemeral key along with a numeric value that allows the TPM to
        regenerate the associated private key.

        Args:
            keyA (TPM_HANDLE): Handle of an unrestricted decryption key ECC
                The private key referenced by this handle is used as dS,A
                Auth Index: 1
                Auth Role: USER
            inQsB (TPMS_ECC_POINT): Other partys static public key (Qs,B =
                (Xs,B, Ys,B))
            inQeB (TPMS_ECC_POINT): Other party's ephemeral public key (Qe,B =
                (Xe,B, Ye,B))
            inScheme (TPM_ALG_ID): The key exchange scheme
            counter (int): Value returned by TPM2_EC_Ephemeral()

        Returns:
            outZ1 - X and Y coordinates of the computed value (scheme dependent)
            outZ2 - X and Y coordinates of the second computed value (scheme dependent)
        """
        req = TPM2_ZGen_2Phase_REQUEST(keyA, inQsB, inQeB, inScheme, counter)
        respBuf = self.dispatchCommand(TPM_CC.ZGen_2Phase, req)
        return self.processResponse(respBuf, ZGen_2PhaseResponse)
    # ZGen_2Phase()

    def ECC_Encrypt(self, keyHandle, plainText, inScheme):
        """ This command performs ECC encryption as described in Part 1, Annex D.

        Args:
            keyHandle (TPM_HANDLE): Reference to public portion of ECC key to
                use for encryption
                Auth Index: None
            plainText (bytes): Plaintext to be encrypted
            inScheme (TPMU_KDF_SCHEME): The KDF to use if scheme associated with
                keyHandle is TPM_ALG_NULL
                One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A,
                TPMS_KDF_SCHEME_KDF2, TPMS_KDF_SCHEME_KDF1_SP800_108,
                TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.

        Returns:
            C1 - The public ephemeral key used for ECDH
            C2 - The data block produced by the XOR process
            C3 - The integrity value
        """
        req = TPM2_ECC_Encrypt_REQUEST(keyHandle, plainText, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.ECC_Encrypt, req)
        return self.processResponse(respBuf, ECC_EncryptResponse)
    # ECC_Encrypt()

    def ECC_Decrypt(self, keyHandle, C1, C2, C3, inScheme):
        """ This command performs ECC decryption.

        Args:
            keyHandle (TPM_HANDLE): ECC key to use for decryption
                Auth Index: 1
                Auth Role: USER
            C1 (TPMS_ECC_POINT): The public ephemeral key used for ECDH
            C2 (bytes): The data block produced by the XOR process
            C3 (bytes): The integrity value
            inScheme (TPMU_KDF_SCHEME): The KDF to use if scheme associated with
                keyHandle is TPM_ALG_NULL
                One of: TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A,
                TPMS_KDF_SCHEME_KDF2, TPMS_KDF_SCHEME_KDF1_SP800_108,
                TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME.

        Returns:
            plainText - Decrypted output
        """
        req = TPM2_ECC_Decrypt_REQUEST(keyHandle, C1, C2, C3, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.ECC_Decrypt, req)
        res = self.processResponse(respBuf, ECC_DecryptResponse)
        return res.plainText if res else None
    # ECC_Decrypt()

    def EncryptDecrypt(self, keyHandle, decrypt, mode, ivIn, inData):
        """ NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is
        preferred. This should be reflected in platform-specific specifications.

        Args:
            keyHandle (TPM_HANDLE): The symmetric key used for the operation
                Auth Index: 1
                Auth Role: USER
            decrypt (int): If YES, then the operation is decryption; if NO, the
                operation is encryption
            mode (TPM_ALG_ID): Symmetric encryption/decryption mode
                this field shall match the default mode of the key or be TPM_ALG_NULL.
            ivIn (bytes): An initial value as required by the algorithm
            inData (bytes): The data to be encrypted/decrypted

        Returns:
            outData - Encrypted or decrypted output
            ivOut - Chaining value to use for IV in next round
        """
        req = TPM2_EncryptDecrypt_REQUEST(keyHandle, decrypt, mode, ivIn, inData)
        respBuf = self.dispatchCommand(TPM_CC.EncryptDecrypt, req)
        return self.processResponse(respBuf, EncryptDecryptResponse)
    # EncryptDecrypt()

    def EncryptDecrypt2(self, keyHandle, inData, decrypt, mode, ivIn):
        """ This command is identical to TPM2_EncryptDecrypt(), except that the
        inData parameter is the first parameter. This permits inData to be
        parameter encrypted.

        Args:
            keyHandle (TPM_HANDLE): The symmetric key used for the operation
                Auth Index: 1
                Auth Role: USER
            inData (bytes): The data to be encrypted/decrypted
            decrypt (int): If YES, then the operation is decryption; if NO, the
                operation is encryption
            mode (TPM_ALG_ID): Symmetric mode
                this field shall match the default mode of the key or be TPM_ALG_NULL.
            ivIn (bytes): An initial value as required by the algorithm

        Returns:
            outData - Encrypted or decrypted output
            ivOut - Chaining value to use for IV in next round
        """
        req = TPM2_EncryptDecrypt2_REQUEST(keyHandle, inData, decrypt, mode, ivIn)
        respBuf = self.dispatchCommand(TPM_CC.EncryptDecrypt2, req)
        return self.processResponse(respBuf, EncryptDecrypt2Response)
    # EncryptDecrypt2()

    def Hash(self, data, hashAlg, hierarchy):
        """ This command performs a hash operation on a data buffer and returns
        the results.

        Args:
            data (bytes): Data to be hashed
            hashAlg (TPM_ALG_ID): Algorithm for the hash being computed shall
                not be TPM_ALG_NULL
            hierarchy (TPM_HANDLE): Hierarchy to use for the ticket (TPM_RH_NULL
                allowed)

        Returns:
            outHash - Results
            validation - Ticket indicating that the sequence of octets used to
                         compute outDigest did not start with TPM_GENERATED_VALUE
                         will be a NULL ticket if the digest may not be signed
                         with a restricted key
        """
        req = TPM2_Hash_REQUEST(data, hashAlg, hierarchy)
        respBuf = self.dispatchCommand(TPM_CC.Hash, req)
        return self.processResponse(respBuf, HashResponse)
    # Hash()

    def HMAC(self, handle, buffer, hashAlg):
        """ This command performs an HMAC on the supplied data using the
        indicated hash algorithm.

        Args:
            handle (TPM_HANDLE): Handle for the symmetric signing key providing
                the HMAC key
                Auth Index: 1
                Auth Role: USER
            buffer (bytes): HMAC data
            hashAlg (TPM_ALG_ID): Algorithm to use for HMAC

        Returns:
            outHMAC - The returned HMAC in a sized buffer
        """
        req = TPM2_HMAC_REQUEST(handle, buffer, hashAlg)
        respBuf = self.dispatchCommand(TPM_CC.HMAC, req)
        res = self.processResponse(respBuf, HMACResponse)
        return res.outHMAC if res else None
    # HMAC()

    def MAC(self, handle, buffer, inScheme):
        """ This command performs an HMAC or a block cipher MAC on the supplied
        data using the indicated algorithm.

        Args:
            handle (TPM_HANDLE): Handle for the symmetric signing key providing
                the MAC key
                Auth Index: 1
                Auth Role: USER
            buffer (bytes): MAC data
            inScheme (TPM_ALG_ID): Algorithm to use for MAC

        Returns:
            outMAC - The returned MAC in a sized buffer
        """
        req = TPM2_MAC_REQUEST(handle, buffer, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.MAC, req)
        res = self.processResponse(respBuf, MACResponse)
        return res.outMAC if res else None
    # MAC()

    def GetRandom(self, bytesRequested):
        """ This command returns the next bytesRequested octets from the random
        number generator (RNG).

        Args:
            bytesRequested (int): Number of octets to return

        Returns:
            randomBytes - The random octets
        """
        req = TPM2_GetRandom_REQUEST(bytesRequested)
        respBuf = self.dispatchCommand(TPM_CC.GetRandom, req)
        res = self.processResponse(respBuf, GetRandomResponse)
        return res.randomBytes if res else None
    # GetRandom()

    def StirRandom(self, inData):
        """ This command is used to add "additional information" to the RNG state.

        Args:
            inData (bytes): Additional information
        """
        req = TPM2_StirRandom_REQUEST(inData)
        respBuf = self.dispatchCommand(TPM_CC.StirRandom, req)
        return self.processResponse(respBuf)
    # StirRandom()

    def HMAC_Start(self, handle, auth, hashAlg):
        """ This command starts an HMAC sequence. The TPM will create and
        initialize an HMAC sequence structure, assign a handle to the sequence,
        and set the authValue of the sequence object to the value in auth.

        Args:
            handle (TPM_HANDLE): Handle of an HMAC key
                Auth Index: 1
                Auth Role: USER
            auth (bytes): Authorization value for subsequent use of the sequence
            hashAlg (TPM_ALG_ID): The hash algorithm to use for the HMAC

        Returns:
            handle - A handle to reference the sequence
        """
        req = TPM2_HMAC_Start_REQUEST(handle, auth, hashAlg)
        respBuf = self.dispatchCommand(TPM_CC.HMAC_Start, req)
        res = self.processResponse(respBuf, HMAC_StartResponse)
        return res.handle if res else None
    # HMAC_Start()

    def MAC_Start(self, handle, auth, inScheme):
        """ This command starts a MAC sequence. The TPM will create and
        initialize a MAC sequence structure, assign a handle to the sequence,
        and set the authValue of the sequence object to the value in auth.

        Args:
            handle (TPM_HANDLE): Handle of a MAC key
                Auth Index: 1
                Auth Role: USER
            auth (bytes): Authorization value for subsequent use of the sequence
            inScheme (TPM_ALG_ID): The algorithm to use for the MAC

        Returns:
            handle - A handle to reference the sequence
        """
        req = TPM2_MAC_Start_REQUEST(handle, auth, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.MAC_Start, req)
        res = self.processResponse(respBuf, MAC_StartResponse)
        return res.handle if res else None
    # MAC_Start()

    def HashSequenceStart(self, auth, hashAlg):
        """ This command starts a hash or an Event Sequence. If hashAlg is an
        implemented hash, then a hash sequence is started. If hashAlg is
        TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither
        an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return
        TPM_RC_HASH.

        Args:
            auth (bytes): Authorization value for subsequent use of the sequence
            hashAlg (TPM_ALG_ID): The hash algorithm to use for the hash sequence
                An Event Sequence starts if this is TPM_ALG_NULL.

        Returns:
            handle - A handle to reference the sequence
        """
        req = TPM2_HashSequenceStart_REQUEST(auth, hashAlg)
        respBuf = self.dispatchCommand(TPM_CC.HashSequenceStart, req)
        res = self.processResponse(respBuf, HashSequenceStartResponse)
        return res.handle if res else None
    # HashSequenceStart()

    def SequenceUpdate(self, sequenceHandle, buffer):
        """ This command is used to add data to a hash or HMAC sequence. The
        amount of data in buffer may be any size up to the limits of the TPM.

        Args:
            sequenceHandle (TPM_HANDLE): Handle for the sequence object
                Auth Index: 1
                Auth Role: USER
            buffer (bytes): Data to be added to hash
        """
        req = TPM2_SequenceUpdate_REQUEST(sequenceHandle, buffer)
        respBuf = self.dispatchCommand(TPM_CC.SequenceUpdate, req)
        return self.processResponse(respBuf)
    # SequenceUpdate()

    def SequenceComplete(self, sequenceHandle, buffer, hierarchy):
        """ This command adds the last part of data, if any, to a hash/HMAC
        sequence and returns the result.

        Args:
            sequenceHandle (TPM_HANDLE): Authorization for the sequence
                Auth Index: 1
                Auth Role: USER
            buffer (bytes): Data to be added to the hash/HMAC
            hierarchy (TPM_HANDLE): Hierarchy of the ticket for a hash

        Returns:
            result - The returned HMAC or digest in a sized buffer
            validation - Ticket indicating that the sequence of octets used to
                         compute outDigest did not start with TPM_GENERATED_VALUE
                         This is a NULL Ticket when the sequence is HMAC.
        """
        req = TPM2_SequenceComplete_REQUEST(sequenceHandle, buffer, hierarchy)
        respBuf = self.dispatchCommand(TPM_CC.SequenceComplete, req)
        return self.processResponse(respBuf, SequenceCompleteResponse)
    # SequenceComplete()

    def EventSequenceComplete(self, pcrHandle, sequenceHandle, buffer):
        """ This command adds the last part of data, if any, to an Event
        Sequence and returns the result in a digest list. If pcrHandle
        references a PCR and not TPM_RH_NULL, then the returned digest list is
        processed in the same manner as the digest list input parameter to
        TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
        pcrHandle, it is extended with the associated digest value from the list.

        Args:
            pcrHandle (TPM_HANDLE): PCR to be extended with the Event data
                Auth Index: 1
                Auth Role: USER
            sequenceHandle (TPM_HANDLE): Authorization for the sequence
                Auth Index: 2
                Auth Role: USER
            buffer (bytes): Data to be added to the Event

        Returns:
            results - List of digests computed for the PCR
        """
        req = TPM2_EventSequenceComplete_REQUEST(pcrHandle, sequenceHandle, buffer)
        respBuf = self.dispatchCommand(TPM_CC.EventSequenceComplete, req)
        res = self.processResponse(respBuf, EventSequenceCompleteResponse)
        return res.results if res else None
    # EventSequenceComplete()

    def Certify(self, objectHandle, signHandle, qualifyingData, inScheme):
        """ The purpose of this command is to prove that an object with a
        specific Name is loaded in the TPM. By certifying that the object is
        loaded, the TPM warrants that a public area with a given Name is
        self-consistent and associated with a valid sensitive area. If a relying
        party has a public area that has the same Name as a Name certified with
        this command, then the values in that public area are correct.

        Args:
            objectHandle (TPM_HANDLE): Handle of the object to be certified
                Auth Index: 1
                Auth Role: ADMIN
            signHandle (TPM_HANDLE): Handle of the key used to sign the
                attestation structure
                Auth Index: 2
                Auth Role: USER
            qualifyingData (bytes): User provided qualifying data
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.

        Returns:
            certifyInfo - The structure that was signed
            signature - The asymmetric signature over certifyInfo using the key
                        referenced by signHandle
        """
        req = TPM2_Certify_REQUEST(objectHandle, signHandle, qualifyingData, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.Certify, req)
        return self.processResponse(respBuf, CertifyResponse)
    # Certify()

    def CertifyCreation(self, signHandle, objectHandle, qualifyingData, creationHash, inScheme, creationTicket):
        """ This command is used to prove the association between an object and
        its creation data. The TPM will validate that the ticket was produced by
        the TPM and that the ticket validates the association between a loaded
        public area and the provided hash of the creation data (creationHash).

        Args:
            signHandle (TPM_HANDLE): Handle of the key that will sign the
                attestation block
                Auth Index: 1
                Auth Role: USER
            objectHandle (TPM_HANDLE): The object associated with the creation data
                Auth Index: None
            qualifyingData (bytes): User-provided qualifying data
            creationHash (bytes): Hash of the creation data produced by
                TPM2_Create() or TPM2_CreatePrimary()
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
            creationTicket (TPMT_TK_CREATION): Ticket produced by TPM2_Create()
                or TPM2_CreatePrimary()

        Returns:
            certifyInfo - The structure that was signed
            signature - The signature over certifyInfo
        """
        req = TPM2_CertifyCreation_REQUEST(signHandle, objectHandle, qualifyingData, creationHash, inScheme, creationTicket)
        respBuf = self.dispatchCommand(TPM_CC.CertifyCreation, req)
        return self.processResponse(respBuf, CertifyCreationResponse)
    # CertifyCreation()

    def Quote(self, signHandle, qualifyingData, inScheme, PCRselect):
        """ This command is used to quote PCR values.

        Args:
            signHandle (TPM_HANDLE): Handle of key that will perform signature
                Auth Index: 1
                Auth Role: USER
            qualifyingData (bytes): Data supplied by the caller
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
            PCRselect (TPMS_PCR_SELECTION[]): PCR set to quote

        Returns:
            quoted - The quoted information
            signature - The signature over quoted
        """
        req = TPM2_Quote_REQUEST(signHandle, qualifyingData, inScheme, PCRselect)
        respBuf = self.dispatchCommand(TPM_CC.Quote, req)
        return self.processResponse(respBuf, QuoteResponse)
    # Quote()

    def GetSessionAuditDigest(self, privacyAdminHandle, signHandle, sessionHandle, qualifyingData, inScheme):
        """ This command returns a digital signature of the audit session digest.

        Args:
            privacyAdminHandle (TPM_HANDLE): Handle of the privacy administrator
                (TPM_RH_ENDORSEMENT)
                Auth Index: 1
                Auth Role: USER
            signHandle (TPM_HANDLE): Handle of the signing key
                Auth Index: 2
                Auth Role: USER
            sessionHandle (TPM_HANDLE): Handle of the audit session
                Auth Index: None
            qualifyingData (bytes): User-provided qualifying data may be zero-length
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.

        Returns:
            auditInfo - The audit information that was signed
            signature - The signature over auditInfo
        """
        req = TPM2_GetSessionAuditDigest_REQUEST(privacyAdminHandle, signHandle, sessionHandle, qualifyingData, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.GetSessionAuditDigest, req)
        return self.processResponse(respBuf, GetSessionAuditDigestResponse)
    # GetSessionAuditDigest()

    def GetCommandAuditDigest(self, privacyHandle, signHandle, qualifyingData, inScheme):
        """ This command returns the current value of the command audit digest,
        a digest of the commands being audited, and the audit hash algorithm.
        These values are placed in an attestation structure and signed with the
        key referenced by signHandle.

        Args:
            privacyHandle (TPM_HANDLE): Handle of the privacy administrator
                (TPM_RH_ENDORSEMENT)
                Auth Index: 1
                Auth Role: USER
            signHandle (TPM_HANDLE): The handle of the signing key
                Auth Index: 2
                Auth Role: USER
            qualifyingData (bytes): Other data to associate with this audit digest
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.

        Returns:
            auditInfo - The auditInfo that was signed
            signature - The signature over auditInfo
        """
        req = TPM2_GetCommandAuditDigest_REQUEST(privacyHandle, signHandle, qualifyingData, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.GetCommandAuditDigest, req)
        return self.processResponse(respBuf, GetCommandAuditDigestResponse)
    # GetCommandAuditDigest()

    def GetTime(self, privacyAdminHandle, signHandle, qualifyingData, inScheme):
        """ This command returns the current values of Time and Clock.

        Args:
            privacyAdminHandle (TPM_HANDLE): Handle of the privacy administrator
                (TPM_RH_ENDORSEMENT)
                Auth Index: 1
                Auth Role: USER
            signHandle (TPM_HANDLE): The keyHandle identifier of a loaded key
                that can perform digital signatures
                Auth Index: 2
                Auth Role: USER
            qualifyingData (bytes): Data to tick stamp
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.

        Returns:
            timeInfo - Standard TPM-generated attestation block
            signature - The signature over timeInfo
        """
        req = TPM2_GetTime_REQUEST(privacyAdminHandle, signHandle, qualifyingData, inScheme)
        respBuf = self.dispatchCommand(TPM_CC.GetTime, req)
        return self.processResponse(respBuf, GetTimeResponse)
    # GetTime()

    def CertifyX509(self, objectHandle, signHandle, reserved, inScheme, partialCertificate):
        """ The purpose of this command is to generate an X.509 certificate that
        proves an object with a specific public key and attributes is loaded in
        the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data
        structure to convey attestation information, TPM2_CertifyX509 encodes
        the attestation information in a DER-encoded X.509 certificate that is
        compliant with RFC5280 Internet X.509 Public Key Infrastructure
        Certificate and Certificate Revocation List (CRL) Profile.

        Args:
            objectHandle (TPM_HANDLE): Handle of the object to be certified
                Auth Index: 1
                Auth Role: ADMIN
            signHandle (TPM_HANDLE): Handle of the key used to sign the
                attestation structure
                Auth Index: 2
                Auth Role: USER
            reserved (bytes): Shall be an Empty Buffer
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
            partialCertificate (bytes): A DER encoded partial certificate

        Returns:
            addedToCertificate - A DER encoded SEQUENCE containing the DER
                                 encoded fields added to partialCertificate to
                                 make it a complete RFC5280 TBSCertificate.
            tbsDigest - The digest that was signed
            signature - The signature over tbsDigest
        """
        req = TPM2_CertifyX509_REQUEST(objectHandle, signHandle, reserved, inScheme, partialCertificate)
        respBuf = self.dispatchCommand(TPM_CC.CertifyX509, req)
        return self.processResponse(respBuf, CertifyX509Response)
    # CertifyX509()

    def Commit(self, signHandle, P1, s2, y2):
        """ TPM2_Commit() performs the first part of an ECC anonymous signing
        operation. The TPM will perform the point multiplications on the
        provided points and return intermediate signing values. The signHandle
        parameter shall refer to an ECC key and the signing scheme must be
        anonymous (TPM_RC_SCHEME).

        Args:
            signHandle (TPM_HANDLE): Handle of the key that will be used in the
                signing operation
                Auth Index: 1
                Auth Role: USER
            P1 (TPMS_ECC_POINT): A point (M) on the curve used by signHandle
            s2 (bytes): Octet array used to derive x-coordinate of a base point
            y2 (bytes): Y coordinate of the point associated with s2

        Returns:
            K - ECC point K [ds](x2, y2)
            L - ECC point L [r](x2, y2)
            E - ECC point E [r]P1
            counter - Least-significant 16 bits of commitCount
        """
        req = TPM2_Commit_REQUEST(signHandle, P1, s2, y2)
        respBuf = self.dispatchCommand(TPM_CC.Commit, req)
        return self.processResponse(respBuf, CommitResponse)
    # Commit()

    def EC_Ephemeral(self, curveID):
        """ TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase
        key exchange protocol.

        Args:
            curveID (TPM_ECC_CURVE): The curve for the computed ephemeral point

        Returns:
            Q - Ephemeral public key Q [r]G
            counter - Least-significant 16 bits of commitCount
        """
        req = TPM2_EC_Ephemeral_REQUEST(curveID)
        respBuf = self.dispatchCommand(TPM_CC.EC_Ephemeral, req)
        return self.processResponse(respBuf, EC_EphemeralResponse)
    # EC_Ephemeral()

    def VerifySignature(self, keyHandle, digest, signature):
        """ This command uses loaded keys to validate a signature on a message
        with the message digest passed to the TPM.

        Args:
            keyHandle (TPM_HANDLE): Handle of public key that will be used in
                the validation
                Auth Index: None
            digest (bytes): Digest of the signed message
            signature (TPMU_SIGNATURE): Signature to be tested
                One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS,
                TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2,
                TPMS_SIGNATURE_ECSCHNORR, TPMT_HA, TPMS_SCHEME_HASH,
                TPMS_NULL_SIGNATURE.

        Returns:
            validation - This ticket is produced by TPM2_VerifySignature(). This
                         formulation is used for multiple ticket uses. The
                         ticket provides evidence that the TPM has validated
                         that a digest was signed by a key with the Name of
                         keyName. The ticket is computed by
        """
        req = TPM2_VerifySignature_REQUEST(keyHandle, digest, signature)
        respBuf = self.dispatchCommand(TPM_CC.VerifySignature, req)
        res = self.processResponse(respBuf, VerifySignatureResponse)
        return res.validation if res else None
    # VerifySignature()

    def Sign(self, keyHandle, digest, inScheme, validation):
        """ This command causes the TPM to sign an externally provided hash with
        the specified symmetric or asymmetric signing key.

        Args:
            keyHandle (TPM_HANDLE): Handle of key that will perform signing
                Auth Index: 1
                Auth Role: USER
            digest (bytes): Digest to be signed
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                keyHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
            validation (TPMT_TK_HASHCHECK): Proof that digest was created by the
                TPM
                If keyHandle is not a restricted signing key, then this may be a
                NULL Ticket with tag = TPM_ST_CHECKHASH.

        Returns:
            signature - The signature
        """
        req = TPM2_Sign_REQUEST(keyHandle, digest, inScheme, validation)
        respBuf = self.dispatchCommand(TPM_CC.Sign, req)
        res = self.processResponse(respBuf, SignResponse)
        return res.signature if res else None
    # Sign()

    def SetCommandCodeAuditStatus(self, auth, auditAlg, setList, clearList):
        """ This command may be used by the Privacy Administrator or platform to
        change the audit status of a command or to set the hash algorithm used
        for the audit digest, but not both at the same time.

        Args:
            auth (TPM_HANDLE): TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            auditAlg (TPM_ALG_ID): Hash algorithm for the audit digest; if
                TPM_ALG_NULL, then the hash is not changed
            setList (TPM_CC[]): List of commands that will be added to those
                that will be audited
            clearList (TPM_CC[]): List of commands that will no longer be audited
        """
        req = TPM2_SetCommandCodeAuditStatus_REQUEST(auth, auditAlg, setList, clearList)
        respBuf = self.dispatchCommand(TPM_CC.SetCommandCodeAuditStatus, req)
        return self.processResponse(respBuf)
    # SetCommandCodeAuditStatus()

    def PCR_Extend(self, pcrHandle, digests):
        """ This command is used to cause an update to the indicated PCR. The
        digests parameter contains one or more tagged digest values identified
        by an algorithm ID. For each digest, the PCR associated with pcrHandle
        is Extended into the bank identified by the tag (hashAlg).

        Args:
            pcrHandle (TPM_HANDLE): Handle of the PCR
                Auth Handle: 1
                Auth Role: USER
            digests (TPMT_HA[]): List of tagged digest values to be extended
        """
        req = TPM2_PCR_Extend_REQUEST(pcrHandle, digests)
        respBuf = self.dispatchCommand(TPM_CC.PCR_Extend, req)
        return self.processResponse(respBuf)
    # PCR_Extend()

    def PCR_Event(self, pcrHandle, eventData):
        """ This command is used to cause an update to the indicated PCR.

        Args:
            pcrHandle (TPM_HANDLE): Handle of the PCR
                Auth Handle: 1
                Auth Role: USER
            eventData (bytes): Event data in sized buffer

        Returns:
            digests - Table 80 shows the basic hash-agile structure used in this
                      specification. To handle hash agility, this structure uses
                      the hashAlg parameter to indicate the algorithm used to
                      compute the digest and, by implication, the size of the digest.
        """
        req = TPM2_PCR_Event_REQUEST(pcrHandle, eventData)
        respBuf = self.dispatchCommand(TPM_CC.PCR_Event, req)
        res = self.processResponse(respBuf, PCR_EventResponse)
        return res.digests if res else None
    # PCR_Event()

    def PCR_Read(self, pcrSelectionIn):
        """ This command returns the values of all PCR specified in pcrSelectionIn.

        Args:
            pcrSelectionIn (TPMS_PCR_SELECTION[]): The selection of PCR to read

        Returns:
            pcrUpdateCounter - The current value of the PCR update counter
            pcrSelectionOut - The PCR in the returned list
            pcrValues - The contents of the PCR indicated in pcrSelectOut-
                        pcrSelection[] as tagged digests
        """
        req = TPM2_PCR_Read_REQUEST(pcrSelectionIn)
        respBuf = self.dispatchCommand(TPM_CC.PCR_Read, req)
        return self.processResponse(respBuf, PCR_ReadResponse)
    # PCR_Read()

    def PCR_Allocate(self, authHandle, pcrAllocation):
        """ This command is used to set the desired PCR allocation of PCR and
        algorithms. This command requires Platform Authorization.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            pcrAllocation (TPMS_PCR_SELECTION[]): The requested allocation

        Returns:
            allocationSuccess - YES if the allocation succeeded
            maxPCR - Maximum number of PCR that may be in a bank
            sizeNeeded - Number of octets required to satisfy the request
            sizeAvailable - Number of octets available. Computed before the allocation.
        """
        req = TPM2_PCR_Allocate_REQUEST(authHandle, pcrAllocation)
        respBuf = self.dispatchCommand(TPM_CC.PCR_Allocate, req)
        return self.processResponse(respBuf, PCR_AllocateResponse)
    # PCR_Allocate()

    def PCR_SetAuthPolicy(self, authHandle, authPolicy, hashAlg, pcrNum):
        """ This command is used to associate a policy with a PCR or group of
        PCR. The policy determines the conditions under which a PCR may be
        extended or reset.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            authPolicy (bytes): The desired authPolicy
            hashAlg (TPM_ALG_ID): The hash algorithm of the policy
            pcrNum (TPM_HANDLE): The PCR for which the policy is to be set
        """
        req = TPM2_PCR_SetAuthPolicy_REQUEST(authHandle, authPolicy, hashAlg, pcrNum)
        respBuf = self.dispatchCommand(TPM_CC.PCR_SetAuthPolicy, req)
        return self.processResponse(respBuf)
    # PCR_SetAuthPolicy()

    def PCR_SetAuthValue(self, pcrHandle, auth):
        """ This command changes the authValue of a PCR or group of PCR.

        Args:
            pcrHandle (TPM_HANDLE): Handle for a PCR that may have an
                authorization value set
                Auth Index: 1
                Auth Role: USER
            auth (bytes): The desired authorization value
        """
        req = TPM2_PCR_SetAuthValue_REQUEST(pcrHandle, auth)
        respBuf = self.dispatchCommand(TPM_CC.PCR_SetAuthValue, req)
        return self.processResponse(respBuf)
    # PCR_SetAuthValue()

    def PCR_Reset(self, pcrHandle):
        """ If the attribute of a PCR allows the PCR to be reset and proper
        authorization is provided, then this command may be used to set the PCR
        in all banks to zero. The attributes of the PCR may restrict the
        locality that can perform the reset operation.

        Args:
            pcrHandle (TPM_HANDLE): The PCR to reset
                Auth Index: 1
                Auth Role: USER
        """
        req = TPM2_PCR_Reset_REQUEST(pcrHandle)
        respBuf = self.dispatchCommand(TPM_CC.PCR_Reset, req)
        return self.processResponse(respBuf)
    # PCR_Reset()

    def PolicySigned(self, authObject, policySession, nonceTPM, cpHashA, policyRef, expiration, auth):
        """ This command includes a signed authorization in a policy. The
        command ties the policy to a signing key by including the Name of the
        signing key in the policyDigest

        Args:
            authObject (TPM_HANDLE): Handle for a key that will validate the signature
                Auth Index: None
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            nonceTPM (bytes): The policy nonce for the session
                This can be the Empty Buffer.
            cpHashA (bytes): Digest of the command parameters to which this
                authorization is limited
                This is not the cpHash for this command but the cpHash for the
                command to which this policy session will be applied. If it is
                not limited, the parameter will be the Empty Buffer.
            policyRef (bytes): A reference to a policy relating to the
                authorization may be the Empty Buffer
                Size is limited to be no larger than the nonce size supported on
                the TPM.
            expiration (int): Time when authorization will expire, measured in
                seconds from the time that nonceTPM was generated
                If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
            auth (TPMU_SIGNATURE): Signed authorization (not optional)
                One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS,
                TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2,
                TPMS_SIGNATURE_ECSCHNORR, TPMT_HA, TPMS_SCHEME_HASH,
                TPMS_NULL_SIGNATURE.

        Returns:
            timeout - Implementation-specific time value, used to indicate to
                      the TPM when the ticket expires
                      NOTE If policyTicket is a NULL Ticket, then this shall be
                      the Empty Buffer.
            policyTicket - Produced if the command succeeds and expiration in
                           the command was non-zero; this ticket will use the
                           TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
        """
        req = TPM2_PolicySigned_REQUEST(authObject, policySession, nonceTPM, cpHashA, policyRef, expiration, auth)
        respBuf = self.dispatchCommand(TPM_CC.PolicySigned, req)
        return self.processResponse(respBuf, PolicySignedResponse)
    # PolicySigned()

    def PolicySecret(self, authHandle, policySession, nonceTPM, cpHashA, policyRef, expiration):
        """ This command includes a secret-based authorization to a policy. The
        caller proves knowledge of the secret value using an authorization
        session using the authValue associated with authHandle. A password
        session, an HMAC session, or a policy session containing
        TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.

        Args:
            authHandle (TPM_HANDLE): Handle for an entity providing the authorization
                Auth Index: 1
                Auth Role: USER
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            nonceTPM (bytes): The policy nonce for the session
                This can be the Empty Buffer.
            cpHashA (bytes): Digest of the command parameters to which this
                authorization is limited
                This not the cpHash for this command but the cpHash for the
                command to which this policy session will be applied. If it is
                not limited, the parameter will be the Empty Buffer.
            policyRef (bytes): A reference to a policy relating to the
                authorization may be the Empty Buffer
                Size is limited to be no larger than the nonce size supported on
                the TPM.
            expiration (int): Time when authorization will expire, measured in
                seconds from the time that nonceTPM was generated
                If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.

        Returns:
            timeout - Implementation-specific time value used to indicate to the
                      TPM when the ticket expires
            policyTicket - Produced if the command succeeds and expiration in
                           the command was non-zero ( See 23.2.5). This ticket
                           will use the TPMT_ST_AUTH_SECRET structure tag
        """
        req = TPM2_PolicySecret_REQUEST(authHandle, policySession, nonceTPM, cpHashA, policyRef, expiration)
        respBuf = self.dispatchCommand(TPM_CC.PolicySecret, req)
        return self.processResponse(respBuf, PolicySecretResponse)
    # PolicySecret()

    def PolicyTicket(self, policySession, timeout, cpHashA, policyRef, authName, ticket):
        """ This command is similar to TPM2_PolicySigned() except that it takes
        a ticket instead of a signed authorization. The ticket represents a
        validated authorization that had an expiration time associated with it.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            timeout (bytes): Time when authorization will expire
                The contents are TPM specific. This shall be the value returned
                when ticket was produced.
            cpHashA (bytes): Digest of the command parameters to which this
                authorization is limited
                If it is not limited, the parameter will be the Empty Buffer.
            policyRef (bytes): Reference to a qualifier for the policy may be
                the Empty Buffer
            authName (bytes): Name of the object that provided the authorization
            ticket (TPMT_TK_AUTH): An authorization ticket returned by the TPM
                in response to a TPM2_PolicySigned() or TPM2_PolicySecret()
        """
        req = TPM2_PolicyTicket_REQUEST(policySession, timeout, cpHashA, policyRef, authName, ticket)
        respBuf = self.dispatchCommand(TPM_CC.PolicyTicket, req)
        return self.processResponse(respBuf)
    # PolicyTicket()

    def PolicyOR(self, policySession, pHashList):
        """ This command allows options in authorizations without requiring that
        the TPM evaluate all of the options. If a policy may be satisfied by
        different sets of conditions, the TPM need only evaluate one set that
        satisfies the policy. This command will indicate that one of the
        required sets of conditions has been satisfied.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            pHashList (TPM2B_DIGEST[]): The list of hashes to check for a match
        """
        req = TPM2_PolicyOR_REQUEST(policySession, pHashList)
        respBuf = self.dispatchCommand(TPM_CC.PolicyOR, req)
        return self.processResponse(respBuf)
    # PolicyOR()

    def PolicyPCR(self, policySession, pcrDigest, pcrs):
        """ This command is used to cause conditional gating of a policy based
        on PCR. This command together with TPM2_PolicyOR() allows one group of
        authorizations to occur when PCR are in one state and a different set of
        authorizations when the PCR are in a different state.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            pcrDigest (bytes): Expected digest value of the selected PCR using
                the hash algorithm of the session; may be zero length
            pcrs (TPMS_PCR_SELECTION[]): The PCR to include in the check digest
        """
        req = TPM2_PolicyPCR_REQUEST(policySession, pcrDigest, pcrs)
        respBuf = self.dispatchCommand(TPM_CC.PolicyPCR, req)
        return self.processResponse(respBuf)
    # PolicyPCR()

    def PolicyLocality(self, policySession, locality):
        """ This command indicates that the authorization will be limited to a
        specific locality.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            locality (TPMA_LOCALITY): The allowed localities for the policy
        """
        req = TPM2_PolicyLocality_REQUEST(policySession, locality)
        respBuf = self.dispatchCommand(TPM_CC.PolicyLocality, req)
        return self.processResponse(respBuf)
    # PolicyLocality()

    def PolicyNV(self, authHandle, nvIndex, policySession, operandB, offset, operation):
        """ This command is used to cause conditional gating of a policy based
        on the contents of an NV Index. It is an immediate assertion. The NV
        index is validated during the TPM2_PolicyNV() command, not when the
        session is used for authorization.

        Args:
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index of the area to read
                Auth Index: None
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            operandB (bytes): The second operand
            offset (int): The octet offset in the NV Index for the start of
                operand A
            operation (TPM_EO): The comparison to make
        """
        req = TPM2_PolicyNV_REQUEST(authHandle, nvIndex, policySession, operandB, offset, operation)
        respBuf = self.dispatchCommand(TPM_CC.PolicyNV, req)
        return self.processResponse(respBuf)
    # PolicyNV()

    def PolicyCounterTimer(self, policySession, operandB, offset, operation):
        """ This command is used to cause conditional gating of a policy based
        on the contents of the TPMS_TIME_INFO structure.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            operandB (bytes): The second operand
            offset (int): The octet offset in the TPMS_TIME_INFO structure for
                the start of operand A
            operation (TPM_EO): The comparison to make
        """
        req = TPM2_PolicyCounterTimer_REQUEST(policySession, operandB, offset, operation)
        respBuf = self.dispatchCommand(TPM_CC.PolicyCounterTimer, req)
        return self.processResponse(respBuf)
    # PolicyCounterTimer()

    def PolicyCommandCode(self, policySession, code):
        """ This command indicates that the authorization will be limited to a
        specific command code.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            code (TPM_CC): The allowed commandCode
        """
        req = TPM2_PolicyCommandCode_REQUEST(policySession, code)
        respBuf = self.dispatchCommand(TPM_CC.PolicyCommandCode, req)
        return self.processResponse(respBuf)
    # PolicyCommandCode()

    def PolicyPhysicalPresence(self, policySession):
        """ This command indicates that physical presence will need to be
        asserted at the time the authorization is performed.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
        """
        req = TPM2_PolicyPhysicalPresence_REQUEST(policySession)
        respBuf = self.dispatchCommand(TPM_CC.PolicyPhysicalPresence, req)
        return self.processResponse(respBuf)
    # PolicyPhysicalPresence()

    def PolicyCpHash(self, policySession, cpHashA):
        """ This command is used to allow a policy to be bound to a specific
        command and command parameters.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            cpHashA (bytes): The cpHash added to the policy
        """
        req = TPM2_PolicyCpHash_REQUEST(policySession, cpHashA)
        respBuf = self.dispatchCommand(TPM_CC.PolicyCpHash, req)
        return self.processResponse(respBuf)
    # PolicyCpHash()

    def PolicyNameHash(self, policySession, nameHash):
        """ This command allows a policy to be bound to a specific set of TPM
        entities without being bound to the parameters of the command. This is
        most useful for commands such as TPM2_Duplicate() and for
        TPM2_PCR_Event() when the referenced PCR requires a policy.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            nameHash (bytes): The digest to be added to the policy
        """
        req = TPM2_PolicyNameHash_REQUEST(policySession, nameHash)
        respBuf = self.dispatchCommand(TPM_CC.PolicyNameHash, req)
        return self.processResponse(respBuf)
    # PolicyNameHash()

    def PolicyDuplicationSelect(self, policySession, objectName, newParentName, includeObject):
        """ This command allows qualification of duplication to allow
        duplication to a selected new parent.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            objectName (bytes): The Name of the object to be duplicated
            newParentName (bytes): The Name of the new parent
            includeObject (int): If YES, the objectName will be included in the
                value in policySessionpolicyDigest
        """
        req = TPM2_PolicyDuplicationSelect_REQUEST(policySession, objectName, newParentName, includeObject)
        respBuf = self.dispatchCommand(TPM_CC.PolicyDuplicationSelect, req)
        return self.processResponse(respBuf)
    # PolicyDuplicationSelect()

    def PolicyAuthorize(self, policySession, approvedPolicy, policyRef, keySign, checkTicket):
        """ This command allows policies to change. If a policy were static,
        then it would be difficult to add users to a policy. This command lets a
        policy authority sign a new policy so that it may be used in an existing
        policy.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            approvedPolicy (bytes): Digest of the policy being approved
            policyRef (bytes): A policy qualifier
            keySign (bytes): Name of a key that can sign a policy addition
            checkTicket (TPMT_TK_VERIFIED): Ticket validating that
                approvedPolicy and policyRef were signed by keySign
        """
        req = TPM2_PolicyAuthorize_REQUEST(policySession, approvedPolicy, policyRef, keySign, checkTicket)
        respBuf = self.dispatchCommand(TPM_CC.PolicyAuthorize, req)
        return self.processResponse(respBuf)
    # PolicyAuthorize()

    def PolicyAuthValue(self, policySession):
        """ This command allows a policy to be bound to the authorization value
        of the authorized entity.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
        """
        req = TPM2_PolicyAuthValue_REQUEST(policySession)
        respBuf = self.dispatchCommand(TPM_CC.PolicyAuthValue, req)
        return self.processResponse(respBuf)
    # PolicyAuthValue()

    def PolicyPassword(self, policySession):
        """ This command allows a policy to be bound to the authorization value
        of the authorized object.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
        """
        req = TPM2_PolicyPassword_REQUEST(policySession)
        respBuf = self.dispatchCommand(TPM_CC.PolicyPassword, req)
        return self.processResponse(respBuf)
    # PolicyPassword()

    def PolicyGetDigest(self, policySession):
        """ This command returns the current policyDigest of the session. This
        command allows the TPM to be used to perform the actions required to
        pre-compute the authPolicy for an object.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session
                Auth Index: None

        Returns:
            policyDigest - The current value of the policySessionpolicyDigest
        """
        req = TPM2_PolicyGetDigest_REQUEST(policySession)
        respBuf = self.dispatchCommand(TPM_CC.PolicyGetDigest, req)
        res = self.processResponse(respBuf, PolicyGetDigestResponse)
        return res.policyDigest if res else None
    # PolicyGetDigest()

    def PolicyNvWritten(self, policySession, writtenSet):
        """ This command allows a policy to be bound to the TPMA_NV_WRITTEN
        attributes. This is a deferred assertion. Values are stored in the
        policy session context and checked when the policy is used for authorization.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            writtenSet (int): YES if NV Index is required to have been written
                NO if NV Index is required not to have been written
        """
        req = TPM2_PolicyNvWritten_REQUEST(policySession, writtenSet)
        respBuf = self.dispatchCommand(TPM_CC.PolicyNvWritten, req)
        return self.processResponse(respBuf)
    # PolicyNvWritten()

    def PolicyTemplate(self, policySession, templateHash):
        """ This command allows a policy to be bound to a specific creation
        template. This is most useful for an object creation command such as
        TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            templateHash (bytes): The digest to be added to the policy
        """
        req = TPM2_PolicyTemplate_REQUEST(policySession, templateHash)
        respBuf = self.dispatchCommand(TPM_CC.PolicyTemplate, req)
        return self.processResponse(respBuf)
    # PolicyTemplate()

    def PolicyAuthorizeNV(self, authHandle, nvIndex, policySession):
        """ This command provides a capability that is the equivalent of a
        revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket
        never expires, so the authorization may not be withdrawn. With this
        command, the approved policy is kept in an NV Index location so that the
        policy may be changed as needed to render the old policy unusable.

        Args:
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index of the area to read
                Auth Index: None
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
        """
        req = TPM2_PolicyAuthorizeNV_REQUEST(authHandle, nvIndex, policySession)
        respBuf = self.dispatchCommand(TPM_CC.PolicyAuthorizeNV, req)
        return self.processResponse(respBuf)
    # PolicyAuthorizeNV()

    def CreatePrimary(self, primaryHandle, inSensitive, inPublic, outsideInfo, creationPCR):
        """ This command is used to create a Primary Object under one of the
        Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses
        a TPM2B_PUBLIC as a template for the object to be created. The size of
        the unique field shall not be checked for consistency with the other
        object parameters. The command will create and load a Primary Object.
        The sensitive area is not returned.

        Args:
            primaryHandle (TPM_HANDLE): TPM_RH_ENDORSEMENT, TPM_RH_OWNER,
                TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
                Auth Index: 1
                Auth Role: USER
            inSensitive (TPMS_SENSITIVE_CREATE): The sensitive data, see TPM 2.0
                Part 1 Sensitive Values
            inPublic (TPMT_PUBLIC): The public template
            outsideInfo (bytes): Data that will be included in the creation data
                for this object to provide permanent, verifiable linkage between
                this object and some object owner data
            creationPCR (TPMS_PCR_SELECTION[]): PCR that will be used in
                creation data

        Returns:
            handle - Handle of type TPM_HT_TRANSIENT for created Primary Object
            outPublic - The public portion of the created object
            creationData - Contains a TPMT_CREATION_DATA
            creationHash - Digest of creationData using nameAlg of outPublic
            creationTicket - Ticket used by TPM2_CertifyCreation() to validate
                             that the creation data was produced by the TPM
            name - The name of the created object
        """
        req = TPM2_CreatePrimary_REQUEST(primaryHandle, inSensitive, inPublic, outsideInfo, creationPCR)
        respBuf = self.dispatchCommand(TPM_CC.CreatePrimary, req)
        return self.processResponse(respBuf, CreatePrimaryResponse)
    # CreatePrimary()

    def HierarchyControl(self, authHandle, enable, state):
        """ This command enables and disables use of a hierarchy and its
        associated NV storage. The command allows phEnable, phEnableNV,
        shEnable, and ehEnable to be changed when the proper authorization is provided.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_ENDORSEMENT, TPM_RH_OWNER or
                TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            enable (TPM_HANDLE): The enable being modified
                TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or
                TPM_RH_PLATFORM_NV
            state (int): YES if the enable should be SET, NO if the enable
                should be CLEAR
        """
        req = TPM2_HierarchyControl_REQUEST(authHandle, enable, state)
        respBuf = self.dispatchCommand(TPM_CC.HierarchyControl, req)
        return self.processResponse(respBuf)
    # HierarchyControl()

    def SetPrimaryPolicy(self, authHandle, authPolicy, hashAlg):
        """ This command allows setting of the authorization policy for the
        lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the
        storage hierarchy (ownerPolicy), and the endorsement hierarchy
        (endorsementPolicy). On TPMs implementing Authenticated Countdown Timers
        (ACT), this command may also be used to set the authorization policy for
        an ACT.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT,
                TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            authPolicy (bytes): An authorization policy digest; may be the Empty
                Buffer
                If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
            hashAlg (TPM_ALG_ID): The hash algorithm to use for the policy
                If the authPolicy is an Empty Buffer, then this field shall be
                TPM_ALG_NULL.
        """
        req = TPM2_SetPrimaryPolicy_REQUEST(authHandle, authPolicy, hashAlg)
        respBuf = self.dispatchCommand(TPM_CC.SetPrimaryPolicy, req)
        return self.processResponse(respBuf)
    # SetPrimaryPolicy()

    def ChangePPS(self, authHandle):
        """ This replaces the current platform primary seed (PPS) with a value
        from the RNG and sets platformPolicy to the default initialization value
        (the Empty Buffer).

        Args:
            authHandle (TPM_HANDLE): TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
        """
        req = TPM2_ChangePPS_REQUEST(authHandle)
        respBuf = self.dispatchCommand(TPM_CC.ChangePPS, req)
        return self.processResponse(respBuf)
    # ChangePPS()

    def ChangeEPS(self, authHandle):
        """ This replaces the current endorsement primary seed (EPS) with a
        value from the RNG and sets the Endorsement hierarchy controls to their
        default initialization values: ehEnable is SET, endorsementAuth and
        endorsementPolicy are both set to the Empty Buffer. It will flush any
        resident objects (transient or persistent) in the Endorsement hierarchy
        and not allow objects in the hierarchy associated with the previous EPS
        to be loaded.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_PLATFORM+{PP}
                Auth Handle: 1
                Auth Role: USER
        """
        req = TPM2_ChangeEPS_REQUEST(authHandle)
        respBuf = self.dispatchCommand(TPM_CC.ChangeEPS, req)
        return self.processResponse(respBuf)
    # ChangeEPS()

    def Clear(self, authHandle):
        """ This command removes all TPM context associated with a specific Owner.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
                Auth Handle: 1
                Auth Role: USER
        """
        req = TPM2_Clear_REQUEST(authHandle)
        respBuf = self.dispatchCommand(TPM_CC.Clear, req)
        return self.processResponse(respBuf)
    # Clear()

    def ClearControl(self, auth, disable):
        """ TPM2_ClearControl() disables and enables the execution of TPM2_Clear().

        Args:
            auth (TPM_HANDLE): TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
                Auth Handle: 1
                Auth Role: USER
            disable (int): YES if the disableOwnerClear flag is to be SET, NO if
                the flag is to be CLEAR.
        """
        req = TPM2_ClearControl_REQUEST(auth, disable)
        respBuf = self.dispatchCommand(TPM_CC.ClearControl, req)
        return self.processResponse(respBuf)
    # ClearControl()

    def HierarchyChangeAuth(self, authHandle, newAuth):
        """ This command allows the authorization secret for a hierarchy or
        lockout to be changed using the current authorization value as the
        command authorization.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT,
                TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            newAuth (bytes): New authorization value
        """
        req = TPM2_HierarchyChangeAuth_REQUEST(authHandle, newAuth)
        respBuf = self.dispatchCommand(TPM_CC.HierarchyChangeAuth, req)
        return self.processResponse(respBuf)
    # HierarchyChangeAuth()

    def DictionaryAttackLockReset(self, lockHandle):
        """ This command cancels the effect of a TPM lockout due to a number of
        successive authorization failures. If this command is properly
        authorized, the lockout counter is set to zero.

        Args:
            lockHandle (TPM_HANDLE): TPM_RH_LOCKOUT
                Auth Index: 1
                Auth Role: USER
        """
        req = TPM2_DictionaryAttackLockReset_REQUEST(lockHandle)
        respBuf = self.dispatchCommand(TPM_CC.DictionaryAttackLockReset, req)
        return self.processResponse(respBuf)
    # DictionaryAttackLockReset()

    def DictionaryAttackParameters(self, lockHandle, newMaxTries, newRecoveryTime, lockoutRecovery):
        """ This command changes the lockout parameters.

        Args:
            lockHandle (TPM_HANDLE): TPM_RH_LOCKOUT
                Auth Index: 1
                Auth Role: USER
            newMaxTries (int): Count of authorization failures before the
                lockout is imposed
            newRecoveryTime (int): Time in seconds before the authorization
                failure count is automatically decremented
                A value of zero indicates that DA protection is disabled.
            lockoutRecovery (int): Time in seconds after a lockoutAuth failure
                before use of lockoutAuth is allowed
                A value of zero indicates that a reboot is required.
        """
        req = TPM2_DictionaryAttackParameters_REQUEST(lockHandle, newMaxTries, newRecoveryTime, lockoutRecovery)
        respBuf = self.dispatchCommand(TPM_CC.DictionaryAttackParameters, req)
        return self.processResponse(respBuf)
    # DictionaryAttackParameters()

    def PP_Commands(self, auth, setList, clearList):
        """ This command is used to determine which commands require assertion
        of Physical Presence (PP) in addition to platformAuth/platformPolicy.

        Args:
            auth (TPM_HANDLE): TPM_RH_PLATFORM+PP
                Auth Index: 1
                Auth Role: USER + Physical Presence
            setList (TPM_CC[]): List of commands to be added to those that will
                require that Physical Presence be asserted
            clearList (TPM_CC[]): List of commands that will no longer require
                that Physical Presence be asserted
        """
        req = TPM2_PP_Commands_REQUEST(auth, setList, clearList)
        respBuf = self.dispatchCommand(TPM_CC.PP_Commands, req)
        return self.processResponse(respBuf)
    # PP_Commands()

    def SetAlgorithmSet(self, authHandle, algorithmSet):
        """ This command allows the platform to change the set of algorithms
        that are used by the TPM. The algorithmSet setting is a vendor-dependent
        value.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_PLATFORM
                Auth Index: 1
                Auth Role: USER
            algorithmSet (int): A TPM vendor-dependent value indicating the
                algorithm set selection
        """
        req = TPM2_SetAlgorithmSet_REQUEST(authHandle, algorithmSet)
        respBuf = self.dispatchCommand(TPM_CC.SetAlgorithmSet, req)
        return self.processResponse(respBuf)
    # SetAlgorithmSet()

    def FieldUpgradeStart(self, authorization, keyHandle, fuDigest, manifestSignature):
        """ This command uses platformPolicy and a TPM Vendor Authorization Key
        to authorize a Field Upgrade Manifest.

        Args:
            authorization (TPM_HANDLE): TPM_RH_PLATFORM+{PP}
                Auth Index:1
                Auth Role: ADMIN
            keyHandle (TPM_HANDLE): Handle of a public area that contains the
                TPM Vendor Authorization Key that will be used to validate
                manifestSignature
                Auth Index: None
            fuDigest (bytes): Digest of the first block in the field upgrade sequence
            manifestSignature (TPMU_SIGNATURE): Signature over fuDigest using
                the key associated with keyHandle (not optional)
                One of: TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS,
                TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2,
                TPMS_SIGNATURE_ECSCHNORR, TPMT_HA, TPMS_SCHEME_HASH,
                TPMS_NULL_SIGNATURE.
        """
        req = TPM2_FieldUpgradeStart_REQUEST(authorization, keyHandle, fuDigest, manifestSignature)
        respBuf = self.dispatchCommand(TPM_CC.FieldUpgradeStart, req)
        return self.processResponse(respBuf)
    # FieldUpgradeStart()

    def FieldUpgradeData(self, fuData):
        """ This command will take the actual field upgrade image to be
        installed on the TPM. The exact format of fuData is vendor-specific.
        This command is only possible following a successful
        TPM2_FieldUpgradeStart(). If the TPM has not received a properly
        authorized TPM2_FieldUpgradeStart(), then the TPM shall return
        TPM_RC_FIELDUPGRADE.

        Args:
            fuData (bytes): Field upgrade image data

        Returns:
            nextDigest - Tagged digest of the next block
                         TPM_ALG_NULL if field update is complete
            firstDigest - Tagged digest of the first block of the sequence
        """
        req = TPM2_FieldUpgradeData_REQUEST(fuData)
        respBuf = self.dispatchCommand(TPM_CC.FieldUpgradeData, req)
        return self.processResponse(respBuf, FieldUpgradeDataResponse)
    # FieldUpgradeData()

    def FirmwareRead(self, sequenceNumber):
        """ This command is used to read a copy of the current firmware
        installed in the TPM.

        Args:
            sequenceNumber (int): The number of previous calls to this command
                in this sequence
                set to 0 on the first call

        Returns:
            fuData - Field upgrade image data
        """
        req = TPM2_FirmwareRead_REQUEST(sequenceNumber)
        respBuf = self.dispatchCommand(TPM_CC.FirmwareRead, req)
        res = self.processResponse(respBuf, FirmwareReadResponse)
        return res.fuData if res else None
    # FirmwareRead()

    def ContextSave(self, saveHandle):
        """ This command saves a session context, object context, or sequence
        object context outside the TPM.

        Args:
            saveHandle (TPM_HANDLE): Handle of the resource to save
                Auth Index: None

        Returns:
            context - This structure is used in TPM2_ContextLoad() and
                      TPM2_ContextSave(). If the values of the TPMS_CONTEXT
                      structure in TPM2_ContextLoad() are not the same as the
                      values when the context was saved (TPM2_ContextSave()),
                      then the TPM shall not load the context.
        """
        req = TPM2_ContextSave_REQUEST(saveHandle)
        respBuf = self.dispatchCommand(TPM_CC.ContextSave, req)
        res = self.processResponse(respBuf, ContextSaveResponse)
        return res.context if res else None
    # ContextSave()

    def ContextLoad(self, context):
        """ This command is used to reload a context that has been saved by
        TPM2_ContextSave().

        Args:
            context (TPMS_CONTEXT): The context blob

        Returns:
            handle - The handle assigned to the resource after it has been
                     successfully loaded
        """
        req = TPM2_ContextLoad_REQUEST(context)
        respBuf = self.dispatchCommand(TPM_CC.ContextLoad, req)
        res = self.processResponse(respBuf, ContextLoadResponse)
        return res.handle if res else None
    # ContextLoad()

    def FlushContext(self, flushHandle):
        """ This command causes all context associated with a loaded object,
        sequence object, or session to be removed from TPM memory.

        Args:
            flushHandle (TPM_HANDLE): The handle of the item to flush
                NOTE This is a use of a handle as a parameter.
        """
        req = TPM2_FlushContext_REQUEST(flushHandle)
        respBuf = self.dispatchCommand(TPM_CC.FlushContext, req)
        return self.processResponse(respBuf)
    # FlushContext()

    def EvictControl(self, auth, objectHandle, persistentHandle):
        """ This command allows certain Transient Objects to be made persistent
        or a persistent object to be evicted.

        Args:
            auth (TPM_HANDLE): TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Handle: 1
                Auth Role: USER
            objectHandle (TPM_HANDLE): The handle of a loaded object
                Auth Index: None
            persistentHandle (TPM_HANDLE): If objectHandle is a transient object
                handle, then this is the persistent handle for the object
                if objectHandle is a persistent object handle, then it shall be
                the same value as persistentHandle
        """
        req = TPM2_EvictControl_REQUEST(auth, objectHandle, persistentHandle)
        respBuf = self.dispatchCommand(TPM_CC.EvictControl, req)
        return self.processResponse(respBuf)
    # EvictControl()

    def ReadClock(self):
        """ This command reads the current TPMS_TIME_INFO structure that
        contains the current setting of Time, Clock, resetCount, and restartCount.

        Returns:
            currentTime - This structure is used in, e.g., the TPM2_GetTime()
                          attestation and TPM2_ReadClock().
        """
        req = TPM2_ReadClock_REQUEST()
        respBuf = self.dispatchCommand(TPM_CC.ReadClock, req)
        res = self.processResponse(respBuf, ReadClockResponse)
        return res.currentTime if res else None
    # ReadClock()

    def ClockSet(self, auth, newTime):
        """ This command is used to advance the value of the TPMs Clock. The
        command will fail if newTime is less than the current value of Clock or
        if the new time is greater than FFFF00000000000016. If both of these
        checks succeed, Clock is set to newTime. If either of these checks
        fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.

        Args:
            auth (TPM_HANDLE): TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Handle: 1
                Auth Role: USER
            newTime (int): New Clock setting in milliseconds
        """
        req = TPM2_ClockSet_REQUEST(auth, newTime)
        respBuf = self.dispatchCommand(TPM_CC.ClockSet, req)
        return self.processResponse(respBuf)
    # ClockSet()

    def ClockRateAdjust(self, auth, rateAdjust):
        """ This command adjusts the rate of advance of Clock and Time to
        provide a better approximation to real time.

        Args:
            auth (TPM_HANDLE): TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Handle: 1
                Auth Role: USER
            rateAdjust (TPM_CLOCK_ADJUST): Adjustment to current Clock update rate
        """
        req = TPM2_ClockRateAdjust_REQUEST(auth, rateAdjust)
        respBuf = self.dispatchCommand(TPM_CC.ClockRateAdjust, req)
        return self.processResponse(respBuf)
    # ClockRateAdjust()

    def GetCapability(self, capability, property, propertyCount):
        """ This command returns various information regarding the TPM and its
        current state.

        Args:
            capability (TPM_CAP): Group selection; determines the format of the
                response
            property (int): Further definition of information
            propertyCount (int): Number of properties of the indicated type to return

        Returns:
            moreData - Flag to indicate if there are more values of this type
            capabilityData - The capability data
        """
        req = TPM2_GetCapability_REQUEST(capability, property, propertyCount)
        respBuf = self.dispatchCommand(TPM_CC.GetCapability, req)
        return self.processResponse(respBuf, GetCapabilityResponse)
    # GetCapability()

    def TestParms(self, parameters):
        """ This command is used to check to see if specific combinations of
        algorithm parameters are supported.

        Args:
            parameters (TPMU_PUBLIC_PARMS): Algorithm parameters to be validated
                One of: TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS,
                TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS.
        """
        req = TPM2_TestParms_REQUEST(parameters)
        respBuf = self.dispatchCommand(TPM_CC.TestParms, req)
        return self.processResponse(respBuf)
    # TestParms()

    def NV_DefineSpace(self, authHandle, auth, publicInfo):
        """ This command defines the attributes of an NV Index and causes the
        TPM to reserve space to hold the data associated with the NV Index. If a
        definition already exists at the NV Index, the TPM will return
        TPM_RC_NV_DEFINED.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            auth (bytes): The authorization value
            publicInfo (TPMS_NV_PUBLIC): The public parameters of the NV area
        """
        req = TPM2_NV_DefineSpace_REQUEST(authHandle, auth, publicInfo)
        respBuf = self.dispatchCommand(TPM_CC.NV_DefineSpace, req)
        return self.processResponse(respBuf)
    # NV_DefineSpace()

    def NV_UndefineSpace(self, authHandle, nvIndex):
        """ This command removes an Index from the TPM.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index to remove from NV space
                Auth Index: None
        """
        req = TPM2_NV_UndefineSpace_REQUEST(authHandle, nvIndex)
        respBuf = self.dispatchCommand(TPM_CC.NV_UndefineSpace, req)
        return self.processResponse(respBuf)
    # NV_UndefineSpace()

    def NV_UndefineSpaceSpecial(self, nvIndex, platform):
        """ This command allows removal of a platform-created NV Index that has
        TPMA_NV_POLICY_DELETE SET.

        Args:
            nvIndex (TPM_HANDLE): Index to be deleted
                Auth Index: 1
                Auth Role: ADMIN
            platform (TPM_HANDLE): TPM_RH_PLATFORM + {PP}
                Auth Index: 2
                Auth Role: USER
        """
        req = TPM2_NV_UndefineSpaceSpecial_REQUEST(nvIndex, platform)
        respBuf = self.dispatchCommand(TPM_CC.NV_UndefineSpaceSpecial, req)
        return self.processResponse(respBuf)
    # NV_UndefineSpaceSpecial()

    def NV_ReadPublic(self, nvIndex):
        """ This command is used to read the public area and Name of an NV
        Index. The public area of an Index is not privacy-sensitive and no
        authorization is required to read this data.

        Args:
            nvIndex (TPM_HANDLE): The NV Index
                Auth Index: None

        Returns:
            nvPublic - The public area of the NV Index
            nvName - The Name of the nvIndex
        """
        req = TPM2_NV_ReadPublic_REQUEST(nvIndex)
        respBuf = self.dispatchCommand(TPM_CC.NV_ReadPublic, req)
        return self.processResponse(respBuf, NV_ReadPublicResponse)
    # NV_ReadPublic()

    def NV_Write(self, authHandle, nvIndex, data, offset):
        """ This command writes a value to an area in NV memory that was
        previously defined by TPM2_NV_DefineSpace().

        Args:
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index of the area to write
                Auth Index: None
            data (bytes): The data to write
            offset (int): The octet offset into the NV Area
        """
        req = TPM2_NV_Write_REQUEST(authHandle, nvIndex, data, offset)
        respBuf = self.dispatchCommand(TPM_CC.NV_Write, req)
        return self.processResponse(respBuf)
    # NV_Write()

    def NV_Increment(self, authHandle, nvIndex):
        """ This command is used to increment the value in an NV Index that has
        the TPM_NT_COUNTER attribute. The data value of the NV Index is
        incremented by one.

        Args:
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index to increment
                Auth Index: None
        """
        req = TPM2_NV_Increment_REQUEST(authHandle, nvIndex)
        respBuf = self.dispatchCommand(TPM_CC.NV_Increment, req)
        return self.processResponse(respBuf)
    # NV_Increment()

    def NV_Extend(self, authHandle, nvIndex, data):
        """ This command extends a value to an area in NV memory that was
        previously defined by TPM2_NV_DefineSpace.

        Args:
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index to extend
                Auth Index: None
            data (bytes): The data to extend
        """
        req = TPM2_NV_Extend_REQUEST(authHandle, nvIndex, data)
        respBuf = self.dispatchCommand(TPM_CC.NV_Extend, req)
        return self.processResponse(respBuf)
    # NV_Extend()

    def NV_SetBits(self, authHandle, nvIndex, bits):
        """ This command is used to SET bits in an NV Index that was created as
        a bit field. Any number of bits from 0 to 64 may be SET. The contents of
        bits are ORed with the current contents of the NV Index.

        Args:
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): NV Index of the area in which the bit is to be
                set
                Auth Index: None
            bits (int): The data to OR with the current contents
        """
        req = TPM2_NV_SetBits_REQUEST(authHandle, nvIndex, bits)
        respBuf = self.dispatchCommand(TPM_CC.NV_SetBits, req)
        return self.processResponse(respBuf)
    # NV_SetBits()

    def NV_WriteLock(self, authHandle, nvIndex):
        """ If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an
        NV location are SET, then this command may be used to inhibit further
        writes of the NV Index.

        Args:
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index of the area to lock
                Auth Index: None
        """
        req = TPM2_NV_WriteLock_REQUEST(authHandle, nvIndex)
        respBuf = self.dispatchCommand(TPM_CC.NV_WriteLock, req)
        return self.processResponse(respBuf)
    # NV_WriteLock()

    def NV_GlobalWriteLock(self, authHandle):
        """ The command will SET TPMA_NV_WRITELOCKED for all indexes that have
        their TPMA_NV_GLOBALLOCK attribute SET.

        Args:
            authHandle (TPM_HANDLE): TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
                Auth Index: 1
                Auth Role: USER
        """
        req = TPM2_NV_GlobalWriteLock_REQUEST(authHandle)
        respBuf = self.dispatchCommand(TPM_CC.NV_GlobalWriteLock, req)
        return self.processResponse(respBuf)
    # NV_GlobalWriteLock()

    def NV_Read(self, authHandle, nvIndex, size, offset):
        """ This command reads a value from an area in NV memory previously
        defined by TPM2_NV_DefineSpace().

        Args:
            authHandle (TPM_HANDLE): The handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index to be read
                Auth Index: None
            size (int): Number of octets to read
            offset (int): Octet offset into the NV area
                This value shall be less than or equal to the size of the
                nvIndex data.

        Returns:
            data - The data read
        """
        req = TPM2_NV_Read_REQUEST(authHandle, nvIndex, size, offset)
        respBuf = self.dispatchCommand(TPM_CC.NV_Read, req)
        res = self.processResponse(respBuf, NV_ReadResponse)
        return res.data if res else None
    # NV_Read()

    def NV_ReadLock(self, authHandle, nvIndex):
        """ If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be
        used to prevent further reads of the NV Index until the next
        TPM2_Startup (TPM_SU_CLEAR).

        Args:
            authHandle (TPM_HANDLE): The handle indicating the source of the
                authorization value
                Auth Index: 1
                Auth Role: USER
            nvIndex (TPM_HANDLE): The NV Index to be locked
                Auth Index: None
        """
        req = TPM2_NV_ReadLock_REQUEST(authHandle, nvIndex)
        respBuf = self.dispatchCommand(TPM_CC.NV_ReadLock, req)
        return self.processResponse(respBuf)
    # NV_ReadLock()

    def NV_ChangeAuth(self, nvIndex, newAuth):
        """ This command allows the authorization secret for an NV Index to be changed.

        Args:
            nvIndex (TPM_HANDLE): Handle of the entity
                Auth Index: 1
                Auth Role: ADMIN
            newAuth (bytes): New authorization value
        """
        req = TPM2_NV_ChangeAuth_REQUEST(nvIndex, newAuth)
        respBuf = self.dispatchCommand(TPM_CC.NV_ChangeAuth, req)
        return self.processResponse(respBuf)
    # NV_ChangeAuth()

    def NV_Certify(self, signHandle, authHandle, nvIndex, qualifyingData, inScheme, size, offset):
        """ The purpose of this command is to certify the contents of an NV
        Index or portion of an NV Index.

        Args:
            signHandle (TPM_HANDLE): Handle of the key used to sign the
                attestation structure
                Auth Index: 1
                Auth Role: USER
            authHandle (TPM_HANDLE): Handle indicating the source of the
                authorization value for the NV Index
                Auth Index: 2
                Auth Role: USER
            nvIndex (TPM_HANDLE): Index for the area to be certified
                Auth Index: None
            qualifyingData (bytes): User-provided qualifying data
            inScheme (TPMU_SIG_SCHEME): Signing scheme to use if the scheme for
                signHandle is TPM_ALG_NULL
                One of: TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS,
                TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
                TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
                TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME.
            size (int): Number of octets to certify
            offset (int): Octet offset into the NV area
                This value shall be less than or equal to the size of the
                nvIndex data.

        Returns:
            certifyInfo - The structure that was signed
            signature - The asymmetric signature over certifyInfo using the key
                        referenced by signHandle
        """
        req = TPM2_NV_Certify_REQUEST(signHandle, authHandle, nvIndex, qualifyingData, inScheme, size, offset)
        respBuf = self.dispatchCommand(TPM_CC.NV_Certify, req)
        return self.processResponse(respBuf, NV_CertifyResponse)
    # NV_Certify()

    def AC_GetCapability(self, ac, capability, count):
        """ The purpose of this command is to obtain information about an
        Attached Component referenced by an AC handle.

        Args:
            ac (TPM_HANDLE): Handle indicating the Attached Component
                Auth Index: None
            capability (TPM_AT): Starting info type
            count (int): Maximum number of values to return

        Returns:
            moreData - Flag to indicate whether there are more values
            capabilitiesData - List of capabilities
        """
        req = TPM2_AC_GetCapability_REQUEST(ac, capability, count)
        respBuf = self.dispatchCommand(TPM_CC.AC_GetCapability, req)
        return self.processResponse(respBuf, AC_GetCapabilityResponse)
    # AC_GetCapability()

    def AC_Send(self, sendObject, authHandle, ac, acDataIn):
        """ The purpose of this command is to send (copy) a loaded object from
        the TPM to an Attached Component.

        Args:
            sendObject (TPM_HANDLE): Handle of the object being sent to ac
                Auth Index: 1
                Auth Role: DUP
            authHandle (TPM_HANDLE): The handle indicating the source of the
                authorization value
                Auth Index: 2
                Auth Role: USER
            ac (TPM_HANDLE): Handle indicating the Attached Component to which
                the object will be sent
                Auth Index: None
            acDataIn (bytes): Optional non sensitive information related to the object

        Returns:
            acDataOut - May include AC specific data or information about an error.
        """
        req = TPM2_AC_Send_REQUEST(sendObject, authHandle, ac, acDataIn)
        respBuf = self.dispatchCommand(TPM_CC.AC_Send, req)
        res = self.processResponse(respBuf, AC_SendResponse)
        return res.acDataOut if res else None
    # AC_Send()

    def Policy_AC_SendSelect(self, policySession, objectName, authHandleName, acName, includeObject):
        """ This command allows qualification of the sending (copying) of an
        Object to an Attached Component (AC). Qualification includes selection
        of the receiving AC and the method of authentication for the AC, and, in
        certain circumstances, the Object to be sent may be specified.

        Args:
            policySession (TPM_HANDLE): Handle for the policy session being extended
                Auth Index: None
            objectName (bytes): The Name of the Object to be sent
            authHandleName (bytes): The Name associated with authHandle used in
                the TPM2_AC_Send() command
            acName (bytes): The Name of the Attached Component to which the
                Object will be sent
            includeObject (int): If SET, objectName will be included in the
                value in policySessionpolicyDigest
        """
        req = TPM2_Policy_AC_SendSelect_REQUEST(policySession, objectName, authHandleName, acName, includeObject)
        respBuf = self.dispatchCommand(TPM_CC.Policy_AC_SendSelect, req)
        return self.processResponse(respBuf)
    # Policy_AC_SendSelect()

    def ACT_SetTimeout(self, actHandle, startTimeout):
        """ This command is used to set the time remaining before an
        Authenticated Countdown Timer (ACT) expires.

        Args:
            actHandle (TPM_HANDLE): Handle of the selected ACT
                Auth Index: 1
                Auth Role: USER
            startTimeout (int): The start timeout value for the ACT in seconds
        """
        req = TPM2_ACT_SetTimeout_REQUEST(actHandle, startTimeout)
        respBuf = self.dispatchCommand(TPM_CC.ACT_SetTimeout, req)
        return self.processResponse(respBuf)
    # ACT_SetTimeout()

    def Vendor_TCG_Test(self, inputData):
        """ This is a placeholder to allow testing of the dispatch code.

        Args:
            inputData (bytes): Dummy data

        Returns:
            outputData - Dummy data
        """
        req = TPM2_Vendor_TCG_Test_REQUEST(inputData)
        respBuf = self.dispatchCommand(TPM_CC.Vendor_TCG_Test, req)
        res = self.processResponse(respBuf, Vendor_TCG_TestResponse)
        return res.outputData if res else None
    # Vendor_TCG_Test()

# class Tpm
