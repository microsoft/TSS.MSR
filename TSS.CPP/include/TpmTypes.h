/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

/*
 * NOTE: this file is partially auto generated!
 *
 * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
 * is autogenerated from the TPM 2.0 Specification docs.
 *
 * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
 */

#pragma once
#include "TpmStructure.h"

#define TPM_ENUM_PROLOGUE(Enum) enum _##Enum {

#define TPM_ENUM_EPILOGUE(Enum) \
    };                                                              \
    Enum() {}                                                       \
    Enum(ValueType v) : TpmEnum(v) {}                               \
    TpmTypeId GetTypeId() const { return TpmTypeId::Enum##_ID; }

// Windows SDK headers may define this symbol
#ifdef _C2
#undef _C2
#endif

_TPMCPP_BEGIN

class _DLLEXP_ Tpm2;

// <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

// Identifier for all TPM-related types
enum class TpmTypeId
{
    None,
    TPM2B_XX_ID,
    TPML_XX_ID,
    BYTE_ID = 3,
    UINT8_ID = 4,
    INT8_ID = 5,
    UINT16_ID = 6,
    INT16_ID = 7,
    UINT32_ID = 8,
    INT32_ID = 9,
    UINT64_ID = 10,
    INT64_ID = 11,
    BOOL_ID = 12,
    TPM_HANDLE_ID = 13,
    TPMS_NULL_UNION_ID = 14,
    TPM_ALG_ID_ID = 15,
    TPM_ECC_CURVE_ID = 16,
    SHA1_ID = 17,
    SHA256_ID = 18,
    SHA384_ID = 19,
    SHA512_ID = 20,
    SM3_256_ID = 21,
    SHA3_256_ID = 22,
    SHA3_384_ID = 23,
    SHA3_512_ID = 24,
    TPMU_HA_ID = 25,
    Logic_ID = 26,
    TPM_SPEC_ID = 27,
    TPM_GENERATED_ID = 28,
    TPM_CC_ID = 29,
    ImplementationConstants_ID = 30,
    TPM_RC_ID = 31,
    TPM_CLOCK_ADJUST_ID = 32,
    TPM_EO_ID = 33,
    TPM_ST_ID = 34,
    TPM_SU_ID = 35,
    TPM_SE_ID = 36,
    TPM_CAP_ID = 37,
    TPM_PT_ID = 38,
    TPM_PT_PCR_ID = 39,
    TPM_PS_ID = 40,
    TPM_HT_ID = 41,
    TPM_RH_ID = 42,
    TPMA_ALGORITHM_ID = 43,
    TPMA_OBJECT_ID = 44,
    TPMA_SESSION_ID = 45,
    TPMA_LOCALITY_ID = 46,
    TPMA_PERMANENT_ID = 47,
    TPMA_STARTUP_CLEAR_ID = 48,
    TPMA_MEMORY_ID = 49,
    TPMA_CC_ID = 50,
    TPMA_MODES_ID = 51,
    TPMA_X509_KEY_USAGE_ID = 52,
    TPMA_ACT_ID = 53,
    TPMS_EMPTY_ID = 54,
    TPMS_ALGORITHM_DESCRIPTION_ID = 55,
    TPMT_HA_ID = 56,
    TPM2B_DIGEST_ID = 57,
    TPM2B_DATA_ID = 58,
    TPM2B_NONCE_ID = 59,
    TPM2B_AUTH_ID = 60,
    TPM2B_OPERAND_ID = 61,
    TPM2B_EVENT_ID = 62,
    TPM2B_MAX_BUFFER_ID = 63,
    TPM2B_MAX_NV_BUFFER_ID = 64,
    TPM2B_TIMEOUT_ID = 65,
    TPM2B_IV_ID = 66,
    TPMU_NAME_ID = 67,
    TPM2B_NAME_ID = 68,
    TPMS_PCR_SELECT_ID = 69,
    TPMS_PCR_SELECTION_ID = 70,
    TPMT_TK_CREATION_ID = 71,
    TPMT_TK_VERIFIED_ID = 72,
    TPMT_TK_AUTH_ID = 73,
    TPMT_TK_HASHCHECK_ID = 74,
    TPMS_ALG_PROPERTY_ID = 75,
    TPMS_TAGGED_PROPERTY_ID = 76,
    TPMS_TAGGED_PCR_SELECT_ID = 77,
    TPMS_TAGGED_POLICY_ID = 78,
    TPMS_ACT_DATA_ID = 79,
    TPML_CC_ID = 80,
    TPML_CCA_ID = 81,
    TPML_ALG_ID = 82,
    TPML_HANDLE_ID = 83,
    TPML_DIGEST_ID = 84,
    TPML_DIGEST_VALUES_ID = 85,
    TPML_PCR_SELECTION_ID = 86,
    TPML_ALG_PROPERTY_ID = 87,
    TPML_TAGGED_TPM_PROPERTY_ID = 88,
    TPML_TAGGED_PCR_PROPERTY_ID = 89,
    TPML_ECC_CURVE_ID = 90,
    TPML_TAGGED_POLICY_ID = 91,
    TPML_ACT_DATA_ID = 92,
    TPMU_CAPABILITIES_ID = 93,
    TPMS_CAPABILITY_DATA_ID = 94,
    TPMS_CLOCK_INFO_ID = 95,
    TPMS_TIME_INFO_ID = 96,
    TPMS_TIME_ATTEST_INFO_ID = 97,
    TPMS_CERTIFY_INFO_ID = 98,
    TPMS_QUOTE_INFO_ID = 99,
    TPMS_COMMAND_AUDIT_INFO_ID = 100,
    TPMS_SESSION_AUDIT_INFO_ID = 101,
    TPMS_CREATION_INFO_ID = 102,
    TPMS_NV_CERTIFY_INFO_ID = 103,
    TPMS_NV_DIGEST_CERTIFY_INFO_ID = 104,
    TPMU_ATTEST_ID = 105,
    TPMS_ATTEST_ID = 106,
    TPM2B_ATTEST_ID = 107,
    TPMS_AUTH_COMMAND_ID = 108,
    TPMS_AUTH_RESPONSE_ID = 109,
    TPMU_SYM_KEY_BITS_ID = 110,
    TPMU_SYM_MODE_ID = 111,
    TPMS_TDES_SYM_DETAILS_ID = 112,
    TPMS_AES_SYM_DETAILS_ID = 113,
    TPMS_SM4_SYM_DETAILS_ID = 114,
    TPMS_CAMELLIA_SYM_DETAILS_ID = 115,
    TPMS_ANY_SYM_DETAILS_ID = 116,
    TPMS_XOR_SYM_DETAILS_ID = 117,
    TPMS_NULL_SYM_DETAILS_ID = 118,
    TPMU_SYM_DETAILS_ID = 119,
    TPMT_SYM_DEF_ID = 120,
    TPMT_SYM_DEF_OBJECT_ID = 121,
    TPM2B_SYM_KEY_ID = 122,
    TPMS_SYMCIPHER_PARMS_ID = 123,
    TPM2B_LABEL_ID = 124,
    TPMS_DERIVE_ID = 125,
    TPM2B_DERIVE_ID = 126,
    TPMU_SENSITIVE_CREATE_ID = 127,
    TPM2B_SENSITIVE_DATA_ID = 128,
    TPMS_SENSITIVE_CREATE_ID = 129,
    TPM2B_SENSITIVE_CREATE_ID = 130,
    TPMS_SCHEME_HASH_ID = 131,
    TPMS_SCHEME_ECDAA_ID = 132,
    TPMS_SCHEME_HMAC_ID = 133,
    TPMS_SCHEME_XOR_ID = 134,
    TPMS_NULL_SCHEME_KEYEDHASH_ID = 135,
    TPMU_SCHEME_KEYEDHASH_ID = 136,
    TPMT_KEYEDHASH_SCHEME_ID = 137,
    TPMS_SIG_SCHEME_RSASSA_ID = 138,
    TPMS_SIG_SCHEME_RSAPSS_ID = 139,
    TPMS_SIG_SCHEME_ECDSA_ID = 140,
    TPMS_SIG_SCHEME_SM2_ID = 141,
    TPMS_SIG_SCHEME_ECSCHNORR_ID = 142,
    TPMS_SIG_SCHEME_ECDAA_ID = 143,
    TPMS_NULL_SIG_SCHEME_ID = 144,
    TPMU_SIG_SCHEME_ID = 145,
    TPMT_SIG_SCHEME_ID = 146,
    TPMS_ENC_SCHEME_OAEP_ID = 147,
    TPMS_ENC_SCHEME_RSAES_ID = 148,
    TPMS_KEY_SCHEME_ECDH_ID = 149,
    TPMS_KEY_SCHEME_ECMQV_ID = 150,
    TPMS_KDF_SCHEME_MGF1_ID = 151,
    TPMS_KDF_SCHEME_KDF1_SP800_56A_ID = 152,
    TPMS_KDF_SCHEME_KDF2_ID = 153,
    TPMS_KDF_SCHEME_KDF1_SP800_108_ID = 154,
    TPMS_NULL_KDF_SCHEME_ID = 155,
    TPMU_KDF_SCHEME_ID = 156,
    TPMT_KDF_SCHEME_ID = 157,
    TPMS_NULL_ASYM_SCHEME_ID = 158,
    TPMU_ASYM_SCHEME_ID = 159,
    TPMT_ASYM_SCHEME_ID = 160,
    TPMT_RSA_SCHEME_ID = 161,
    TPMT_RSA_DECRYPT_ID = 162,
    TPM2B_PUBLIC_KEY_RSA_ID = 163,
    TPM2B_PRIVATE_KEY_RSA_ID = 164,
    TPM2B_ECC_PARAMETER_ID = 165,
    TPMS_ECC_POINT_ID = 166,
    TPM2B_ECC_POINT_ID = 167,
    TPMT_ECC_SCHEME_ID = 168,
    TPMS_ALGORITHM_DETAIL_ECC_ID = 169,
    TPMS_SIGNATURE_RSA_ID = 170,
    TPMS_SIGNATURE_RSASSA_ID = 171,
    TPMS_SIGNATURE_RSAPSS_ID = 172,
    TPMS_SIGNATURE_ECC_ID = 173,
    TPMS_SIGNATURE_ECDSA_ID = 174,
    TPMS_SIGNATURE_ECDAA_ID = 175,
    TPMS_SIGNATURE_SM2_ID = 176,
    TPMS_SIGNATURE_ECSCHNORR_ID = 177,
    TPMS_NULL_SIGNATURE_ID = 178,
    TPMU_SIGNATURE_ID = 179,
    TPMT_SIGNATURE_ID = 180,
    TPMU_ENCRYPTED_SECRET_ID = 181,
    TPM2B_ENCRYPTED_SECRET_ID = 182,
    TPMU_PUBLIC_ID_ID = 183,
    TPMS_KEYEDHASH_PARMS_ID = 184,
    TPMS_ASYM_PARMS_ID = 185,
    TPMS_RSA_PARMS_ID = 186,
    TPMS_ECC_PARMS_ID = 187,
    TPMU_PUBLIC_PARMS_ID = 188,
    TPMT_PUBLIC_PARMS_ID = 189,
    TPMT_PUBLIC_ID = 190,
    TPM2B_PUBLIC_ID = 191,
    TPM2B_TEMPLATE_ID = 192,
    TPM2B_PRIVATE_VENDOR_SPECIFIC_ID = 193,
    TPMU_SENSITIVE_COMPOSITE_ID = 194,
    TPMT_SENSITIVE_ID = 195,
    TPM2B_SENSITIVE_ID = 196,
    _PRIVATE_ID = 197,
    TPM2B_PRIVATE_ID = 198,
    TPMS_ID_OBJECT_ID = 199,
    TPM2B_ID_OBJECT_ID = 200,
    TPM_NV_INDEX_ID = 201,
    TPM_NT_ID = 202,
    TPMS_NV_PIN_COUNTER_PARAMETERS_ID = 203,
    TPMA_NV_ID = 204,
    TPMS_NV_PUBLIC_ID = 205,
    TPM2B_NV_PUBLIC_ID = 206,
    TPM2B_CONTEXT_SENSITIVE_ID = 207,
    TPMS_CONTEXT_DATA_ID = 208,
    TPM2B_CONTEXT_DATA_ID = 209,
    TPMS_CONTEXT_ID = 210,
    TPMS_CREATION_DATA_ID = 211,
    TPM2B_CREATION_DATA_ID = 212,
    TPM_AT_ID = 213,
    TPM_AE_ID = 214,
    TPMS_AC_OUTPUT_ID = 215,
    TPML_AC_CAPABILITIES_ID = 216,
    PLATFORM_ID = 217,
    ALG_ID_VALUE_ID = 218,
    Implementation_ID = 219,
    TPM_HC_ID = 220,
    TPM2_Startup_REQUEST_ID = 221,
    StartupResponse_ID = 222,
    TPM2_Shutdown_REQUEST_ID = 223,
    ShutdownResponse_ID = 224,
    TPM2_SelfTest_REQUEST_ID = 225,
    SelfTestResponse_ID = 226,
    TPM2_IncrementalSelfTest_REQUEST_ID = 227,
    IncrementalSelfTestResponse_ID = 228,
    TPM2_GetTestResult_REQUEST_ID = 229,
    GetTestResultResponse_ID = 230,
    TPM2_StartAuthSession_REQUEST_ID = 231,
    StartAuthSessionResponse_ID = 232,
    TPM2_PolicyRestart_REQUEST_ID = 233,
    PolicyRestartResponse_ID = 234,
    TPM2_Create_REQUEST_ID = 235,
    CreateResponse_ID = 236,
    TPM2_Load_REQUEST_ID = 237,
    LoadResponse_ID = 238,
    TPM2_LoadExternal_REQUEST_ID = 239,
    LoadExternalResponse_ID = 240,
    TPM2_ReadPublic_REQUEST_ID = 241,
    ReadPublicResponse_ID = 242,
    TPM2_ActivateCredential_REQUEST_ID = 243,
    ActivateCredentialResponse_ID = 244,
    TPM2_MakeCredential_REQUEST_ID = 245,
    MakeCredentialResponse_ID = 246,
    TPM2_Unseal_REQUEST_ID = 247,
    UnsealResponse_ID = 248,
    TPM2_ObjectChangeAuth_REQUEST_ID = 249,
    ObjectChangeAuthResponse_ID = 250,
    TPM2_CreateLoaded_REQUEST_ID = 251,
    CreateLoadedResponse_ID = 252,
    TPM2_Duplicate_REQUEST_ID = 253,
    DuplicateResponse_ID = 254,
    TPM2_Rewrap_REQUEST_ID = 255,
    RewrapResponse_ID = 256,
    TPM2_Import_REQUEST_ID = 257,
    ImportResponse_ID = 258,
    TPM2_RSA_Encrypt_REQUEST_ID = 259,
    RSA_EncryptResponse_ID = 260,
    TPM2_RSA_Decrypt_REQUEST_ID = 261,
    RSA_DecryptResponse_ID = 262,
    TPM2_ECDH_KeyGen_REQUEST_ID = 263,
    ECDH_KeyGenResponse_ID = 264,
    TPM2_ECDH_ZGen_REQUEST_ID = 265,
    ECDH_ZGenResponse_ID = 266,
    TPM2_ECC_Parameters_REQUEST_ID = 267,
    ECC_ParametersResponse_ID = 268,
    TPM2_ZGen_2Phase_REQUEST_ID = 269,
    ZGen_2PhaseResponse_ID = 270,
    TPM2_ECC_Encrypt_REQUEST_ID = 271,
    ECC_EncryptResponse_ID = 272,
    TPM2_ECC_Decrypt_REQUEST_ID = 273,
    ECC_DecryptResponse_ID = 274,
    TPM2_EncryptDecrypt_REQUEST_ID = 275,
    EncryptDecryptResponse_ID = 276,
    TPM2_EncryptDecrypt2_REQUEST_ID = 277,
    EncryptDecrypt2Response_ID = 278,
    TPM2_Hash_REQUEST_ID = 279,
    HashResponse_ID = 280,
    TPM2_HMAC_REQUEST_ID = 281,
    HMACResponse_ID = 282,
    TPM2_MAC_REQUEST_ID = 283,
    MACResponse_ID = 284,
    TPM2_GetRandom_REQUEST_ID = 285,
    GetRandomResponse_ID = 286,
    TPM2_StirRandom_REQUEST_ID = 287,
    StirRandomResponse_ID = 288,
    TPM2_HMAC_Start_REQUEST_ID = 289,
    HMAC_StartResponse_ID = 290,
    TPM2_MAC_Start_REQUEST_ID = 291,
    MAC_StartResponse_ID = 292,
    TPM2_HashSequenceStart_REQUEST_ID = 293,
    HashSequenceStartResponse_ID = 294,
    TPM2_SequenceUpdate_REQUEST_ID = 295,
    SequenceUpdateResponse_ID = 296,
    TPM2_SequenceComplete_REQUEST_ID = 297,
    SequenceCompleteResponse_ID = 298,
    TPM2_EventSequenceComplete_REQUEST_ID = 299,
    EventSequenceCompleteResponse_ID = 300,
    TPM2_Certify_REQUEST_ID = 301,
    CertifyResponse_ID = 302,
    TPM2_CertifyCreation_REQUEST_ID = 303,
    CertifyCreationResponse_ID = 304,
    TPM2_Quote_REQUEST_ID = 305,
    QuoteResponse_ID = 306,
    TPM2_GetSessionAuditDigest_REQUEST_ID = 307,
    GetSessionAuditDigestResponse_ID = 308,
    TPM2_GetCommandAuditDigest_REQUEST_ID = 309,
    GetCommandAuditDigestResponse_ID = 310,
    TPM2_GetTime_REQUEST_ID = 311,
    GetTimeResponse_ID = 312,
    TPM2_CertifyX509_REQUEST_ID = 313,
    CertifyX509Response_ID = 314,
    TPM2_Commit_REQUEST_ID = 315,
    CommitResponse_ID = 316,
    TPM2_EC_Ephemeral_REQUEST_ID = 317,
    EC_EphemeralResponse_ID = 318,
    TPM2_VerifySignature_REQUEST_ID = 319,
    VerifySignatureResponse_ID = 320,
    TPM2_Sign_REQUEST_ID = 321,
    SignResponse_ID = 322,
    TPM2_SetCommandCodeAuditStatus_REQUEST_ID = 323,
    SetCommandCodeAuditStatusResponse_ID = 324,
    TPM2_PCR_Extend_REQUEST_ID = 325,
    PCR_ExtendResponse_ID = 326,
    TPM2_PCR_Event_REQUEST_ID = 327,
    PCR_EventResponse_ID = 328,
    TPM2_PCR_Read_REQUEST_ID = 329,
    PCR_ReadResponse_ID = 330,
    TPM2_PCR_Allocate_REQUEST_ID = 331,
    PCR_AllocateResponse_ID = 332,
    TPM2_PCR_SetAuthPolicy_REQUEST_ID = 333,
    PCR_SetAuthPolicyResponse_ID = 334,
    TPM2_PCR_SetAuthValue_REQUEST_ID = 335,
    PCR_SetAuthValueResponse_ID = 336,
    TPM2_PCR_Reset_REQUEST_ID = 337,
    PCR_ResetResponse_ID = 338,
    TPM2_PolicySigned_REQUEST_ID = 339,
    PolicySignedResponse_ID = 340,
    TPM2_PolicySecret_REQUEST_ID = 341,
    PolicySecretResponse_ID = 342,
    TPM2_PolicyTicket_REQUEST_ID = 343,
    PolicyTicketResponse_ID = 344,
    TPM2_PolicyOR_REQUEST_ID = 345,
    PolicyORResponse_ID = 346,
    TPM2_PolicyPCR_REQUEST_ID = 347,
    PolicyPCRResponse_ID = 348,
    TPM2_PolicyLocality_REQUEST_ID = 349,
    PolicyLocalityResponse_ID = 350,
    TPM2_PolicyNV_REQUEST_ID = 351,
    PolicyNVResponse_ID = 352,
    TPM2_PolicyCounterTimer_REQUEST_ID = 353,
    PolicyCounterTimerResponse_ID = 354,
    TPM2_PolicyCommandCode_REQUEST_ID = 355,
    PolicyCommandCodeResponse_ID = 356,
    TPM2_PolicyPhysicalPresence_REQUEST_ID = 357,
    PolicyPhysicalPresenceResponse_ID = 358,
    TPM2_PolicyCpHash_REQUEST_ID = 359,
    PolicyCpHashResponse_ID = 360,
    TPM2_PolicyNameHash_REQUEST_ID = 361,
    PolicyNameHashResponse_ID = 362,
    TPM2_PolicyDuplicationSelect_REQUEST_ID = 363,
    PolicyDuplicationSelectResponse_ID = 364,
    TPM2_PolicyAuthorize_REQUEST_ID = 365,
    PolicyAuthorizeResponse_ID = 366,
    TPM2_PolicyAuthValue_REQUEST_ID = 367,
    PolicyAuthValueResponse_ID = 368,
    TPM2_PolicyPassword_REQUEST_ID = 369,
    PolicyPasswordResponse_ID = 370,
    TPM2_PolicyGetDigest_REQUEST_ID = 371,
    PolicyGetDigestResponse_ID = 372,
    TPM2_PolicyNvWritten_REQUEST_ID = 373,
    PolicyNvWrittenResponse_ID = 374,
    TPM2_PolicyTemplate_REQUEST_ID = 375,
    PolicyTemplateResponse_ID = 376,
    TPM2_PolicyAuthorizeNV_REQUEST_ID = 377,
    PolicyAuthorizeNVResponse_ID = 378,
    TPM2_CreatePrimary_REQUEST_ID = 379,
    CreatePrimaryResponse_ID = 380,
    TPM2_HierarchyControl_REQUEST_ID = 381,
    HierarchyControlResponse_ID = 382,
    TPM2_SetPrimaryPolicy_REQUEST_ID = 383,
    SetPrimaryPolicyResponse_ID = 384,
    TPM2_ChangePPS_REQUEST_ID = 385,
    ChangePPSResponse_ID = 386,
    TPM2_ChangeEPS_REQUEST_ID = 387,
    ChangeEPSResponse_ID = 388,
    TPM2_Clear_REQUEST_ID = 389,
    ClearResponse_ID = 390,
    TPM2_ClearControl_REQUEST_ID = 391,
    ClearControlResponse_ID = 392,
    TPM2_HierarchyChangeAuth_REQUEST_ID = 393,
    HierarchyChangeAuthResponse_ID = 394,
    TPM2_DictionaryAttackLockReset_REQUEST_ID = 395,
    DictionaryAttackLockResetResponse_ID = 396,
    TPM2_DictionaryAttackParameters_REQUEST_ID = 397,
    DictionaryAttackParametersResponse_ID = 398,
    TPM2_PP_Commands_REQUEST_ID = 399,
    PP_CommandsResponse_ID = 400,
    TPM2_SetAlgorithmSet_REQUEST_ID = 401,
    SetAlgorithmSetResponse_ID = 402,
    TPM2_FieldUpgradeStart_REQUEST_ID = 403,
    FieldUpgradeStartResponse_ID = 404,
    TPM2_FieldUpgradeData_REQUEST_ID = 405,
    FieldUpgradeDataResponse_ID = 406,
    TPM2_FirmwareRead_REQUEST_ID = 407,
    FirmwareReadResponse_ID = 408,
    TPM2_ContextSave_REQUEST_ID = 409,
    ContextSaveResponse_ID = 410,
    TPM2_ContextLoad_REQUEST_ID = 411,
    ContextLoadResponse_ID = 412,
    TPM2_FlushContext_REQUEST_ID = 413,
    FlushContextResponse_ID = 414,
    TPM2_EvictControl_REQUEST_ID = 415,
    EvictControlResponse_ID = 416,
    TPM2_ReadClock_REQUEST_ID = 417,
    ReadClockResponse_ID = 418,
    TPM2_ClockSet_REQUEST_ID = 419,
    ClockSetResponse_ID = 420,
    TPM2_ClockRateAdjust_REQUEST_ID = 421,
    ClockRateAdjustResponse_ID = 422,
    TPM2_GetCapability_REQUEST_ID = 423,
    GetCapabilityResponse_ID = 424,
    TPM2_TestParms_REQUEST_ID = 425,
    TestParmsResponse_ID = 426,
    TPM2_NV_DefineSpace_REQUEST_ID = 427,
    NV_DefineSpaceResponse_ID = 428,
    TPM2_NV_UndefineSpace_REQUEST_ID = 429,
    NV_UndefineSpaceResponse_ID = 430,
    TPM2_NV_UndefineSpaceSpecial_REQUEST_ID = 431,
    NV_UndefineSpaceSpecialResponse_ID = 432,
    TPM2_NV_ReadPublic_REQUEST_ID = 433,
    NV_ReadPublicResponse_ID = 434,
    TPM2_NV_Write_REQUEST_ID = 435,
    NV_WriteResponse_ID = 436,
    TPM2_NV_Increment_REQUEST_ID = 437,
    NV_IncrementResponse_ID = 438,
    TPM2_NV_Extend_REQUEST_ID = 439,
    NV_ExtendResponse_ID = 440,
    TPM2_NV_SetBits_REQUEST_ID = 441,
    NV_SetBitsResponse_ID = 442,
    TPM2_NV_WriteLock_REQUEST_ID = 443,
    NV_WriteLockResponse_ID = 444,
    TPM2_NV_GlobalWriteLock_REQUEST_ID = 445,
    NV_GlobalWriteLockResponse_ID = 446,
    TPM2_NV_Read_REQUEST_ID = 447,
    NV_ReadResponse_ID = 448,
    TPM2_NV_ReadLock_REQUEST_ID = 449,
    NV_ReadLockResponse_ID = 450,
    TPM2_NV_ChangeAuth_REQUEST_ID = 451,
    NV_ChangeAuthResponse_ID = 452,
    TPM2_NV_Certify_REQUEST_ID = 453,
    NV_CertifyResponse_ID = 454,
    TPM2_AC_GetCapability_REQUEST_ID = 455,
    AC_GetCapabilityResponse_ID = 456,
    TPM2_AC_Send_REQUEST_ID = 457,
    AC_SendResponse_ID = 458,
    TPM2_Policy_AC_SendSelect_REQUEST_ID = 459,
    Policy_AC_SendSelectResponse_ID = 460,
    TPM2_ACT_SetTimeout_REQUEST_ID = 461,
    ACT_SetTimeoutResponse_ID = 462,
    TPM2_Vendor_TCG_Test_REQUEST_ID = 463,
    Vendor_TCG_TestResponse_ID = 464,
    TPMS_SCHEME_RSASSA_ID = TPMS_SIG_SCHEME_RSASSA_ID,
    TPMS_SCHEME_RSAPSS_ID = TPMS_SIG_SCHEME_RSAPSS_ID,
    TPMS_SCHEME_ECDSA_ID = TPMS_SIG_SCHEME_ECDSA_ID,
    TPMS_SCHEME_SM2_ID = TPMS_SIG_SCHEME_SM2_ID,
    TPMS_SCHEME_ECSCHNORR_ID = TPMS_SIG_SCHEME_ECSCHNORR_ID,
    TPMS_SCHEME_OAEP_ID = TPMS_ENC_SCHEME_OAEP_ID,
    TPMS_SCHEME_RSAES_ID = TPMS_ENC_SCHEME_RSAES_ID,
    TPMS_SCHEME_ECDH_ID = TPMS_KEY_SCHEME_ECDH_ID,
    TPMS_SCHEME_ECMQV_ID = TPMS_KEY_SCHEME_ECMQV_ID,
    TPMS_SCHEME_MGF1_ID = TPMS_KDF_SCHEME_MGF1_ID,
    TPMS_SCHEME_KDF1_SP800_56A_ID = TPMS_KDF_SCHEME_KDF1_SP800_56A_ID,
    TPMS_SCHEME_KDF2_ID = TPMS_KDF_SCHEME_KDF2_ID,
    TPMS_SCHEME_KDF1_SP800_108_ID = TPMS_KDF_SCHEME_KDF1_SP800_108_ID,
    TssObject_ID = 465,
    PcrValue_ID = 466,
    SessionIn_ID = 467,
    SessionOut_ID = 468,
    CommandHeader_ID = 469,
    TSS_KEY_ID = 470,
    TPM2B_DIGEST_SYMCIPHER_ID = 471,
    TPM2B_DIGEST_KEYEDHASH_ID = 472
};

/// <summary>
/// Table 2 is the list of algorithms to which the TCG has assigned an algorithm identifier
/// along with its numeric identifier.
/// </summary>
struct TPM_ALG_ID : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_ALG_ID)
    
    /// <summary> should not occur </summary>
    _ERROR = 0x0000,
    
    /// <summary> an object type that contains an RSA key </summary>
    FIRST = 0x0001,
    
    /// <summary> an object type that contains an RSA key </summary>
    RSA = 0x0001,
    
    /// <summary>
    /// block cipher with various key sizes (Triple Data Encryption Algorithm, commonly called
    /// Triple Data Encryption Standard)
    /// </summary>
    TDES = 0x0003,
    
    /// <summary> hash algorithm producing a 160-bit digest </summary>
    SHA = 0x0004,
    
    /// <summary> redefinition for documentation consistency </summary>
    SHA1 = 0x0004,
    
    /// <summary> Hash Message Authentication Code (HMAC) algorithm </summary>
    HMAC = 0x0005,
    
    /// <summary> block cipher with various key sizes </summary>
    AES = 0x0006,
    
    /// <summary> hash-based mask-generation function </summary>
    MGF1 = 0x0007,
    
    /// <summary>
    /// an object type that may use XOR for encryption or an HMAC for signing and may also refer
    /// to a data object that is neither signing nor encrypting
    /// </summary>
    KEYEDHASH = 0x0008,
    
    /// <summary> hash-based stream cipher </summary>
    XOR = 0x000A,
    
    /// <summary> hash algorithm producing a 256-bit digest </summary>
    SHA256 = 0x000B,
    
    /// <summary> hash algorithm producing a 384-bit digest </summary>
    SHA384 = 0x000C,
    
    /// <summary> hash algorithm producing a 512-bit digest </summary>
    SHA512 = 0x000D,
    
    /// <summary> Indication that no algorithm is selected </summary>
    _NULL = 0x0010,
    
    /// <summary> hash algorithm producing a 256-bit digest </summary>
    SM3_256 = 0x0012,
    
    /// <summary> symmetric block cipher with 128 bit key </summary>
    SM4 = 0x0013,
    
    /// <summary> a signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5) </summary>
    RSASSA = 0x0014,
    
    /// <summary> a padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5) </summary>
    RSAES = 0x0015,
    
    /// <summary> a signature algorithm defined in section 8.1 (RSASSA-PSS) </summary>
    RSAPSS = 0x0016,
    
    /// <summary> a padding algorithm defined in Section 7.1 (RSAES_OAEP) </summary>
    OAEP = 0x0017,
    
    /// <summary> signature algorithm using elliptic curve cryptography (ECC) </summary>
    ECDSA = 0x0018,
    
    /// <summary>
    /// secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman,
    /// C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC
    /// CDH) defined in 6.1.1.2
    /// </summary>
    ECDH = 0x0019,
    
    /// <summary> elliptic-curve based, anonymous signing scheme </summary>
    ECDAA = 0x001A,
    
    /// <summary>
    /// depending on context, either an elliptic-curve-based signature algorithm, encryption
    /// algorithm, or key exchange protocol
    /// </summary>
    SM2 = 0x001B,
    
    /// <summary> elliptic-curve based Schnorr signature </summary>
    ECSCHNORR = 0x001C,
    
    /// <summary> two-phase elliptic-curve key exchange C(2, 2, ECC MQV) Section 6.1.1.4 </summary>
    ECMQV = 0x001D,
    
    /// <summary> concatenation key derivation function (approved alternative 1) Section 5.8.1 </summary>
    KDF1_SP800_56A = 0x0020,
    
    /// <summary> key derivation function KDF2 Section 13.2 </summary>
    KDF2 = 0x0021,
    
    /// <summary> a key derivation method SP800-108, Section 5.1 KDF in Counter Mode </summary>
    KDF1_SP800_108 = 0x0022,
    
    /// <summary> prime field ECC </summary>
    ECC = 0x0023,
    
    /// <summary> the object type for a symmetric block cipher key </summary>
    SYMCIPHER = 0x0025,
    
    /// <summary> symmetric block cipher with various key sizes </summary>
    CAMELLIA = 0x0026,
    
    /// <summary> Hash algorithm producing a 256-bit digest </summary>
    SHA3_256 = 0x0027,
    
    /// <summary> Hash algorithm producing a 384-bit digest </summary>
    SHA3_384 = 0x0028,
    
    /// <summary> Hash algorithm producing a 512-bit digest </summary>
    SHA3_512 = 0x0029,
    
    CMAC = 0x003F,
    
    /// <summary>
    /// Counter mode if implemented, all symmetric block ciphers (S type) implemented shall
    /// be capable of using this mode.
    /// </summary>
    CTR = 0x0040,
    
    /// <summary>
    /// Output Feedback mode if implemented, all symmetric block ciphers (S type) implemented shall
    /// be capable of using this mode.
    /// </summary>
    OFB = 0x0041,
    
    /// <summary>
    /// Cipher Block Chaining mode if implemented, all symmetric block ciphers (S type) implemented
    /// shall be capable of using this mode.
    /// </summary>
    CBC = 0x0042,
    
    /// <summary>
    /// Cipher Feedback mode if implemented, all symmetric block ciphers (S type) implemented shall
    /// be capable of using this mode.
    /// </summary>
    CFB = 0x0043,
    
    /// <summary>
    /// Electronic Codebook mode if implemented, all implemented symmetric block ciphers (S type)
    /// shall be capable of using this mode.
    /// NOTE This mode is not recommended for uses unless the key is frequently
    /// rotated such as in video codecs
    /// </summary>
    ECB = 0x0044,
    
    LAST = 0x0044,
    
    /// <summary> Phony alg ID to be used for the first union member with no selector </summary>
    ANY = 0x7FFF,
    
    /// <summary> Phony alg ID to be used for the second union member with no selector </summary>
    ANY2 = 0x7FFE
    TPM_ENUM_EPILOGUE(TPM_ALG_ID)
};

/// <summary>
/// Table 4 is the list of identifiers for TCG-registered curve ID values for
/// elliptic curve cryptography.
/// </summary>
struct TPM_ECC_CURVE : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_ECC_CURVE)
    
    NONE = 0x0000,
    
    NIST_P192 = 0x0001,
    
    NIST_P224 = 0x0002,
    
    NIST_P256 = 0x0003,
    
    NIST_P384 = 0x0004,
    
    NIST_P521 = 0x0005,
    
    /// <summary> curve to support ECDAA </summary>
    BN_P256 = 0x0010,
    
    /// <summary> curve to support ECDAA </summary>
    BN_P638 = 0x0011,
    
    SM2_P256 = 0x0020,
    
    TEST_P192 = 0x0021
    TPM_ENUM_EPILOGUE(TPM_ECC_CURVE)
};

/// <summary> Table 13 Defines for SHA1 Hash Values </summary>
struct SHA1 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA1)
    
    /// <summary> size of digest in octets </summary>
    DIGEST_SIZE = 20,
    
    /// <summary> size of hash block in octets </summary>
    BLOCK_SIZE = 64
    TPM_ENUM_EPILOGUE(SHA1)
};

/// <summary> Table 14 Defines for SHA256 Hash Values </summary>
struct SHA256 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA256)
    
    /// <summary> size of digest </summary>
    DIGEST_SIZE = 32,
    
    /// <summary> size of hash block </summary>
    BLOCK_SIZE = 64
    TPM_ENUM_EPILOGUE(SHA256)
};

/// <summary> Table 15 Defines for SHA384 Hash Values </summary>
struct SHA384 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA384)
    
    /// <summary> size of digest in octets </summary>
    DIGEST_SIZE = 48,
    
    /// <summary> size of hash block in octets </summary>
    BLOCK_SIZE = 128
    TPM_ENUM_EPILOGUE(SHA384)
};

/// <summary> Table 16 Defines for SHA512 Hash Values </summary>
struct SHA512 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA512)
    
    /// <summary> size of digest in octets </summary>
    DIGEST_SIZE = 64,
    
    /// <summary> size of hash block in octets </summary>
    BLOCK_SIZE = 128
    TPM_ENUM_EPILOGUE(SHA512)
};

/// <summary> Table 17 Defines for SM3_256 Hash Values </summary>
struct SM3_256 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SM3_256)
    
    /// <summary> size of digest in octets </summary>
    DIGEST_SIZE = 32,
    
    /// <summary> size of hash block in octets </summary>
    BLOCK_SIZE = 64
    TPM_ENUM_EPILOGUE(SM3_256)
};

/// <summary> Table 18 Defines for SHA3_256 Hash Values </summary>
struct SHA3_256 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA3_256)
    
    /// <summary> size of digest in octets </summary>
    DIGEST_SIZE = 32,
    
    /// <summary> size of hash block in octets </summary>
    BLOCK_SIZE = 136
    TPM_ENUM_EPILOGUE(SHA3_256)
};

/// <summary> Table 19 Defines for SHA3_384 Hash Values </summary>
struct SHA3_384 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA3_384)
    
    /// <summary> size of digest in octets </summary>
    DIGEST_SIZE = 48,
    
    /// <summary> size of hash block in octets </summary>
    BLOCK_SIZE = 104
    TPM_ENUM_EPILOGUE(SHA3_384)
};

/// <summary> Table 20 Defines for SHA3_512 Hash Values </summary>
struct SHA3_512 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA3_512)
    
    /// <summary> size of digest in octets </summary>
    DIGEST_SIZE = 64,
    
    /// <summary> size of hash block in octets </summary>
    BLOCK_SIZE = 72
    TPM_ENUM_EPILOGUE(SHA3_512)
};

/// <summary> Table 4 Defines for Logic Values </summary>
struct Logic : public TpmEnum<BYTE>
{
    TPM_ENUM_PROLOGUE(Logic)
    
    _TRUE = 1,
    
    _FALSE = 0,
    
    YES = 1,
    
    NO = 0,
    
    SET = 1,
    
    CLEAR = 0
    TPM_ENUM_EPILOGUE(Logic)
};

/// <summary> These values are readable with TPM2_GetCapability() (see 6.13 for the format). </summary>
struct TPM_SPEC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_SPEC)
    
    /// <summary> ASCII 2.0 with null terminator </summary>
    FAMILY = 0x322E3000,
    
    /// <summary> the level number for the specification </summary>
    LEVEL = 0,
    
    /// <summary> the version number of the spec (001.62 * 100) </summary>
    VERSION = 162,
    
    /// <summary> the year of the version </summary>
    YEAR = 2019,
    
    /// <summary> the day of the year (December 26) </summary>
    DAY_OF_YEAR = 360
    TPM_ENUM_EPILOGUE(TPM_SPEC)
};

/// <summary> This constant value differentiates TPM-generated structures from non-TPM structures. </summary>
struct TPM_GENERATED : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_GENERATED)
    
    /// <summary> 0xFF TCG (FF 54 43 4716) </summary>
    VALUE = 0xff544347
    TPM_ENUM_EPILOGUE(TPM_GENERATED)
};

struct TPM_CC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_CC)
    
    /// <summary> Compile variable. May decrease based on implementation. </summary>
    FIRST = 0x0000011F,
    
    NV_UndefineSpaceSpecial = 0x0000011F,
    
    EvictControl = 0x00000120,
    
    HierarchyControl = 0x00000121,
    
    NV_UndefineSpace = 0x00000122,
    
    ChangeEPS = 0x00000124,
    
    ChangePPS = 0x00000125,
    
    Clear = 0x00000126,
    
    ClearControl = 0x00000127,
    
    ClockSet = 0x00000128,
    
    HierarchyChangeAuth = 0x00000129,
    
    NV_DefineSpace = 0x0000012A,
    
    PCR_Allocate = 0x0000012B,
    
    PCR_SetAuthPolicy = 0x0000012C,
    
    PP_Commands = 0x0000012D,
    
    SetPrimaryPolicy = 0x0000012E,
    
    FieldUpgradeStart = 0x0000012F,
    
    ClockRateAdjust = 0x00000130,
    
    CreatePrimary = 0x00000131,
    
    NV_GlobalWriteLock = 0x00000132,
    
    GetCommandAuditDigest = 0x00000133,
    
    NV_Increment = 0x00000134,
    
    NV_SetBits = 0x00000135,
    
    NV_Extend = 0x00000136,
    
    NV_Write = 0x00000137,
    
    NV_WriteLock = 0x00000138,
    
    DictionaryAttackLockReset = 0x00000139,
    
    DictionaryAttackParameters = 0x0000013A,
    
    NV_ChangeAuth = 0x0000013B,
    
    /// <summary> PCR </summary>
    PCR_Event = 0x0000013C,
    
    /// <summary> PCR </summary>
    PCR_Reset = 0x0000013D,
    
    SequenceComplete = 0x0000013E,
    
    SetAlgorithmSet = 0x0000013F,
    
    SetCommandCodeAuditStatus = 0x00000140,
    
    FieldUpgradeData = 0x00000141,
    
    IncrementalSelfTest = 0x00000142,
    
    SelfTest = 0x00000143,
    
    Startup = 0x00000144,
    
    Shutdown = 0x00000145,
    
    StirRandom = 0x00000146,
    
    ActivateCredential = 0x00000147,
    
    Certify = 0x00000148,
    
    /// <summary> Policy </summary>
    PolicyNV = 0x00000149,
    
    CertifyCreation = 0x0000014A,
    
    Duplicate = 0x0000014B,
    
    GetTime = 0x0000014C,
    
    GetSessionAuditDigest = 0x0000014D,
    
    NV_Read = 0x0000014E,
    
    NV_ReadLock = 0x0000014F,
    
    ObjectChangeAuth = 0x00000150,
    
    /// <summary> Policy </summary>
    PolicySecret = 0x00000151,
    
    Rewrap = 0x00000152,
    
    Create = 0x00000153,
    
    ECDH_ZGen = 0x00000154,
    
    /// <summary> See NOTE 1 </summary>
    HMAC = 0x00000155,
    
    /// <summary> See NOTE 1 </summary>
    MAC = 0x00000155,
    
    Import = 0x00000156,
    
    Load = 0x00000157,
    
    Quote = 0x00000158,
    
    RSA_Decrypt = 0x00000159,
    
    /// <summary> See NOTE 1 </summary>
    HMAC_Start = 0x0000015B,
    
    /// <summary> See NOTE 1 </summary>
    MAC_Start = 0x0000015B,
    
    SequenceUpdate = 0x0000015C,
    
    Sign = 0x0000015D,
    
    Unseal = 0x0000015E,
    
    /// <summary> Policy </summary>
    PolicySigned = 0x00000160,
    
    /// <summary> Context </summary>
    ContextLoad = 0x00000161,
    
    /// <summary> Context </summary>
    ContextSave = 0x00000162,
    
    ECDH_KeyGen = 0x00000163,
    
    EncryptDecrypt = 0x00000164,
    
    /// <summary> Context </summary>
    FlushContext = 0x00000165,
    
    LoadExternal = 0x00000167,
    
    MakeCredential = 0x00000168,
    
    /// <summary> NV </summary>
    NV_ReadPublic = 0x00000169,
    
    /// <summary> Policy </summary>
    PolicyAuthorize = 0x0000016A,
    
    /// <summary> Policy </summary>
    PolicyAuthValue = 0x0000016B,
    
    /// <summary> Policy </summary>
    PolicyCommandCode = 0x0000016C,
    
    /// <summary> Policy </summary>
    PolicyCounterTimer = 0x0000016D,
    
    /// <summary> Policy </summary>
    PolicyCpHash = 0x0000016E,
    
    /// <summary> Policy </summary>
    PolicyLocality = 0x0000016F,
    
    /// <summary> Policy </summary>
    PolicyNameHash = 0x00000170,
    
    /// <summary> Policy </summary>
    PolicyOR = 0x00000171,
    
    /// <summary> Policy </summary>
    PolicyTicket = 0x00000172,
    
    ReadPublic = 0x00000173,
    
    RSA_Encrypt = 0x00000174,
    
    StartAuthSession = 0x00000176,
    
    VerifySignature = 0x00000177,
    
    ECC_Parameters = 0x00000178,
    
    FirmwareRead = 0x00000179,
    
    GetCapability = 0x0000017A,
    
    GetRandom = 0x0000017B,
    
    GetTestResult = 0x0000017C,
    
    Hash = 0x0000017D,
    
    /// <summary> PCR </summary>
    PCR_Read = 0x0000017E,
    
    /// <summary> Policy </summary>
    PolicyPCR = 0x0000017F,
    
    PolicyRestart = 0x00000180,
    
    ReadClock = 0x00000181,
    
    PCR_Extend = 0x00000182,
    
    PCR_SetAuthValue = 0x00000183,
    
    NV_Certify = 0x00000184,
    
    EventSequenceComplete = 0x00000185,
    
    HashSequenceStart = 0x00000186,
    
    /// <summary> Policy </summary>
    PolicyPhysicalPresence = 0x00000187,
    
    /// <summary> Policy </summary>
    PolicyDuplicationSelect = 0x00000188,
    
    /// <summary> Policy </summary>
    PolicyGetDigest = 0x00000189,
    
    TestParms = 0x0000018A,
    
    Commit = 0x0000018B,
    
    /// <summary> Policy </summary>
    PolicyPassword = 0x0000018C,
    
    ZGen_2Phase = 0x0000018D,
    
    EC_Ephemeral = 0x0000018E,
    
    /// <summary> Policy </summary>
    PolicyNvWritten = 0x0000018F,
    
    /// <summary> Policy </summary>
    PolicyTemplate = 0x00000190,
    
    CreateLoaded = 0x00000191,
    
    /// <summary> Policy </summary>
    PolicyAuthorizeNV = 0x00000192,
    
    EncryptDecrypt2 = 0x00000193,
    
    AC_GetCapability = 0x00000194,
    
    AC_Send = 0x00000195,
    
    /// <summary> Policy </summary>
    Policy_AC_SendSelect = 0x00000196,
    
    CertifyX509 = 0x00000197,
    
    ACT_SetTimeout = 0x00000198,
    
    ECC_Encrypt = 0x00000199,
    
    ECC_Decrypt = 0x0000019A,
    
    /// <summary> Compile variable. May increase based on implementation. </summary>
    LAST = 0x0000019A,
    
    CC_VEND = 0x20000000,
    
    /// <summary> Used for testing of command dispatch </summary>
    Vendor_TCG_Test = CC_VEND+0x0000
    TPM_ENUM_EPILOGUE(TPM_CC)
};

/// <summary> Architecturally defined constants </summary>
struct ImplementationConstants : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(ImplementationConstants)
    
    Ossl = 1,
    
    Ltc = 2,
    
    Msbn = 3,
    
    Symcrypt = 4,
    
    HASH_COUNT = 3,
    
    MAX_SYM_KEY_BITS = 256,
    
    MAX_SYM_KEY_BYTES = ((MAX_SYM_KEY_BITS + 7) / 8),
    
    MAX_SYM_BLOCK_SIZE = 16,
    
    MAX_CAP_CC = TPM_CC::LAST,
    
    MAX_RSA_KEY_BYTES = 256,
    
    MAX_AES_KEY_BYTES = 32,
    
    MAX_ECC_KEY_BYTES = 48,
    
    LABEL_MAX_BUFFER = 32,
    
    _TPM_CAP_SIZE = sizeof(UINT32),
    
    MAX_CAP_DATA = (1024/*MAX_CAP_BUFFER*/-_TPM_CAP_SIZE-sizeof(UINT32)),
    
    MAX_CAP_ALGS = (MAX_CAP_DATA / 0x6 /*sizeof(TPMS_ALG_PROPERTY)*/),
    
    MAX_CAP_HANDLES = (MAX_CAP_DATA / 0x4 /*sizeof(TPM_HANDLE)*/),
    
    MAX_TPM_PROPERTIES = (MAX_CAP_DATA / 0x8 /*sizeof(TPMS_TAGGED_PROPERTY)*/),
    
    MAX_PCR_PROPERTIES = (MAX_CAP_DATA / 0x5 /*sizeof(TPMS_TAGGED_PCR_SELECT)*/),
    
    MAX_ECC_CURVES = (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE)),
    
    MAX_TAGGED_POLICIES = (MAX_CAP_DATA / 0x46 /*sizeof(TPMS_TAGGED_POLICY)*/),
    
    MAX_AC_CAPABILITIES = (MAX_CAP_DATA / 0x8 /*sizeof(TPMS_AC_OUTPUT)*/),
    
    MAX_ACT_DATA = MAX_CAP_DATA / 0xC /*sizeof(TPMS_ACT_DATA)*/
    TPM_ENUM_EPILOGUE(ImplementationConstants)
};

/// <summary>
/// In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and will
/// have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have the F bit
/// CLEAR but the V (version) attribute will be SET to indicate that it is a TPM 2.0 response
/// code. See Response Code Details in TPM 2.0 Part 1.
/// </summary>
struct TPM_RC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_RC)
    
    SUCCESS = 0x000,
    
    /// <summary> defined for compatibility with TPM 1.2 </summary>
    BAD_TAG = 0x01E,
    
    /// <summary> set for all format 0 response codes </summary>
    RC_VER1 = 0x100,
    
    /// <summary> TPM not initialized by TPM2_Startup or already initialized </summary>
    INITIALIZE = RC_VER1 + 0x000,
    
    /// <summary>
    /// commands not being accepted because of a TPM failure
    /// NOTE This may be returned by TPM2_GetTestResult() as the testResult parameter.
    /// </summary>
    FAILURE = RC_VER1 + 0x001,
    
    /// <summary> improper use of a sequence handle </summary>
    SEQUENCE = RC_VER1 + 0x003,
    
    /// <summary> not currently used </summary>
    PRIVATE = RC_VER1 + 0x00B,
    
    /// <summary> not currently used </summary>
    HMAC = RC_VER1 + 0x019,
    
    /// <summary> the command is disabled </summary>
    DISABLED = RC_VER1 + 0x020,
    
    /// <summary> command failed because audit sequence required exclusivity </summary>
    EXCLUSIVE = RC_VER1 + 0x021,
    
    /// <summary> authorization handle is not correct for command </summary>
    AUTH_TYPE = RC_VER1 + 0x024,
    
    /// <summary> command requires an authorization session for handle and it is not present. </summary>
    AUTH_MISSING = RC_VER1 + 0x025,
    
    /// <summary> policy failure in math operation or an invalid authPolicy value </summary>
    POLICY = RC_VER1 + 0x026,
    
    /// <summary> PCR check fail </summary>
    PCR = RC_VER1 + 0x027,
    
    /// <summary> PCR have changed since checked. </summary>
    PCR_CHANGED = RC_VER1 + 0x028,
    
    /// <summary>
    /// for all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM is
    /// in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the TPM
    /// is not in field upgrade mode
    /// </summary>
    UPGRADE = RC_VER1 + 0x02D,
    
    /// <summary> context ID counter is at maximum. </summary>
    TOO_MANY_CONTEXTS = RC_VER1 + 0x02E,
    
    /// <summary> authValue or authPolicy is not available for selected entity. </summary>
    AUTH_UNAVAILABLE = RC_VER1 + 0x02F,
    
    /// <summary> a _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation. </summary>
    REBOOT = RC_VER1 + 0x030,
    
    /// <summary>
    /// the protection algorithms (hash and symmetric) are not reasonably balanced. The digest
    /// size of the hash must be larger than the key size of the symmetric algorithm.
    /// </summary>
    UNBALANCED = RC_VER1 + 0x031,
    
    /// <summary>
    /// command commandSize value is inconsistent with contents of the command buffer; either the
    /// size is not the same as the octets loaded by the hardware interface layer or the value is not
    /// large enough to hold a command header
    /// </summary>
    COMMAND_SIZE = RC_VER1 + 0x042,
    
    /// <summary> command code not supported </summary>
    COMMAND_CODE = RC_VER1 + 0x043,
    
    /// <summary>
    /// the value of authorizationSize is out of range or the number of octets in the
    /// Authorization Area is greater than required
    /// </summary>
    AUTHSIZE = RC_VER1 + 0x044,
    
    /// <summary>
    /// use of an authorization session with a context command or another command that cannot
    /// have an authorization session.
    /// </summary>
    AUTH_CONTEXT = RC_VER1 + 0x045,
    
    /// <summary> NV offset+size is out of range. </summary>
    NV_RANGE = RC_VER1 + 0x046,
    
    /// <summary> Requested allocation size is larger than allowed. </summary>
    NV_SIZE = RC_VER1 + 0x047,
    
    /// <summary> NV access locked. </summary>
    NV_LOCKED = RC_VER1 + 0x048,
    
    /// <summary>
    /// NV access authorization fails in command actions (this failure does
    /// not affect lockout.action)
    /// </summary>
    NV_AUTHORIZATION = RC_VER1 + 0x049,
    
    /// <summary>
    /// an NV Index is used before being initialized or the state saved by
    /// TPM2_Shutdown(STATE) could not be restored
    /// </summary>
    NV_UNINITIALIZED = RC_VER1 + 0x04A,
    
    /// <summary> insufficient space for NV allocation </summary>
    NV_SPACE = RC_VER1 + 0x04B,
    
    /// <summary> NV Index or persistent object already defined </summary>
    NV_DEFINED = RC_VER1 + 0x04C,
    
    /// <summary> context in TPM2_ContextLoad() is not valid </summary>
    BAD_CONTEXT = RC_VER1 + 0x050,
    
    /// <summary> cpHash value already set or not correct for use </summary>
    CPHASH = RC_VER1 + 0x051,
    
    /// <summary> handle for parent is not a valid parent </summary>
    PARENT = RC_VER1 + 0x052,
    
    /// <summary> some function needs testing. </summary>
    NEEDS_TEST = RC_VER1 + 0x053,
    
    /// <summary>
    /// returned when an internal function cannot process a request due to an unspecified problem.
    /// This code is usually related to invalid parameters that are not properly filtered by
    /// the input unmarshaling code.
    /// </summary>
    NO_RESULT = RC_VER1 + 0x054,
    
    /// <summary>
    /// the sensitive area did not unmarshal correctly after decryption this code is used in lieu
    /// of the other unmarshaling errors so that an attacker cannot determine where the
    /// unmarshaling error occurred
    /// </summary>
    SENSITIVE = RC_VER1 + 0x055,
    
    /// <summary> largest version 1 code that is not a warning </summary>
    RC_MAX_FM0 = RC_VER1 + 0x07F,
    
    /// <summary>
    /// This bit is SET in all format 1 response codes
    /// The codes in this group may have a value added to them to indicate the handle, session, or
    /// parameter to which they apply.
    /// </summary>
    RC_FMT1 = 0x080,
    
    /// <summary> asymmetric algorithm not supported or not correct </summary>
    ASYMMETRIC = RC_FMT1 + 0x001,
    
    /// <summary> inconsistent attributes </summary>
    ATTRIBUTES = RC_FMT1 + 0x002,
    
    /// <summary> hash algorithm not supported or not appropriate </summary>
    HASH = RC_FMT1 + 0x003,
    
    /// <summary> value is out of range or is not correct for the context </summary>
    VALUE = RC_FMT1 + 0x004,
    
    /// <summary> hierarchy is not enabled or is not correct for the use </summary>
    HIERARCHY = RC_FMT1 + 0x005,
    
    /// <summary> key size is not supported </summary>
    KEY_SIZE = RC_FMT1 + 0x007,
    
    /// <summary> mask generation function not supported </summary>
    MGF = RC_FMT1 + 0x008,
    
    /// <summary> mode of operation not supported </summary>
    MODE = RC_FMT1 + 0x009,
    
    /// <summary> the type of the value is not appropriate for the use </summary>
    TYPE = RC_FMT1 + 0x00A,
    
    /// <summary> the handle is not correct for the use </summary>
    HANDLE = RC_FMT1 + 0x00B,
    
    /// <summary> unsupported key derivation function or function not appropriate for use </summary>
    KDF = RC_FMT1 + 0x00C,
    
    /// <summary> value was out of allowed range. </summary>
    RANGE = RC_FMT1 + 0x00D,
    
    /// <summary> the authorization HMAC check failed and DA counter incremented </summary>
    AUTH_FAIL = RC_FMT1 + 0x00E,
    
    /// <summary> invalid nonce size or nonce value mismatch </summary>
    NONCE = RC_FMT1 + 0x00F,
    
    /// <summary> authorization requires assertion of PP </summary>
    PP = RC_FMT1 + 0x010,
    
    /// <summary> unsupported or incompatible scheme </summary>
    SCHEME = RC_FMT1 + 0x012,
    
    /// <summary> structure is the wrong size </summary>
    SIZE = RC_FMT1 + 0x015,
    
    /// <summary> unsupported symmetric algorithm or key size, or not appropriate for instance </summary>
    SYMMETRIC = RC_FMT1 + 0x016,
    
    /// <summary> incorrect structure tag </summary>
    TAG = RC_FMT1 + 0x017,
    
    /// <summary> union selector is incorrect </summary>
    SELECTOR = RC_FMT1 + 0x018,
    
    /// <summary>
    /// the TPM was unable to unmarshal a value because there were not enough
    /// octets in the input buffer
    /// </summary>
    INSUFFICIENT = RC_FMT1 + 0x01A,
    
    /// <summary> the signature is not valid </summary>
    SIGNATURE = RC_FMT1 + 0x01B,
    
    /// <summary> key fields are not compatible with the selected use </summary>
    KEY = RC_FMT1 + 0x01C,
    
    /// <summary> a policy check failed </summary>
    POLICY_FAIL = RC_FMT1 + 0x01D,
    
    /// <summary> integrity check failed </summary>
    INTEGRITY = RC_FMT1 + 0x01F,
    
    /// <summary> invalid ticket </summary>
    TICKET = RC_FMT1 + 0x020,
    
    /// <summary> reserved bits not set to zero as required </summary>
    RESERVED_BITS = RC_FMT1 + 0x021,
    
    /// <summary> authorization failure without DA implications </summary>
    BAD_AUTH = RC_FMT1 + 0x022,
    
    /// <summary> the policy has expired </summary>
    EXPIRED = RC_FMT1 + 0x023,
    
    /// <summary>
    /// the commandCode in the policy is not the commandCode of the command or the command code in
    /// a policy command references a command that is not implemented
    /// </summary>
    POLICY_CC = RC_FMT1 + 0x024,
    
    /// <summary> public and sensitive portions of an object are not cryptographically bound </summary>
    BINDING = RC_FMT1 + 0x025,
    
    /// <summary> curve not supported </summary>
    CURVE = RC_FMT1 + 0x026,
    
    /// <summary> point is not on the required curve. </summary>
    ECC_POINT = RC_FMT1 + 0x027,
    
    /// <summary> set for warning response codes </summary>
    RC_WARN = 0x900,
    
    /// <summary> gap for context ID is too large </summary>
    CONTEXT_GAP = RC_WARN + 0x001,
    
    /// <summary> out of memory for object contexts </summary>
    OBJECT_MEMORY = RC_WARN + 0x002,
    
    /// <summary> out of memory for session contexts </summary>
    SESSION_MEMORY = RC_WARN + 0x003,
    
    /// <summary> out of shared object/session memory or need space for internal operations </summary>
    MEMORY = RC_WARN + 0x004,
    
    /// <summary> out of session handles a session must be flushed before a new session may be created </summary>
    SESSION_HANDLES = RC_WARN + 0x005,
    
    /// <summary>
    /// out of object handles the handle space for objects is depleted and a reboot is required
    /// NOTE 1 This cannot occur on the reference implementation.
    /// NOTE 2 There is no reason why an implementation would implement a design that would
    /// deplete handle space. Platform specifications are encouraged to forbid it.
    /// </summary>
    OBJECT_HANDLES = RC_WARN + 0x006,
    
    /// <summary> bad locality </summary>
    LOCALITY = RC_WARN + 0x007,
    
    /// <summary>
    /// the TPM has suspended operation on the command; forward progress was made and the command
    /// may be retried
    /// See TPM 2.0 Part 1, Multi-tasking.
    /// NOTE This cannot occur on the reference implementation.
    /// </summary>
    YIELDED = RC_WARN + 0x008,
    
    /// <summary> the command was canceled </summary>
    CANCELED = RC_WARN + 0x009,
    
    /// <summary> TPM is performing self-tests </summary>
    TESTING = RC_WARN + 0x00A,
    
    /// <summary>
    /// the 1st handle in the handle area references a transient object or
    /// session that is not loaded
    /// </summary>
    REFERENCE_H0 = RC_WARN + 0x010,
    
    /// <summary>
    /// the 2nd handle in the handle area references a transient object or
    /// session that is not loaded
    /// </summary>
    REFERENCE_H1 = RC_WARN + 0x011,
    
    /// <summary>
    /// the 3rd handle in the handle area references a transient object or
    /// session that is not loaded
    /// </summary>
    REFERENCE_H2 = RC_WARN + 0x012,
    
    /// <summary>
    /// the 4th handle in the handle area references a transient object or
    /// session that is not loaded
    /// </summary>
    REFERENCE_H3 = RC_WARN + 0x013,
    
    /// <summary>
    /// the 5th handle in the handle area references a transient object or
    /// session that is not loaded
    /// </summary>
    REFERENCE_H4 = RC_WARN + 0x014,
    
    /// <summary>
    /// the 6th handle in the handle area references a transient object or
    /// session that is not loaded
    /// </summary>
    REFERENCE_H5 = RC_WARN + 0x015,
    
    /// <summary>
    /// the 7th handle in the handle area references a transient object or
    /// session that is not loaded
    /// </summary>
    REFERENCE_H6 = RC_WARN + 0x016,
    
    /// <summary> the 1st authorization session handle references a session that is not loaded </summary>
    REFERENCE_S0 = RC_WARN + 0x018,
    
    /// <summary> the 2nd authorization session handle references a session that is not loaded </summary>
    REFERENCE_S1 = RC_WARN + 0x019,
    
    /// <summary> the 3rd authorization session handle references a session that is not loaded </summary>
    REFERENCE_S2 = RC_WARN + 0x01A,
    
    /// <summary> the 4th authorization session handle references a session that is not loaded </summary>
    REFERENCE_S3 = RC_WARN + 0x01B,
    
    /// <summary> the 5th session handle references a session that is not loaded </summary>
    REFERENCE_S4 = RC_WARN + 0x01C,
    
    /// <summary> the 6th session handle references a session that is not loaded </summary>
    REFERENCE_S5 = RC_WARN + 0x01D,
    
    /// <summary> the 7th authorization session handle references a session that is not loaded </summary>
    REFERENCE_S6 = RC_WARN + 0x01E,
    
    /// <summary> the TPM is rate-limiting accesses to prevent wearout of NV </summary>
    NV_RATE = RC_WARN + 0x020,
    
    /// <summary>
    /// authorizations for objects subject to DA protection are not allowed at this time because
    /// the TPM is in DA lockout mode
    /// </summary>
    LOCKOUT = RC_WARN + 0x021,
    
    /// <summary> the TPM was not able to start the command </summary>
    RETRY = RC_WARN + 0x022,
    
    /// <summary> the command may require writing of NV and NV is not current accessible </summary>
    NV_UNAVAILABLE = RC_WARN + 0x023,
    
    /// <summary> this value is reserved and shall not be returned by the TPM </summary>
    NOT_USED = RC_WARN + 0x7F,
    
    /// <summary> add to a handle-related error </summary>
    H = 0x000,
    
    /// <summary> add to a parameter-related error </summary>
    P = 0x040,
    
    /// <summary> add to a session-related error </summary>
    S = 0x800,
    
    /// <summary> add to a parameter-, handle-, or session-related error </summary>
    _1 = 0x100,
    
    /// <summary> add to a parameter-, handle-, or session-related error </summary>
    _2 = 0x200,
    
    /// <summary> add to a parameter-, handle-, or session-related error </summary>
    _3 = 0x300,
    
    /// <summary> add to a parameter-, handle-, or session-related error </summary>
    _4 = 0x400,
    
    /// <summary> add to a parameter-, handle-, or session-related error </summary>
    _5 = 0x500,
    
    /// <summary> add to a parameter-, handle-, or session-related error </summary>
    _6 = 0x600,
    
    /// <summary> add to a parameter-, handle-, or session-related error </summary>
    _7 = 0x700,
    
    /// <summary> add to a parameter-related error </summary>
    _8 = 0x800,
    
    /// <summary> add to a parameter-related error </summary>
    _9 = 0x900,
    
    /// <summary> add to a parameter-related error </summary>
    A = 0xA00,
    
    /// <summary> add to a parameter-related error </summary>
    B = 0xB00,
    
    /// <summary> add to a parameter-related error </summary>
    C = 0xC00,
    
    /// <summary> add to a parameter-related error </summary>
    D = 0xD00,
    
    /// <summary> add to a parameter-related error </summary>
    E = 0xE00,
    
    /// <summary> add to a parameter-related error </summary>
    F = 0xF00,
    
    /// <summary> number mask </summary>
    N_MASK = 0xF00,
    
    /// <summary> Response buffer returned by the TPM is too short </summary>
    TSS_TCP_BAD_HANDSHAKE_RESP = 0x40280001,
    
    /// <summary> Too old TCP server version </summary>
    TSS_TCP_SERVER_TOO_OLD = 0x40280002,
    
    /// <summary> Bad ack from the TCP end point </summary>
    TSS_TCP_BAD_ACK = 0x40280003,
    
    /// <summary> Wrong length of the response buffer returned by the TPM </summary>
    TSS_TCP_BAD_RESP_LEN = 0x40280004,
    
    /// <summary> TPM2_Startup returned unexpected response code </summary>
    TSS_TCP_UNEXPECTED_STARTUP_RESP = 0x40280005,
    
    /// <summary> Invalid size tag in the TPM response TCP packet </summary>
    TSS_TCP_INVALID_SIZE_TAG = 0x40280006,
    
    /// <summary> TPM over TCP device is not connected </summary>
    TSS_TCP_DISCONNECTED = 0x40280007,
    
    /// <summary> General TPM command dispatch failure </summary>
    TSS_DISPATCH_FAILED = 0x40280010,
    
    /// <summary> Sending data to TPM failed </summary>
    TSS_SEND_OP_FAILED = 0x40280011,
    
    /// <summary> Response buffer returned by the TPM is too short </summary>
    TSS_RESP_BUF_TOO_SHORT = 0x40280021,
    
    /// <summary> Invalid tag in the response buffer returned by the TPM </summary>
    TSS_RESP_BUF_INVALID_SESSION_TAG = 0x40280022,
    
    /// <summary> Windows TBS error TPM_E_COMMAND_BLOCKED </summary>
    TBS_COMMAND_BLOCKED = 0x80280400,
    
    /// <summary> Windows TBS error TPM_E_INVALID_HANDLE </summary>
    TBS_INVALID_HANDLE = 0x80280401,
    
    /// <summary> Windows TBS error TPM_E_DUPLICATE_VHANDLE </summary>
    TBS_DUPLICATE_V_HANDLE = 0x80280402,
    
    /// <summary> Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED </summary>
    TBS_EMBEDDED_COMMAND_BLOCKED = 0x80280403,
    
    /// <summary> Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED </summary>
    TBS_EMBEDDED_COMMAND_UNSUPPORTED = 0x80280404,
    
    /// <summary> Windows TBS returned success but empty response buffer </summary>
    TBS_UNKNOWN_ERROR = 0x80284000,
    
    /// <summary> Windows TBS error TBS_E_INTERNAL_ERROR </summary>
    TBS_INTERNAL_ERROR = 0x80284001,
    
    /// <summary> Windows TBS error TBS_E_BAD_PARAMETER </summary>
    TBS_BAD_PARAMETER = 0x80284002,
    
    /// <summary> Windows TBS error TBS_E_INVALID_OUTPUT_POINTER </summary>
    TBS_INVALID_OUTPUT_POINTER = 0x80284003,
    
    /// <summary> Windows TBS error TBS_E_INVALID_CONTEXT </summary>
    TBS_INVALID_CONTEXT = 0x80284004,
    
    /// <summary> Windows TBS error TBS_E_INSUFFICIENT_BUFFER </summary>
    TBS_INSUFFICIENT_BUFFER = 0x80284005,
    
    /// <summary> Windows TBS error TBS_E_IOERROR </summary>
    TBS_IO_ERROR = 0x80284006,
    
    /// <summary> Windows TBS error TBS_E_INVALID_CONTEXT_PARAM </summary>
    TBS_INVALID_CONTEXT_PARAM = 0x80284007,
    
    /// <summary> Windows TBS error TBS_E_SERVICE_NOT_RUNNING </summary>
    TBS_SERVICE_NOT_RUNNING = 0x80284008,
    
    /// <summary> Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS </summary>
    TBS_TOO_MANY_CONTEXTS = 0x80284009,
    
    /// <summary> Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES </summary>
    TBS_TOO_MANY_RESOURCES = 0x8028400A,
    
    /// <summary> Windows TBS error TBS_E_SERVICE_START_PENDING </summary>
    TBS_SERVICE_START_PENDING = 0x8028400B,
    
    /// <summary> Windows TBS error TBS_E_PPI_NOT_SUPPORTED </summary>
    TBS_PPI_NOT_SUPPORTED = 0x8028400C,
    
    /// <summary> Windows TBS error TBS_E_COMMAND_CANCELED </summary>
    TBS_COMMAND_CANCELED = 0x8028400D,
    
    /// <summary> Windows TBS error TBS_E_BUFFER_TOO_LARGE </summary>
    TBS_BUFFER_TOO_LARGE = 0x8028400E,
    
    /// <summary> Windows TBS error TBS_E_TPM_NOT_FOUND </summary>
    TBS_TPM_NOT_FOUND = 0x8028400F,
    
    /// <summary> Windows TBS error TBS_E_SERVICE_DISABLED </summary>
    TBS_SERVICE_DISABLED = 0x80284010,
    
    /// <summary> Windows TBS error TBS_E_ACCESS_DENIED </summary>
    TBS_ACCESS_DENIED = 0x80284012,
    
    /// <summary> Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED </summary>
    TBS_PPI_FUNCTION_NOT_SUPPORTED = 0x80284014,
    
    /// <summary> Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND </summary>
    TBS_OWNER_AUTH_NOT_FOUND = 0x80284015
    TPM_ENUM_EPILOGUE(TPM_RC)
};

/// <summary>
/// A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal oscillator
/// is divided. A change to the divider will change the rate at which Clock and Time change.
/// </summary>
struct TPM_CLOCK_ADJUST : public TpmEnum<INT8>
{
    TPM_ENUM_PROLOGUE(TPM_CLOCK_ADJUST)
    
    /// <summary> Slow the Clock update rate by one coarse adjustment step. </summary>
    COARSE_SLOWER = -3,
    
    /// <summary> Slow the Clock update rate by one medium adjustment step. </summary>
    MEDIUM_SLOWER = -2,
    
    /// <summary> Slow the Clock update rate by one fine adjustment step. </summary>
    FINE_SLOWER = -1,
    
    /// <summary> No change to the Clock update rate. </summary>
    NO_CHANGE = 0,
    
    /// <summary> Speed the Clock update rate by one fine adjustment step. </summary>
    FINE_FASTER = 1,
    
    /// <summary> Speed the Clock update rate by one medium adjustment step. </summary>
    MEDIUM_FASTER = 2,
    
    /// <summary> Speed the Clock update rate by one coarse adjustment step. </summary>
    COARSE_FASTER = 3
    TPM_ENUM_EPILOGUE(TPM_CLOCK_ADJUST)
};

/// <summary> Table 18 Definition of (UINT16) TPM_EO Constants [IN/OUT] </summary>
struct TPM_EO : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_EO)
    
    /// <summary> A = B </summary>
    EQ = 0x0000,
    
    /// <summary> A B </summary>
    NEQ = 0x0001,
    
    /// <summary> A  B signed </summary>
    SIGNED_GT = 0x0002,
    
    /// <summary> A  B unsigned </summary>
    UNSIGNED_GT = 0x0003,
    
    /// <summary> A  B signed </summary>
    SIGNED_LT = 0x0004,
    
    /// <summary> A  B unsigned </summary>
    UNSIGNED_LT = 0x0005,
    
    /// <summary> A B signed </summary>
    SIGNED_GE = 0x0006,
    
    /// <summary> A B unsigned </summary>
    UNSIGNED_GE = 0x0007,
    
    /// <summary> A B signed </summary>
    SIGNED_LE = 0x0008,
    
    /// <summary> A B unsigned </summary>
    UNSIGNED_LE = 0x0009,
    
    /// <summary> All bits SET in B are SET in A. ((AB)=B) </summary>
    BITSET = 0x000A,
    
    /// <summary> All bits SET in B are CLEAR in A. ((AB)=0) </summary>
    BITCLEAR = 0x000B
    TPM_ENUM_EPILOGUE(TPM_EO)
};

/// <summary>
/// Structure tags are used to disambiguate structures. They are 16-bit values with the most
/// significant bit SET so that they do not overlap TPM_ALG_ID values. A single exception is
/// made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has the same value
/// as the TPM_TAG_RSP_COMMAND tag from earlier versions of this specification. This value is
/// used when the TPM is compatible with a previous TPM specification and the TPM cannot
/// determine which family of response code to return because the command tag is not valid.
/// </summary>
struct TPM_ST : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_ST)
    
    /// <summary>
    /// tag value for a response; used when there is an error in the tag. This is also the value
    /// returned from a TPM 1.2 when an error occurs. This value is used in this specification
    /// because an error in the command tag may prevent determination of the family. When this tag
    /// is used in the response, the response code will be TPM_RC_BAD_TAG (0 1E16), which has the
    /// same numeric value as the TPM 1.2 response code for TPM_BADTAG.
    /// NOTE In a previously published version of this specification, TPM_RC_BAD_TAG was
    /// incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my return the
    /// old value instead of the new value.
    /// </summary>
    RSP_COMMAND = 0x00C4,
    
    /// <summary> no structure type specified </summary>
    _NULL = 0X8000,
    
    /// <summary>
    /// tag value for a command/response for a command defined in this specification; indicating
    /// that the command/response has no attached sessions and no authorizationSize/parameterSize
    /// value is present
    /// If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall
    /// have this value.
    /// </summary>
    NO_SESSIONS = 0x8001,
    
    /// <summary>
    /// tag value for a command/response for a command defined in this specification; indicating
    /// that the command/response has one or more attached sessions and the
    /// authorizationSize/parameterSize field is present
    /// </summary>
    SESSIONS = 0x8002,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_NV = 0x8014,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_COMMAND_AUDIT = 0x8015,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_SESSION_AUDIT = 0x8016,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_CERTIFY = 0x8017,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_QUOTE = 0x8018,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_TIME = 0x8019,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_CREATION = 0x801A,
    
    /// <summary> tag for an attestation structure </summary>
    ATTEST_NV_DIGEST = 0x801C,
    
    /// <summary> tag for a ticket type </summary>
    CREATION = 0x8021,
    
    /// <summary> tag for a ticket type </summary>
    VERIFIED = 0x8022,
    
    /// <summary> tag for a ticket type </summary>
    AUTH_SECRET = 0x8023,
    
    /// <summary> tag for a ticket type </summary>
    HASHCHECK = 0x8024,
    
    /// <summary> tag for a ticket type </summary>
    AUTH_SIGNED = 0x8025,
    
    /// <summary> tag for a structure describing a Field Upgrade Policy </summary>
    FU_MANIFEST = 0x8029
    TPM_ENUM_EPILOGUE(TPM_ST)
};

/// <summary>
/// These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The
/// defined startup sequences are:
/// </summary>
struct TPM_SU : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_SU)
    
    /// <summary>
    /// on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state
    /// required for an orderly startup (TPM Reset).
    /// on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
    /// </summary>
    CLEAR = 0x0000,
    
    /// <summary>
    /// on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state
    /// required for an orderly startup (TPM Restart or TPM Resume)
    /// on TPM2_Startup(), indicates that the TPM should restore the state saved by
    /// TPM2_Shutdown(TPM_SU_STATE)
    /// </summary>
    STATE = 0x0001
    TPM_ENUM_EPILOGUE(TPM_SU)
};

/// <summary>
/// This type is used in TPM2_StartAuthSession() to indicate the type of
/// the session to be created.
/// </summary>
struct TPM_SE : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPM_SE)
    
    HMAC = 0x00,
    
    POLICY = 0x01,
    
    /// <summary>
    /// The policy session is being used to compute the policyHash and not for command
    /// authorization.
    /// This setting modifies some policy commands and prevents session from being used to
    /// authorize a command.
    /// </summary>
    TRIAL = 0x03
    TPM_ENUM_EPILOGUE(TPM_SE)
};

/// <summary>
/// The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to be
/// returned. The format of the response varies according to the type of the value.
/// </summary>
struct TPM_CAP : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_CAP)
    
    FIRST = 0x00000000,
    
    /// <summary> TPML_ALG_PROPERTY </summary>
    ALGS = 0x00000000,
    
    /// <summary> TPML_HANDLE </summary>
    HANDLES = 0x00000001,
    
    /// <summary> TPML_CCA </summary>
    COMMANDS = 0x00000002,
    
    /// <summary> TPML_CC </summary>
    PP_COMMANDS = 0x00000003,
    
    /// <summary> TPML_CC </summary>
    AUDIT_COMMANDS = 0x00000004,
    
    /// <summary> TPML_PCR_SELECTION </summary>
    PCRS = 0x00000005,
    
    /// <summary> TPML_TAGGED_TPM_PROPERTY </summary>
    TPM_PROPERTIES = 0x00000006,
    
    /// <summary> TPML_TAGGED_PCR_PROPERTY </summary>
    PCR_PROPERTIES = 0x00000007,
    
    /// <summary> TPML_ECC_CURVE </summary>
    ECC_CURVES = 0x00000008,
    
    /// <summary> TPML_TAGGED_POLICY </summary>
    AUTH_POLICIES = 0x00000009,
    
    /// <summary> TPML_ACT_DATA </summary>
    ACT = 0x0000000A,
    
    LAST = 0x0000000A,
    
    /// <summary> manufacturer-specific values </summary>
    VENDOR_PROPERTY = 0x00000100
    TPM_ENUM_EPILOGUE(TPM_CAP)
};

/// <summary>
/// The TPM_PT constants are used in TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES)
/// to indicate the property being selected or returned.
/// </summary>
struct TPM_PT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_PT)
    
    /// <summary> indicates no property type </summary>
    NONE = 0x00000000,
    
    /// <summary>
    /// The number of properties in each group.
    /// NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
    /// </summary>
    PT_GROUP = 0x00000100,
    
    /// <summary>
    /// the group of fixed properties returned as TPMS_TAGGED_PROPERTY
    /// The values in this group are only changed due to a firmware change in the TPM.
    /// </summary>
    PT_FIXED = PT_GROUP * 1,
    
    /// <summary> a 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY) </summary>
    FAMILY_INDICATOR = PT_FIXED + 0,
    
    /// <summary>
    /// the level of the specification
    /// NOTE 1 For this specification, the level is zero.
    /// NOTE 2 The level is on the title page of the specification.
    /// </summary>
    LEVEL = PT_FIXED + 1,
    
    /// <summary>
    /// the specification Revision times 100
    /// EXAMPLE Revision 01.01 would have a value of 101.
    /// NOTE The Revision value is on the title page of the specification.
    /// </summary>
    REVISION = PT_FIXED + 2,
    
    /// <summary>
    /// the specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    /// </summary>
    DAY_OF_YEAR = PT_FIXED + 3,
    
    /// <summary>
    /// the specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    /// NOTE The specification date is on the title page of the specification or errata (see 6.1).
    /// </summary>
    YEAR = PT_FIXED + 4,
    
    /// <summary> the vendor ID unique to each TPM manufacturer </summary>
    MANUFACTURER = PT_FIXED + 5,
    
    /// <summary>
    /// the first four characters of the vendor ID string
    /// NOTE When the vendor string is fewer than 16 octets, the additional property values do not
    /// have to be present. A vendor string of 4 octets can be represented in one 32-bit value and no null
    /// terminating character is required.
    /// </summary>
    VENDOR_STRING_1 = PT_FIXED + 6,
    
    /// <summary> the second four characters of the vendor ID string </summary>
    VENDOR_STRING_2 = PT_FIXED + 7,
    
    /// <summary> the third four characters of the vendor ID string </summary>
    VENDOR_STRING_3 = PT_FIXED + 8,
    
    /// <summary> the fourth four characters of the vendor ID sting </summary>
    VENDOR_STRING_4 = PT_FIXED + 9,
    
    /// <summary> vendor-defined value indicating the TPM model </summary>
    VENDOR_TPM_TYPE = PT_FIXED + 10,
    
    /// <summary>
    /// the most-significant 32 bits of a TPM vendor-specific value indicating the version number of the
    /// firmware. See 10.12.2 and 10.12.12.
    /// </summary>
    FIRMWARE_VERSION_1 = PT_FIXED + 11,
    
    /// <summary>
    /// the least-significant 32 bits of a TPM vendor-specific value indicating the version number of the
    /// firmware. See 10.12.2 and 10.12.12.
    /// </summary>
    FIRMWARE_VERSION_2 = PT_FIXED + 12,
    
    /// <summary> the maximum size of a parameter (typically, a TPM2B_MAX_BUFFER) </summary>
    INPUT_BUFFER = PT_FIXED + 13,
    
    /// <summary>
    /// the minimum number of transient objects that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the platform-specific
    /// specification to which the TPM is built.
    /// </summary>
    HR_TRANSIENT_MIN = PT_FIXED + 14,
    
    /// <summary>
    /// the minimum number of persistent objects that can be held in TPM NV memory
    /// NOTE This minimum shall be no less than the minimum value required by the platform-specific
    /// specification to which the TPM is built.
    /// </summary>
    HR_PERSISTENT_MIN = PT_FIXED + 15,
    
    /// <summary>
    /// the minimum number of authorization sessions that can be held in TPM RAM
    /// NOTE This minimum shall be no less than the minimum value required by the platform-specific
    /// specification to which the TPM is built.
    /// </summary>
    HR_LOADED_MIN = PT_FIXED + 16,
    
    /// <summary>
    /// the number of authorization sessions that may be active at a time
    /// A session is active when it has a context associated with its handle. The context may
    /// either be in TPM RAM or be context saved.
    /// NOTE This value shall be no less than the minimum value required by the platform-specific
    /// specification to which the TPM is built.
    /// </summary>
    ACTIVE_SESSIONS_MAX = PT_FIXED + 17,
    
    /// <summary>
    /// the number of PCR implemented
    /// NOTE This number is determined by the defined attributes, not the number of PCR that are
    /// populated.
    /// </summary>
    PCR_COUNT = PT_FIXED + 18,
    
    /// <summary>
    /// the minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect
    /// NOTE This value is not determined by the number of PCR implemented but by the number of
    /// PCR required by the platform-specific specification with which the TPM is compliant or by
    /// the implementer if not adhering to a platform-specific specification.
    /// </summary>
    PCR_SELECT_MIN = PT_FIXED + 19,
    
    /// <summary>
    /// the maximum allowed difference (unsigned) between the contextID values of two saved
    /// session contexts
    /// This value shall be 2n-1, where n is at least 16.
    /// </summary>
    CONTEXT_GAP_MAX = PT_FIXED + 20,
    
    /// <summary>
    /// the maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute
    /// NOTE 1 It is allowed for this value to be larger than the number of NV Indexes that can be
    /// defined. This would be indicative of a TPM implementation that did not use different
    /// implementation technology for different NV Index types.
    /// NOTE 2 The value zero indicates that there is no fixed maximum. The number of counter
    /// indexes is determined by the available NV memory pool.
    /// </summary>
    NV_COUNTERS_MAX = PT_FIXED + 22,
    
    /// <summary> the maximum size of an NV Index data area </summary>
    NV_INDEX_MAX = PT_FIXED + 23,
    
    /// <summary> a TPMA_MEMORY indicating the memory management method for the TPM </summary>
    MEMORY = PT_FIXED + 24,
    
    /// <summary> interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV </summary>
    CLOCK_UPDATE = PT_FIXED + 25,
    
    /// <summary>
    /// the algorithm used for the integrity HMAC on saved contexts and for hashing the
    /// fuData of TPM2_FirmwareRead()
    /// </summary>
    CONTEXT_HASH = PT_FIXED + 26,
    
    /// <summary> TPM_ALG_ID, the algorithm used for encryption of saved contexts </summary>
    CONTEXT_SYM = PT_FIXED + 27,
    
    /// <summary> TPM_KEY_BITS, the size of the key used for encryption of saved contexts </summary>
    CONTEXT_SYM_SIZE = PT_FIXED + 28,
    
    /// <summary>
    /// the modulus - 1 of the count for NV update of an orderly counter
    /// The returned value is MAX_ORDERLY_COUNT.
    /// This will have a value of 2N 1 where 1 N 32
    /// NOTE 1 An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and
    /// TPMA_NV_ORDERLY SET.
    /// NOTE 2 When the low-order bits of a counter equal this value, an NV write occurs on the next
    /// increment.
    /// </summary>
    ORDERLY_COUNT = PT_FIXED + 29,
    
    /// <summary> the maximum value for commandSize in a command </summary>
    MAX_COMMAND_SIZE = PT_FIXED + 30,
    
    /// <summary> the maximum value for responseSize in a response </summary>
    MAX_RESPONSE_SIZE = PT_FIXED + 31,
    
    /// <summary> the maximum size of a digest that can be produced by the TPM </summary>
    MAX_DIGEST = PT_FIXED + 32,
    
    /// <summary> the maximum size of an object context that will be returned by TPM2_ContextSave </summary>
    MAX_OBJECT_CONTEXT = PT_FIXED + 33,
    
    /// <summary> the maximum size of a session context that will be returned by TPM2_ContextSave </summary>
    MAX_SESSION_CONTEXT = PT_FIXED + 34,
    
    /// <summary>
    /// platform-specific family (a TPM_PS value)(see Table 25)
    /// NOTE The platform-specific values for the TPM_PT_PS parameters are in the relevant
    /// platform-specific specification. In the reference implementation, all
    /// of these values are 0.
    /// </summary>
    PS_FAMILY_INDICATOR = PT_FIXED + 35,
    
    /// <summary> the level of the platform-specific specification </summary>
    PS_LEVEL = PT_FIXED + 36,
    
    /// <summary> a platform specific value </summary>
    PS_REVISION = PT_FIXED + 37,
    
    /// <summary>
    /// the platform-specific TPM specification day of year using TCG calendar
    /// EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    /// </summary>
    PS_DAY_OF_YEAR = PT_FIXED + 38,
    
    /// <summary>
    /// the platform-specific TPM specification year using the CE
    /// EXAMPLE The year 2010 has a value of 000007DA16.
    /// </summary>
    PS_YEAR = PT_FIXED + 39,
    
    /// <summary> the number of split signing operations supported by the TPM </summary>
    SPLIT_MAX = PT_FIXED + 40,
    
    /// <summary> total number of commands implemented in the TPM </summary>
    TOTAL_COMMANDS = PT_FIXED + 41,
    
    /// <summary> number of commands from the TPM library that are implemented </summary>
    LIBRARY_COMMANDS = PT_FIXED + 42,
    
    /// <summary> number of vendor commands that are implemented </summary>
    VENDOR_COMMANDS = PT_FIXED + 43,
    
    /// <summary> the maximum data size in one NV write, NV read, NV extend, or NV certify command </summary>
    NV_BUFFER_MAX = PT_FIXED + 44,
    
    /// <summary> a TPMA_MODES value, indicating that the TPM is designed for these modes. </summary>
    MODES = PT_FIXED + 45,
    
    /// <summary> the maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability(). </summary>
    MAX_CAP_BUFFER = PT_FIXED + 46,
    
    /// <summary>
    /// the group of variable properties returned as TPMS_TAGGED_PROPERTY
    /// The properties in this group change because of a Protected Capability other than a
    /// firmware update. The values are not necessarily persistent across all power transitions.
    /// </summary>
    PT_VAR = PT_GROUP * 2,
    
    /// <summary> TPMA_PERMANENT </summary>
    PERMANENT = PT_VAR + 0,
    
    /// <summary> TPMA_STARTUP_CLEAR </summary>
    STARTUP_CLEAR = PT_VAR + 1,
    
    /// <summary> the number of NV Indexes currently defined </summary>
    HR_NV_INDEX = PT_VAR + 2,
    
    /// <summary> the number of authorization sessions currently loaded into TPM RAM </summary>
    HR_LOADED = PT_VAR + 3,
    
    /// <summary>
    /// the number of additional authorization sessions, of any type, that could be loaded into
    /// TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one authorization
    /// session of any type may be loaded. Any command that changes the RAM memory allocation can
    /// make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session would fit into
    /// RAM.
    /// </summary>
    HR_LOADED_AVAIL = PT_VAR + 4,
    
    /// <summary>
    /// the number of active authorization sessions currently being tracked by the TPM
    /// This is the sum of the loaded and saved sessions.
    /// </summary>
    HR_ACTIVE = PT_VAR + 5,
    
    /// <summary>
    /// the number of additional authorization sessions, of any type, that could be created
    /// This value is an estimate. If this value is at least 1, then at least one authorization
    /// session of any type may be created. Any command that changes the RAM memory allocation can
    /// make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one authorization session could be
    /// created.
    /// </summary>
    HR_ACTIVE_AVAIL = PT_VAR + 6,
    
    /// <summary>
    /// estimate of the number of additional transient objects that could be loaded into TPM RAM
    /// This value is an estimate. If this value is at least 1, then at least one object of any
    /// type may be loaded. Any command that changes the memory allocation can make this estimate
    /// invalid.
    /// NOTE A valid implementation may return 1 even if more than one transient object
    /// would fit into RAM.
    /// </summary>
    HR_TRANSIENT_AVAIL = PT_VAR + 7,
    
    /// <summary> the number of persistent objects currently loaded into TPM NV memory </summary>
    HR_PERSISTENT = PT_VAR + 8,
    
    /// <summary>
    /// the number of additional persistent objects that could be loaded into NV memory
    /// This value is an estimate. If this value is at least 1, then at least one object of any
    /// type may be made persistent. Any command that changes the NV memory allocation can make
    /// this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one persistent object would fit into
    /// NV memory.
    /// </summary>
    HR_PERSISTENT_AVAIL = PT_VAR + 9,
    
    /// <summary> the number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute </summary>
    NV_COUNTERS = PT_VAR + 10,
    
    /// <summary>
    /// the number of additional NV Indexes that can be defined with their TPM_NT of
    /// TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET
    /// This value is an estimate. If this value is at least 1, then at least one NV Index may be
    /// created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any command
    /// that changes the NV memory allocation can make this estimate invalid.
    /// NOTE A valid implementation may return 1 even if more than one NV
    /// counter could be defined.
    /// </summary>
    NV_COUNTERS_AVAIL = PT_VAR + 11,
    
    /// <summary> code that limits the algorithms that may be used with the TPM </summary>
    ALGORITHM_SET = PT_VAR + 12,
    
    /// <summary> the number of loaded ECC curves </summary>
    LOADED_CURVES = PT_VAR + 13,
    
    /// <summary> the current value of the lockout counter (failedTries) </summary>
    LOCKOUT_COUNTER = PT_VAR + 14,
    
    /// <summary> the number of authorization failures before DA lockout is invoked </summary>
    MAX_AUTH_FAIL = PT_VAR + 15,
    
    /// <summary> the number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented </summary>
    LOCKOUT_INTERVAL = PT_VAR + 16,
    
    /// <summary>
    /// the number of seconds after a lockoutAuth failure before use of
    /// lockoutAuth may be attempted again
    /// </summary>
    LOCKOUT_RECOVERY = PT_VAR + 17,
    
    /// <summary>
    /// number of milliseconds before the TPM will accept another command that will modify NV
    /// This value is an approximation and may go up or down over time.
    /// </summary>
    NV_WRITE_RECOVERY = PT_VAR + 18,
    
    /// <summary> the high-order 32 bits of the command audit counter </summary>
    AUDIT_COUNTER_0 = PT_VAR + 19,
    
    /// <summary> the low-order 32 bits of the command audit counter </summary>
    AUDIT_COUNTER_1 = PT_VAR + 20
    TPM_ENUM_EPILOGUE(TPM_PT)
};

/// <summary>
/// The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property being
/// selected or returned. The PCR properties can be read when capability ==
/// TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of property,
/// the next higher value is returned, if it exists.
/// </summary>
struct TPM_PT_PCR : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_PT_PCR)
    
    /// <summary> bottom of the range of TPM_PT_PCR properties </summary>
    FIRST = 0x00000000,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and
    /// restored by TPM_SU_STATE
    /// </summary>
    SAVE = 0x00000000,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0
    /// This property is only present if a locality other than 0 is implemented.
    /// </summary>
    EXTEND_L0 = 0x00000001,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
    /// TPM2_PCR_Reset() from locality 0
    /// </summary>
    RESET_L0 = 0x00000002,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1
    /// This property is only present if locality 1 is implemented.
    /// </summary>
    EXTEND_L1 = 0x00000003,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset()
    /// from locality 1
    /// This property is only present if locality 1 is implemented.
    /// </summary>
    RESET_L1 = 0x00000004,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    /// </summary>
    EXTEND_L2 = 0x00000005,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset()
    /// from locality 2
    /// This property is only present if localities 1 and 2 are implemented.
    /// </summary>
    RESET_L2 = 0x00000006,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    /// </summary>
    EXTEND_L3 = 0x00000007,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset()
    /// from locality 3
    /// This property is only present if localities 1, 2, and 3 are implemented.
    /// </summary>
    RESET_L3 = 0x00000008,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are implemented.
    /// </summary>
    EXTEND_L4 = 0x00000009,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset()
    /// from locality 4
    /// This property is only present if localities 1, 2, 3, and 4 are
    /// implemented.
    /// </summary>
    RESET_L4 = 0x0000000A,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or Extend) will
    /// not increment the pcrUpdateCounter
    /// </summary>
    NO_INCREMENT = 0x00000011,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event
    /// These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event
    /// following a _TPM_Hash_Start event.
    /// </summary>
    DRTM_RESET = 0x00000012,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy
    /// This property is only present if the TPM supports policy control of a PCR.
    /// </summary>
    POLICY = 0x00000013,
    
    /// <summary>
    /// a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an authorization
    /// value
    /// This property is only present if the TPM supports authorization control of a PCR.
    /// </summary>
    AUTH = 0x00000014,
    
    /// <summary>
    /// top of the range of TPM_PT_PCR properties of the implementation
    /// If the TPM receives a request for a PCR property with a value larger than this, the TPM
    /// will return a zero length list and set the moreData parameter to NO.
    /// NOTE This is an implementation-specific value. The value shown reflects the
    /// reference code implementation.
    /// </summary>
    LAST = 0x00000014
    TPM_ENUM_EPILOGUE(TPM_PT_PCR)
};

/// <summary> The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR. </summary>
struct TPM_PS : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_PS)
    
    /// <summary> not platform specific </summary>
    MAIN = 0x00000000,
    
    /// <summary> PC Client </summary>
    PC = 0x00000001,
    
    /// <summary> PDA (includes all mobile devices that are not specifically cell phones) </summary>
    PDA = 0x00000002,
    
    /// <summary> Cell Phone </summary>
    CELL_PHONE = 0x00000003,
    
    /// <summary> Server WG </summary>
    SERVER = 0x00000004,
    
    /// <summary> Peripheral WG </summary>
    PERIPHERAL = 0x00000005,
    
    /// <summary> TSS WG (deprecated) </summary>
    TSS = 0x00000006,
    
    /// <summary> Storage WG </summary>
    STORAGE = 0x00000007,
    
    /// <summary> Authentication WG </summary>
    AUTHENTICATION = 0x00000008,
    
    /// <summary> Embedded WG </summary>
    EMBEDDED = 0x00000009,
    
    /// <summary> Hardcopy WG </summary>
    HARDCOPY = 0x0000000A,
    
    /// <summary> Infrastructure WG (deprecated) </summary>
    INFRASTRUCTURE = 0x0000000B,
    
    /// <summary> Virtualization WG </summary>
    VIRTUALIZATION = 0x0000000C,
    
    /// <summary> Trusted Network Connect WG (deprecated) </summary>
    TNC = 0x0000000D,
    
    /// <summary> Multi-tenant WG (deprecated) </summary>
    MULTI_TENANT = 0x0000000E,
    
    /// <summary> Technical Committee (deprecated) </summary>
    TC = 0x0000000F
    TPM_ENUM_EPILOGUE(TPM_PS)
};

/// <summary>
/// The 32-bit handle space is divided into 256 regions of equal size with 224 values in each.
/// Each of these ranges represents a handle type.
/// </summary>
struct TPM_HT : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPM_HT)
    
    /// <summary>
    /// PCR consecutive numbers, starting at 0, that reference the PCR registers
    /// A platform-specific specification will set the minimum number of PCR and an
    /// implementation may have more.
    /// </summary>
    PCR = 0x00,
    
    /// <summary> NV Index assigned by the caller </summary>
    NV_INDEX = 0x01,
    
    /// <summary> HMAC Authorization Session assigned by the TPM when the session is created </summary>
    HMAC_SESSION = 0x02,
    
    /// <summary>
    /// Loaded Authorization Session used only in the context of TPM2_GetCapability
    /// This type references both loaded HMAC and loaded policy authorization sessions.
    /// </summary>
    LOADED_SESSION = 0x02,
    
    /// <summary> Policy Authorization Session assigned by the TPM when the session is created </summary>
    POLICY_SESSION = 0x03,
    
    /// <summary>
    /// Saved Authorization Session used only in the context of TPM2_GetCapability
    /// This type references saved authorization session contexts for which the TPM is
    /// maintaining tracking information.
    /// </summary>
    SAVED_SESSION = 0x03,
    
    /// <summary> Permanent Values assigned by this specification in Table 28 </summary>
    PERMANENT = 0x40,
    
    /// <summary>
    /// Transient Objects assigned by the TPM when an object is loaded into transient-object
    /// memory or when a persistent object is converted to a transient object
    /// </summary>
    TRANSIENT = 0x80,
    
    /// <summary> Persistent Objects assigned by the TPM when a loaded transient object is made persistent </summary>
    PERSISTENT = 0x81,
    
    /// <summary> Attached Component handle for an Attached Component. </summary>
    AC = 0x90
    TPM_ENUM_EPILOGUE(TPM_HT)
};

/// <summary>
/// Table 28 lists the architecturally defined handles that cannot be changed. The handles
/// include authorization handles, and special handles.
/// </summary>
struct TPM_RH : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_RH)
    
    FIRST = 0x40000000,
    
    /// <summary> not used1 </summary>
    SRK = 0x40000000,
    
    /// <summary> handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy </summary>
    OWNER = 0x40000001,
    
    /// <summary> not used1 </summary>
    REVOKE = 0x40000002,
    
    /// <summary> not used1 </summary>
    TRANSPORT = 0x40000003,
    
    /// <summary> not used1 </summary>
    OPERATOR = 0x40000004,
    
    /// <summary> not used1 </summary>
    ADMIN = 0x40000005,
    
    /// <summary> not used1 </summary>
    EK = 0x40000006,
    
    /// <summary>
    /// a handle associated with the null hierarchy, an EmptyAuth authValue, and an
    /// Empty Policy authPolicy.
    /// </summary>
    _NULL = 0x40000007,
    
    /// <summary>
    /// value reserved to the TPM to indicate a handle location that has not
    /// been initialized or assigned
    /// </summary>
    UNASSIGNED = 0x40000008,
    
    /// <summary> authorization value used to indicate a password authorization session </summary>
    PW = 0x40000009,
    
    /// <summary> Deprecated: use PW instead </summary>
    RS_PW [[deprecated("Use TPM_RH::PW instead")]] = 0x40000009,
    
    /// <summary> references the authorization associated with the dictionary attack lockout reset </summary>
    LOCKOUT = 0x4000000A,
    
    /// <summary> references the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy </summary>
    ENDORSEMENT = 0x4000000B,
    
    /// <summary> references the Platform Primary Seed (PPS), platformAuth, and platformPolicy </summary>
    PLATFORM = 0x4000000C,
    
    /// <summary> for phEnableNV </summary>
    PLATFORM_NV = 0x4000000D,
    
    /// <summary>
    /// Start of a range of authorization values that are vendor-specific. A TPM may support any
    /// of the values in this range as are needed for vendor-specific purposes.
    /// Disabled if ehEnable is CLEAR.
    /// NOTE Any includes none.
    /// </summary>
    AUTH_00 = 0x40000010,
    
    /// <summary> End of the range of vendor-specific authorization values. </summary>
    AUTH_FF = 0x4000010F,
    
    /// <summary> Start of the range of authenticated timers </summary>
    ACT_0 = 0x40000110,
    
    /// <summary> End of the range of authenticated timers </summary>
    ACT_F = 0x4000011F,
    
    /// <summary>
    /// the top of the reserved handle area
    /// This is set to allow TPM2_GetCapability() to know where to stop. It may vary as implementations
    /// add to the permanent handle area.
    /// </summary>
    LAST = 0x4000011F
    TPM_ENUM_EPILOGUE(TPM_RH)
};

/// <summary> This table lists the values of the TPM_NT field of a TPMA_NV. See Table 215 for usage. </summary>
struct TPM_NT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_NT)
    
    /// <summary>
    /// Ordinary contains data that is opaque to the TPM that can only be
    /// modified using TPM2_NV_Write().
    /// </summary>
    ORDINARY = 0x0,
    
    /// <summary>
    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    /// </summary>
    COUNTER = 0x1,
    
    /// <summary>
    /// Bit Field contains an 8-octet value to be used as a bit field and can only be
    /// modified with TPM2_NV_SetBits().
    /// </summary>
    BITS = 0x2,
    
    /// <summary>
    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    /// </summary>
    EXTEND = 0x4,
    
    /// <summary> PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit </summary>
    PIN_FAIL = 0x8,
    
    /// <summary> PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit </summary>
    PIN_PASS = 0x9
    TPM_ENUM_EPILOGUE(TPM_NT)
};

/// <summary>
/// These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value
/// returned from an attached component.
/// </summary>
struct TPM_AT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_AT)
    
    /// <summary>
    /// in a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    /// </summary>
    ANY = 0x00000000,
    
    /// <summary> indicates a TCG defined, device-specific error </summary>
    _ERROR = 0x00000001,
    
    /// <summary> indicates the most significant 32 bits of a pairing value for the AC </summary>
    PV1 = 0x00000002,
    
    /// <summary> value added to a TPM_AT to indicate a vendor-specific tag value </summary>
    VEND = 0x80000000
    TPM_ENUM_EPILOGUE(TPM_AT)
};

/// <summary> These constants are the TCG-defined error values returned by an AC. </summary>
struct TPM_AE : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_AE)
    
    /// <summary>
    /// in a command, a non-specific request for AC information; in a response, indicates that
    /// outputData is not meaningful
    /// </summary>
    NONE = 0x00000000
    TPM_ENUM_EPILOGUE(TPM_AE)
};

/// <summary> These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values. </summary>
struct PLATFORM : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(PLATFORM)
    
    FAMILY = TPM_SPEC::FAMILY,
    
    LEVEL = TPM_SPEC::LEVEL,
    
    VERSION = TPM_SPEC::VERSION,
    
    YEAR = TPM_SPEC::YEAR,
    
    DAY_OF_YEAR = TPM_SPEC::DAY_OF_YEAR
    TPM_ENUM_EPILOGUE(PLATFORM)
};

/// <summary>
/// This table contains a collection of values used in various parts of the reference code. The
/// values shown are illustrative.
/// </summary>
struct Implementation : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(Implementation)
    
    /// <summary> temporary define </summary>
    FIELD_UPGRADE_IMPLEMENTED = Logic::NO,
    
    /// <summary> Selection of the library that provides the basic hashing functions. </summary>
    HASH_LIB = ImplementationConstants::Ossl,
    
    /// <summary>
    /// Selection of the library that provides the low-level symmetric cryptography. Choices are
    /// determined by the vendor (See LibSupport.h for implications).
    /// </summary>
    SYM_LIB = ImplementationConstants::Ossl,
    
    /// <summary>
    /// Selection of the library that provides the big number math including ECC. Choices are
    /// determined by the vendor (See LibSupport.h for implications).
    /// </summary>
    MATH_LIB = ImplementationConstants::Ossl,
    
    /// <summary> the number of PCR in the TPM </summary>
    IMPLEMENTATION_PCR = 24,
    
    PCR_SELECT_MAX = ((IMPLEMENTATION_PCR+7)/8),
    
    /// <summary> the number of PCR required by the relevant platform specification </summary>
    PLATFORM_PCR = 24,
    
    PCR_SELECT_MIN = ((PLATFORM_PCR + 7) / 8),
    
    /// <summary>
    /// the D-RTM PCR
    /// NOTE This value is not defined when the TPM does not implement D-RTM
    /// </summary>
    DRTM_PCR = 17,
    
    /// <summary>
    /// the PCR that will receive the H-CRTM value at TPM2_Startup. This
    /// value should not be changed.
    /// </summary>
    HCRTM_PCR = 0,
    
    /// <summary>
    /// the number of localities supported by the TPM
    /// This is expected to be either 5 for a PC, or 1 for just about everything else.
    /// </summary>
    NUM_LOCALITIES = 5,
    
    /// <summary>
    /// the maximum number of handles in the handle area
    /// This should be produced by the Part 3 parser but is here for now.
    /// </summary>
    MAX_HANDLE_NUM = 3,
    
    /// <summary> the number of simultaneously active sessions that are supported by the TPM implementation </summary>
    MAX_ACTIVE_SESSIONS = 64,
    
    /// <summary> the number of sessions that the TPM may have in memory </summary>
    MAX_LOADED_SESSIONS = 3,
    
    /// <summary> this is the current maximum value </summary>
    MAX_SESSION_NUM = 3,
    
    /// <summary>
    /// the number of simultaneously loaded objects that are supported by the TPM; this number
    /// does not include the objects that may be placed in NV memory by TPM2_EvictControl().
    /// </summary>
    MAX_LOADED_OBJECTS = 3,
    
    /// <summary> the minimum number of evict objects supported by the TPM </summary>
    MIN_EVICT_OBJECTS = 2,
    
    /// <summary> number of PCR groups that have individual policies </summary>
    NUM_POLICY_PCR_GROUP = 1,
    
    /// <summary> number of PCR groups that have individual authorization values </summary>
    NUM_AUTHVALUE_PCR_GROUP = 1,
    
    MAX_CONTEXT_SIZE = 1264,
    
    MAX_DIGEST_BUFFER = 1024,
    
    /// <summary> maximum data size allowed in an NV Index </summary>
    MAX_NV_INDEX_SIZE = 2048,
    
    /// <summary> maximum data size in one NV read or write command </summary>
    MAX_NV_BUFFER_SIZE = 1024,
    
    /// <summary> maximum size of a capability buffer </summary>
    MAX_CAP_BUFFER = 1024,
    
    /// <summary> size of NV memory in octets </summary>
    NV_MEMORY_SIZE = 16384,
    
    /// <summary>
    /// the TPM will not allocate a non-counter index if it would prevent allocation
    /// of this number of indices.
    /// </summary>
    MIN_COUNTER_INDICES = 8,
    
    NUM_STATIC_PCR = 16,
    
    /// <summary> number of algorithms that can be in a list </summary>
    MAX_ALG_LIST_SIZE = 64,
    
    /// <summary> size of the Primary Seed in octets </summary>
    PRIMARY_SEED_SIZE = 32,
    
    /// <summary>
    /// context encryption algorithm
    /// Just use the root so that the macros in GpMacros.h will work correctly.
    /// </summary>
    CONTEXT_ENCRYPT_ALGORITHM = TPM_ALG_ID::AES,
    
    /// <summary>
    /// the update interval expressed as a power of 2 seconds
    /// A value of 12 is 4,096 seconds (~68 minutes).
    /// </summary>
    NV_CLOCK_UPDATE_INTERVAL = 12,
    
    /// <summary> number of PCR groups that allow policy/auth </summary>
    NUM_POLICY_PCR = 1,
    
    /// <summary> maximum size of a command </summary>
    MAX_COMMAND_SIZE = 4096,
    
    /// <summary> maximum size of a response </summary>
    MAX_RESPONSE_SIZE = 4096,
    
    /// <summary> number between 1 and 32 inclusive </summary>
    ORDERLY_BITS = 8,
    
    /// <summary>
    /// the maximum number of octets that may be in a sealed blob; 128 is
    /// the minimum allowed value
    /// </summary>
    MAX_SYM_DATA = 128,
    
    MAX_RNG_ENTROPY_SIZE = 64,
    
    /// <summary>
    /// Number of bytes used for the RAM index space. If this is not large enough, it might not be
    /// possible to allocate orderly indices.
    /// </summary>
    RAM_INDEX_SPACE = 512,
    
    /// <summary> 216 + 1 </summary>
    RSA_DEFAULT_PUBLIC_EXPONENT = 0x00010001,
    
    /// <summary> indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented </summary>
    ENABLE_PCR_NO_INCREMENT = Logic::YES,
    
    CRT_FORMAT_RSA = Logic::YES,
    
    VENDOR_COMMAND_COUNT = 0,
    
    /// <summary> Maximum size of the vendor-specific buffer </summary>
    MAX_VENDOR_BUFFER_SIZE = 1024,
    
    /// <summary>
    /// L value for a derivation. This is the
    /// maximum number of bits allowed from an instantiation of a KDF-DRBG. This is size is OK because
    /// RSA keys are never derived keys
    /// </summary>
    MAX_DERIVATION_BITS = 8192,
    
    RSA_MAX_PRIME = (ImplementationConstants::MAX_RSA_KEY_BYTES/2),
    
    RSA_PRIVATE_SIZE = (RSA_MAX_PRIME * 5),
    
    SIZE_OF_X509_SERIAL_NUMBER = 20,
    
    /// <summary>
    /// This is a vendor-specific value so it is in this vendor-speific table. When this is used,
    /// RSA_PRIVATE_SIZE will have been defined
    /// </summary>
    PRIVATE_VENDOR_SPECIFIC_BYTES = RSA_PRIVATE_SIZE
    TPM_ENUM_EPILOGUE(Implementation)
};

/// <summary> The definitions in Table 29 are used to define many of the interface data types. </summary>
struct TPM_HC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_HC)
    
    /// <summary> to mask off the HR </summary>
    HR_HANDLE_MASK = 0x00FFFFFF,
    
    /// <summary> to mask off the variable part </summary>
    HR_RANGE_MASK = 0xFF000000,
    
    HR_SHIFT = 24,
    
    HR_PCR = (TPM_HT::PCR << HR_SHIFT),
    
    HR_HMAC_SESSION = (TPM_HT::HMAC_SESSION << HR_SHIFT),
    
    HR_POLICY_SESSION = (TPM_HT::POLICY_SESSION << HR_SHIFT),
    
    HR_TRANSIENT = (TPM_HT::TRANSIENT << HR_SHIFT),
    
    HR_PERSISTENT = (TPM_HT::PERSISTENT << HR_SHIFT),
    
    HR_NV_INDEX = (TPM_HT::NV_INDEX << HR_SHIFT),
    
    HR_PERMANENT = (TPM_HT::PERMANENT << HR_SHIFT),
    
    /// <summary> first PCR </summary>
    PCR_FIRST = (HR_PCR + 0),
    
    /// <summary> last PCR </summary>
    PCR_LAST = (PCR_FIRST + Implementation::IMPLEMENTATION_PCR-1),
    
    /// <summary> first HMAC session </summary>
    HMAC_SESSION_FIRST = (HR_HMAC_SESSION + 0),
    
    /// <summary> last HMAC session </summary>
    HMAC_SESSION_LAST = (HMAC_SESSION_FIRST+Implementation::MAX_ACTIVE_SESSIONS-1),
    
    /// <summary> used in GetCapability </summary>
    LOADED_SESSION_FIRST = HMAC_SESSION_FIRST,
    
    /// <summary> used in GetCapability </summary>
    LOADED_SESSION_LAST = HMAC_SESSION_LAST,
    
    /// <summary> first policy session </summary>
    POLICY_SESSION_FIRST = (HR_POLICY_SESSION + 0),
    
    /// <summary> last policy session </summary>
    POLICY_SESSION_LAST = (POLICY_SESSION_FIRST + Implementation::MAX_ACTIVE_SESSIONS-1),
    
    /// <summary> first transient object </summary>
    TRANSIENT_FIRST = (HR_TRANSIENT + 0),
    
    /// <summary> used in GetCapability </summary>
    ACTIVE_SESSION_FIRST = POLICY_SESSION_FIRST,
    
    /// <summary> used in GetCapability </summary>
    ACTIVE_SESSION_LAST = POLICY_SESSION_LAST,
    
    /// <summary> last transient object </summary>
    TRANSIENT_LAST = (TRANSIENT_FIRST+Implementation::MAX_LOADED_OBJECTS-1),
    
    /// <summary> first persistent object </summary>
    PERSISTENT_FIRST = (HR_PERSISTENT + 0),
    
    /// <summary> last persistent object </summary>
    PERSISTENT_LAST = (PERSISTENT_FIRST + 0x00FFFFFF),
    
    /// <summary> first platform persistent object </summary>
    PLATFORM_PERSISTENT = (PERSISTENT_FIRST + 0x00800000),
    
    /// <summary> first allowed NV Index </summary>
    NV_INDEX_FIRST = (HR_NV_INDEX + 0),
    
    /// <summary> last allowed NV Index </summary>
    NV_INDEX_LAST = (NV_INDEX_FIRST + 0x00FFFFFF),
    
    PERMANENT_FIRST = TPM_RH::FIRST,
    
    PERMANENT_LAST = TPM_RH::LAST,
    
    /// <summary> AC aliased NV Index </summary>
    HR_NV_AC = ((TPM_HT::NV_INDEX << HR_SHIFT) + 0xD00000),
    
    /// <summary> first NV Index aliased to Attached Component </summary>
    NV_AC_FIRST = (HR_NV_AC + 0),
    
    /// <summary> last NV Index aliased to Attached Component </summary>
    NV_AC_LAST = (HR_NV_AC + 0x0000FFFF),
    
    /// <summary> AC Handle </summary>
    HR_AC = (TPM_HT::AC << HR_SHIFT),
    
    /// <summary> first Attached Component </summary>
    AC_FIRST = (HR_AC + 0),
    
    /// <summary> last Attached Component </summary>
    AC_LAST = (HR_AC + 0x0000FFFF)
    TPM_ENUM_EPILOGUE(TPM_HC)
};

/// <summary> This structure defines the attributes of an algorithm. </summary>
struct TPMA_ALGORITHM : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_ALGORITHM)
    
    /// <summary>
    /// SET (1): an asymmetric algorithm with public and private portions
    /// CLEAR (0): not an asymmetric algorithm
    /// </summary>
    asymmetric = 0x1,
    
    /// <summary>
    /// SET (1): a symmetric block cipher
    /// CLEAR (0): not a symmetric block cipher
    /// </summary>
    symmetric = 0x2,
    
    /// <summary>
    /// SET (1): a hash algorithm
    /// CLEAR (0): not a hash algorithm
    /// </summary>
    hash = 0x4,
    
    /// <summary>
    /// SET (1): an algorithm that may be used as an object type
    /// CLEAR (0): an algorithm that is not used as an object type
    /// </summary>
    object = 0x8,
    
    /// <summary>
    /// SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will indicate
    /// the type of signing algorithm.
    /// CLEAR (0): not a signing algorithm
    /// </summary>
    signing = 0x100,
    
    /// <summary>
    /// SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and
    /// hash will indicate the type of encryption/decryption algorithm.
    /// CLEAR (0): not an encryption/decryption algorithm
    /// </summary>
    encrypting = 0x200,
    
    /// <summary>
    /// SET (1): a method such as a key derivative function (KDF)
    /// CLEAR (0): not a method
    /// </summary>
    method = 0x400
    TPM_ENUM_EPILOGUE(TPMA_ALGORITHM)
};

/// <summary>
/// This attribute structure indicates an objects use, its authorization types, and its
/// relationship to other objects.
/// </summary>
struct TPMA_OBJECT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_OBJECT)
    
    /// <summary>
    /// SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change.
    /// CLEAR (0): The hierarchy of the object may change as a result of this object or an
    /// ancestor key being duplicated for use in another hierarchy.
    /// NOTE fixedTPM does not indicate that key material resides on a single TPM
    /// (see sensitiveDataOrigin).
    /// </summary>
    fixedTPM = 0x2,
    
    /// <summary>
    /// SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR).
    /// CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE)
    /// and subsequent Startup().
    /// </summary>
    stClear = 0x4,
    
    /// <summary>
    /// SET (1): The parent of the object may not change.
    /// CLEAR (0): The parent of the object may change as the result of a
    /// TPM2_Duplicate() of the object.
    /// </summary>
    fixedParent = 0x10,
    
    /// <summary>
    /// SET (1): Indicates that, when the object was created with TPM2_Create() or
    /// TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the
    /// authValue.
    /// CLEAR (0): A portion of the sensitive data, other than the authValue, was
    /// provided by the caller.
    /// </summary>
    sensitiveDataOrigin = 0x20,
    
    /// <summary>
    /// SET (1): Approval of USER role actions with this object may be with an HMAC session or
    /// with a password using the authValue of the object or a policy session.
    /// CLEAR (0): Approval of USER role actions with this object may only be
    /// done with a policy session.
    /// </summary>
    userWithAuth = 0x40,
    
    /// <summary>
    /// SET (1): Approval of ADMIN role actions with this object may only be done with a policy
    /// session.
    /// CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session or
    /// with a password using the authValue of the object or a policy session.
    /// </summary>
    adminWithPolicy = 0x80,
    
    /// <summary>
    /// SET (1): The object is not subject to dictionary attack protections.
    /// CLEAR (0): The object is subject to dictionary attack protections.
    /// </summary>
    noDA = 0x400,
    
    /// <summary>
    /// SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and
    /// newParentHandle shall not be TPM_RH_NULL.
    /// CLEAR (0): The object may be duplicated without an inner wrapper on the private portion of
    /// the object and the new parent may be TPM_RH_NULL.
    /// </summary>
    encryptedDuplication = 0x800,
    
    /// <summary>
    /// SET (1): Key usage is restricted to manipulate structures of known format; the parent of
    /// this key shall have restricted SET.
    /// CLEAR (0): Key usage is not restricted to use on special formats.
    /// </summary>
    restricted = 0x10000,
    
    /// <summary>
    /// SET (1): The private portion of the key may be used to decrypt.
    /// CLEAR (0): The private portion of the key may not be used to decrypt.
    /// </summary>
    decrypt = 0x20000,
    
    /// <summary>
    /// SET (1): For a symmetric cipher object, the private portion of the key may be used to
    /// encrypt. For other objects, the private portion of the key may be used to sign.
    /// CLEAR (0): The private portion of the key may not be used to sign or encrypt.
    /// </summary>
    sign = 0x40000,
    
    /// <summary> Alias to the sign value. </summary>
    encrypt = 0x40000,
    
    /// <summary>
    /// SET (1): An asymmetric key that may not be used to sign with TPM2_Sign()
    /// CLEAR (0): A key that may be used with TPM2_Sign() if sign is SET
    /// NOTE: This attribute only has significance if sign is SET.
    /// </summary>
    x509sign = 0x80000
    TPM_ENUM_EPILOGUE(TPMA_OBJECT)
};

/// <summary>
/// This octet in each session is used to identify the session type, indicate its relationship
/// to any handles in the command, and indicate its use in parameter encryption.
/// </summary>
struct TPMA_SESSION : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPMA_SESSION)
    
    /// <summary>
    /// SET (1): In a command, this setting indicates that the session is to remain active after
    /// successful completion of the command. In a response, it indicates that the session is
    /// still active. If SET in the command, this attribute shall be SET in the response.
    /// CLEAR (0): In a command, this setting indicates that the TPM should close the session and
    /// flush any related context when the command completes successfully. In a response, it
    /// indicates that the session is closed and the context is no longer active.
    /// This attribute has no meaning for a password authorization and the TPM will allow any
    /// setting of the attribute in the command and SET the attribute in the response.
    /// This attribute will only be CLEAR in one response for a logical session. If the attribute
    /// is CLEAR, the context associated with the session is no longer in use and the space is
    /// available. A session created after another session is ended may have the same handle but
    /// logically is not the same session.
    /// This attribute has no effect if the command does not complete successfully.
    /// </summary>
    continueSession = 0x1,
    
    /// <summary>
    /// SET (1): In a command, this setting indicates that the command should only be executed if
    /// the session is exclusive at the start of the command. In a response, it indicates that the
    /// session is exclusive. This setting is only allowed if the audit attribute is SET
    /// (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the session need not be exclusive at the start of
    /// the command. In a response, indicates that the session is not exclusive.
    /// </summary>
    auditExclusive = 0x2,
    
    /// <summary>
    /// SET (1): In a command, this setting indicates that the audit digest of the session should
    /// be initialized and the exclusive status of the session SET. This setting is only allowed
    /// if the audit attribute is SET (TPM_RC_ATTRIBUTES).
    /// CLEAR (0): In a command, indicates that the audit digest should not be initialized.
    /// This bit is always CLEAR in a response.
    /// </summary>
    auditReset = 0x4,
    
    /// <summary>
    /// SET (1): In a command, this setting indicates that the first parameter in the command is
    /// symmetrically encrypted using the parameter encryption scheme described in TPM 2.0 Part 1.
    /// The TPM will decrypt the parameter after performing any HMAC computations and before
    /// unmarshaling the parameter. In a response, the attribute is copied from the request but
    /// has no effect on the response.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and
    /// response.
    /// This attribute may be SET in a session that is not associated with a command handle. Such
    /// a session is provided for purposes of encrypting a parameter and not for authorization.
    /// This attribute may be SET in combination with any other session attributes.
    /// </summary>
    decrypt = 0x20,
    
    /// <summary>
    /// SET (1): In a command, this setting indicates that the TPM should use this session to
    /// encrypt the first parameter in the response. In a response, it indicates that the
    /// attribute was set in the command and that the TPM used the session to encrypt the first
    /// parameter in the response using the parameter encryption scheme described in TPM 2.0 Part
    /// 1.
    /// CLEAR (0): Session not used for encryption.
    /// For a password authorization, this attribute will be CLEAR in both the command and
    /// response.
    /// This attribute may be SET in a session that is not associated with a command handle. Such
    /// a session is provided for purposes of encrypting a parameter and not for authorization.
    /// </summary>
    encrypt = 0x40,
    
    /// <summary>
    /// SET (1): In a command or response, this setting indicates that the session is for audit
    /// and that auditExclusive and auditReset have meaning. This session may also be used for
    /// authorization, encryption, or decryption. The encrypted and encrypt fields may be SET or
    /// CLEAR.
    /// CLEAR (0): Session is not used for audit.
    /// If SET in the command, then this attribute will be SET in the response.
    /// </summary>
    audit = 0x80
    TPM_ENUM_EPILOGUE(TPMA_SESSION)
};

/// <summary>
/// In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of the
/// command that created the object. No more than one of the locality attributes shall
/// be set in the creation data.
/// </summary>
struct TPMA_LOCALITY : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPMA_LOCALITY)
    
    LOC_ZERO = 0x1,
    
    LOC_ONE = 0x2,
    
    LOC_TWO = 0x4,
    
    LOC_THREE = 0x8,
    
    LOC_FOUR = 0x10,
    
    /// <summary> If any of these bits is set, an extended locality is indicated </summary>
    Extended_BIT_MASK = 0x000000E0,
    Extended_BIT_OFFSET = 5,
    Extended_BIT_LENGTH = 3,
    TPM_ENUM_EPILOGUE(TPMA_LOCALITY)
};

/// <summary>
/// The attributes in this structure are persistent and are not changed as a result of
/// _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change as
/// the result of specific Protected Capabilities. This structure may be read using
/// TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
/// </summary>
struct TPMA_PERMANENT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_PERMANENT)
    
    /// <summary>
    /// SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last
    /// TPM2_Clear().
    /// CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
    /// </summary>
    ownerAuthSet = 0x1,
    
    /// <summary>
    /// SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the last
    /// TPM2_Clear().
    /// CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
    /// </summary>
    endorsementAuthSet = 0x2,
    
    /// <summary>
    /// SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last
    /// TPM2_Clear().
    /// CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
    /// </summary>
    lockoutAuthSet = 0x4,
    
    /// <summary>
    /// SET (1): TPM2_Clear() is disabled.
    /// CLEAR (0): TPM2_Clear() is enabled.
    /// NOTE See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    disableClear = 0x100,
    
    /// <summary> SET (1): The TPM is in lockout, when failedTries is equal to maxTries. </summary>
    inLockout = 0x200,
    
    /// <summary>
    /// SET (1): The EPS was created by the TPM.
    /// CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
    /// </summary>
    tpmGeneratedEPS = 0x400
    TPM_ENUM_EPILOGUE(TPMA_PERMANENT)
};

/// <summary>
/// This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES,
/// property = TPM_PT_STARTUP_CLEAR).
/// </summary>
struct TPMA_STARTUP_CLEAR : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_STARTUP_CLEAR)
    
    /// <summary>
    /// SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be used
    /// for authorization.
    /// CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and objects
    /// in the platform hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    phEnable = 0x1,
    
    /// <summary>
    /// SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for
    /// authorization. NV indices defined using owner authorization are accessible.
    /// CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects in
    /// the Storage hierarchy, persistent objects, and NV indices defined using owner
    /// authorization cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    shEnable = 0x2,
    
    /// <summary>
    /// SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to
    /// authorize commands.
    /// CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects in
    /// the endorsement hierarchy, including persistent objects, cannot be used.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// </summary>
    ehEnable = 0x4,
    
    /// <summary>
    /// SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The
    /// platform can create define and undefine indices.
    /// CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written
    /// (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined
    /// (TPM_RC_HANDLE) indices.
    /// NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    /// NOTE
    /// read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify,
    /// TPM2_PolicyNV
    /// write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend,
    /// TPM2_NV_SetBits
    /// NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine whether
    /// phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index does not
    /// exist, it also returns this error code if the index is disabled. Otherwise, the TPM would
    /// leak the existence of an index even when disabled.
    /// </summary>
    phEnableNV = 0x8,
    
    /// <summary>
    /// SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup().
    /// CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type.
    /// NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed by a
    /// TPM2_Startup() of any type. However, the TPM will return an error if
    /// TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
    /// </summary>
    orderly = 0x80000000
    TPM_ENUM_EPILOGUE(TPMA_STARTUP_CLEAR)
};

/// <summary>
/// This structure of this attribute is used to report the memory management method used by
/// the TPM for transient objects and authorization sessions. This structure may be read using
/// TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
/// </summary>
struct TPMA_MEMORY : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_MEMORY)
    
    /// <summary>
    /// SET (1): indicates that the RAM memory used for authorization session contexts is shared
    /// with the memory used for transient objects
    /// CLEAR (0): indicates that the memory used for authorization sessions is not shared with
    /// memory used for transient objects
    /// </summary>
    sharedRAM = 0x1,
    
    /// <summary>
    /// SET (1): indicates that the NV memory used for persistent objects is shared with the NV
    /// memory used for NV Index values
    /// CLEAR (0): indicates that the persistent objects and NV Index values are allocated
    /// from separate sections of NV
    /// </summary>
    sharedNV = 0x2,
    
    /// <summary>
    /// SET (1): indicates that the TPM copies persistent objects to a transient-object slot in
    /// RAM when the persistent object is referenced in a command. The TRM is required to make
    /// sure that an object slot is available.
    /// CLEAR (0): indicates that the TPM does not use transient-object slots when
    /// persistent objects are referenced
    /// </summary>
    objectCopiedToRam = 0x4
    TPM_ENUM_EPILOGUE(TPMA_MEMORY)
};

/// <summary>
/// This structure defines the attributes of a command from a context management perspective.
/// The fields of the structure indicate to the TPM Resource Manager (TRM) the number of
/// resources required by a command and how the command affects the TPMs resources.
/// </summary>
struct TPMA_CC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_CC)
    
    /// <summary> indicates the command being selected </summary>
    commandIndex_BIT_MASK = 0x0000FFFF,
    commandIndex_BIT_OFFSET = 0,
    commandIndex_BIT_LENGTH = 16,
    
    /// <summary>
    /// SET (1): indicates that the command may write to NV
    /// CLEAR (0): indicates that the command does not write to NV
    /// </summary>
    nv = 0x400000,
    
    /// <summary>
    /// SET (1): This command could flush any number of loaded contexts.
    /// CLEAR (0): no additional changes other than indicated by the flushed attribute
    /// </summary>
    extensive = 0x800000,
    
    /// <summary>
    /// SET (1): The context associated with any transient handle in the command will be flushed
    /// when this command completes.
    /// CLEAR (0): No context is flushed as a side effect of this command.
    /// </summary>
    flushed = 0x1000000,
    
    /// <summary> indicates the number of the handles in the handle area for this command </summary>
    cHandles_BIT_MASK = 0x0E000000,
    cHandles_BIT_OFFSET = 25,
    cHandles_BIT_LENGTH = 3,
    
    /// <summary> SET (1): indicates the presence of the handle area in the response </summary>
    rHandle = 0x10000000,
    
    /// <summary>
    /// SET (1): indicates that the command is vendor-specific
    /// CLEAR (0): indicates that the command is defined in a version of this specification
    /// </summary>
    V = 0x20000000,
    
    /// <summary> allocated for software; shall be zero </summary>
    Res_BIT_MASK = 0xC0000000,
    Res_BIT_OFFSET = 30,
    Res_BIT_LENGTH = 2,
    TPM_ENUM_EPILOGUE(TPMA_CC)
};

/// <summary>
/// This structure of this attribute is used to report that the TPM is designed for these
/// modes. This structure may be read using TPM2_GetCapability(capability =
/// TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
/// </summary>
struct TPMA_MODES : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_MODES)
    
    /// <summary>
    /// SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2
    /// requirements at Level 1 or higher.
    /// </summary>
    FIPS_140_2 = 0x1
    TPM_ENUM_EPILOGUE(TPMA_MODES)
};

/// <summary>
/// These attributes are as specified in clause 4.2.1.3. of RFC 5280 Internet X.509 Public Key
/// Infrastructure Certificate and Certificate Revocation List (CRL) Profile. For
/// TPM2_CertifyX509, when a caller provides a DER encoded Key Usage in partialCertificate,
/// the TPM will validate that the key to be certified meets the requirements of Key Usage.
/// </summary>
struct TPMA_X509_KEY_USAGE : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_X509_KEY_USAGE)
    
    /// <summary> Attributes.Decrypt SET </summary>
    decipherOnly = 0x800000,
    
    /// <summary> Attributes.Decrypt SET </summary>
    encipherOnly = 0x1000000,
    
    /// <summary> Attributes.sign SET </summary>
    cRLSign = 0x2000000,
    
    /// <summary> Attributes.sign SET </summary>
    keyCertSign = 0x4000000,
    
    /// <summary> Attributes.Decrypt SET </summary>
    keyAgreement = 0x8000000,
    
    /// <summary> Attributes.Decrypt SET </summary>
    dataEncipherment = 0x10000000,
    
    /// <summary> asymmetric key with decrypt and restricted SET key has the attributes of a parent key </summary>
    keyEncipherment = 0x20000000,
    
    /// <summary> fixedTPM SET in Subject Key (objectHandle) </summary>
    nonrepudiation = 0x40000000,
    
    /// <summary> Alias to the nonrepudiation value. </summary>
    contentCommitment = 0x40000000,
    
    /// <summary> sign SET in Subject Key (objectHandle) </summary>
    digitalSignature = 0x80000000
    TPM_ENUM_EPILOGUE(TPMA_X509_KEY_USAGE)
};

/// <summary>
/// This attribute is used to report the ACT state. This attribute may be read using
/// TPM2_GetCapability(capability = TPM_CAP_ACT, property = TPM_RH_ACT_x where x is the ACT
/// number (0-F)). The signaled value must be preserved across TPM Resume or if the TPM has
/// not lost power. The signaled value may be preserved over a power cycle of a TPM.
/// </summary>
struct TPMA_ACT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_ACT)
    
    /// <summary>
    /// SET (1): The ACT has signaled
    /// CLEAR (0): The ACT has not signaled
    /// </summary>
    signaled = 0x1,
    
    /// <summary> Preserves the state of signaled, depending on the power cycle </summary>
    preserveSignaled = 0x2
    TPM_ENUM_EPILOGUE(TPMA_ACT)
};

/// <summary>
/// A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the
/// Index is changed from TPM 1.2 in order to include the Index in the reserved handle space.
/// Handles in this range use the digest of the public area of the Index as the Name of the
/// entity in authorization computations
/// </summary>
struct TPM_NV_INDEX : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_NV_INDEX)
    
    /// <summary> The Index of the NV location </summary>
    index_BIT_MASK = 0x00FFFFFF,
    index_BIT_OFFSET = 0,
    index_BIT_LENGTH = 24,
    
    /// <summary> constant value of TPM_HT_NV_INDEX indicating the NV Index range </summary>
    RhNv_BIT_MASK = 0xFF000000,
    RhNv_BIT_OFFSET = 24,
    RhNv_BIT_LENGTH = 8,
    TPM_ENUM_EPILOGUE(TPM_NV_INDEX)
};

/// <summary>
/// This structure allows the TPM to keep track of the data and permissions
/// to manipulate an NV Index.
/// </summary>
struct TPMA_NV : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_NV)
    
    /// <summary>
    /// SET (1): The Index data can be written if Platform Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
    /// </summary>
    PPWRITE = 0x1,
    
    /// <summary>
    /// SET (1): The Index data can be written if Owner Authorization is provided.
    /// CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
    /// </summary>
    OWNERWRITE = 0x2,
    
    /// <summary>
    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with an HMAC session or password.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not be provided
    /// with an HMAC session or password.
    /// </summary>
    AUTHWRITE = 0x4,
    
    /// <summary>
    /// SET (1): Authorizations to change the Index contents that require USER role may be
    /// provided with a policy session.
    /// CLEAR (0): Authorizations to change the Index contents that require USER role may not be
    /// provided with a policy session.
    /// NOTE TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
    /// </summary>
    POLICYWRITE = 0x8,
    
    /// <summary>
    /// Ordinary contains data that is opaque to the TPM that can only be
    /// modified using TPM2_NV_Write().
    /// </summary>
    ORDINARY = 0x0,
    
    /// <summary>
    /// Counter contains an 8-octet value that is to be used as a counter and can only be
    /// modified with TPM2_NV_Increment()
    /// </summary>
    COUNTER = 0x10,
    
    /// <summary>
    /// Bit Field contains an 8-octet value to be used as a bit field and can only be
    /// modified with TPM2_NV_SetBits().
    /// </summary>
    BITS = 0x20,
    
    /// <summary>
    /// Extend contains a digest-sized value used like a PCR. The Index can only be modified
    /// using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    /// </summary>
    EXTEND = 0x40,
    
    /// <summary> PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit </summary>
    PIN_FAIL = 0x80,
    
    /// <summary> PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit </summary>
    PIN_PASS = 0x90,
    
    /// <summary>
    /// The type of the index.
    /// NOTE A TPM is not required to support all TPM_NT values
    /// </summary>
    TpmNt_BIT_MASK = 0x000000F0,
    TpmNt_BIT_OFFSET = 4,
    TpmNt_BIT_LENGTH = 4,
    
    /// <summary>
    /// SET (1): Index may not be deleted unless the authPolicy is satisfied using
    /// TPM2_NV_UndefineSpaceSpecial().
    /// CLEAR (0): Index may be deleted with proper platform or owner authorization using
    /// TPM2_NV_UndefineSpace().
    /// NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an
    /// Empty Policy) cannot be deleted.
    /// </summary>
    POLICY_DELETE = 0x400,
    
    /// <summary>
    /// SET (1): Index cannot be written.
    /// CLEAR (0): Index can be written.
    /// </summary>
    WRITELOCKED = 0x800,
    
    /// <summary>
    /// SET (1): A partial write of the Index data is not allowed. The write size shall match the
    /// defined space size.
    /// CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of the
    /// Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
    /// </summary>
    WRITEALL = 0x1000,
    
    /// <summary>
    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if
    /// TPMA_NV_WRITE_STCLEAR is also CLEAR.
    /// </summary>
    WRITEDEFINE = 0x2000,
    
    /// <summary>
    /// SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location until
    /// the next TPM Reset or TPM Restart.
    /// CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if
    /// TPMA_NV_WRITEDEFINE is also CLEAR.
    /// </summary>
    WRITE_STCLEAR = 0x4000,
    
    /// <summary>
    /// SET (1): If TPM2_NV_GlobalWriteLock() is successful, TPMA_NV_WRITELOCKED is set.
    /// CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of
    /// the data at this Index.
    /// </summary>
    GLOBALLOCK = 0x8000,
    
    /// <summary>
    /// SET (1): The Index data can be read if Platform Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
    /// </summary>
    PPREAD = 0x10000,
    
    /// <summary>
    /// SET (1): The Index data can be read if Owner Authorization is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
    /// </summary>
    OWNERREAD = 0x20000,
    
    /// <summary>
    /// SET (1): The Index data may be read if the authValue is provided.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
    /// </summary>
    AUTHREAD = 0x40000,
    
    /// <summary>
    /// SET (1): The Index data may be read if the authPolicy is satisfied.
    /// CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
    /// </summary>
    POLICYREAD = 0x80000,
    
    /// <summary>
    /// SET (1): Authorization failures of the Index do not affect the DA logic and authorization
    /// of the Index is not blocked when the TPM is in Lockout mode.
    /// CLEAR (0): Authorization failures of the Index will increment the authorization failure
    /// counter and authorizations of this Index are not allowed when the TPM is in Lockout mode.
    /// </summary>
    NO_DA = 0x2000000,
    
    /// <summary>
    /// SET (1): NV Index state is only required to be saved when the TPM performs an orderly
    /// shutdown (TPM2_Shutdown()).
    /// CLEAR (0): NV Index state is required to be persistent after the command to update the
    /// Index completes successfully (that is, the NV update is synchronous
    /// with the update command).
    /// </summary>
    ORDERLY = 0x4000000,
    
    /// <summary>
    /// SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart.
    /// CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart.
    /// NOTE This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
    /// </summary>
    CLEAR_STCLEAR = 0x8000000,
    
    /// <summary>
    /// SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart.
    /// CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
    /// </summary>
    READLOCKED = 0x10000000,
    
    /// <summary>
    /// SET (1): Index has been written.
    /// CLEAR (0): Index has not been written.
    /// </summary>
    WRITTEN = 0x20000000,
    
    /// <summary>
    /// SET (1): This Index may be undefined with Platform Authorization but not with Owner
    /// Authorization.
    /// CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform
    /// Authorization.
    /// The TPM will validate that this attribute is SET when the Index is defined using Platform
    /// Authorization and will validate that this attribute is CLEAR when the Index is
    /// defined using Owner Authorization.
    /// </summary>
    PLATFORMCREATE = 0x40000000,
    
    /// <summary>
    /// SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index.
    /// CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
    /// </summary>
    READ_STCLEAR = 0x80000000
    TPM_ENUM_EPILOGUE(TPMA_NV)
};

/// <summary> Base class for TPM union interfaces </summary>
class _DLLEXP_ TpmUnion: public virtual TpmStructure {};

/// <summary>
/// Table 119 Definition of TPMU_CAPABILITIES Union [OUT]
/// (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
/// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
/// TPML_TAGGED_POLICY, TPML_ACT_DATA])
/// </summary>
class _DLLEXP_ TPMU_CAPABILITIES: public virtual TpmUnion
{
    public: virtual TPM_CAP GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_CAPABILITIES_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// Table 132 Definition of TPMU_ATTEST Union [OUT]
/// (One of [TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO, TPMS_COMMAND_AUDIT_INFO,
/// TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO, TPMS_NV_CERTIFY_INFO,
/// TPMS_NV_DIGEST_CERTIFY_INFO])
/// </summary>
class _DLLEXP_ TPMU_ATTEST: public virtual TpmUnion
{
    public: virtual TPM_ST GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_ATTEST_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// This union allows additional parameters to be added for a symmetric cipher. Currently, no
/// additional parameters are required for any of the symmetric algorithms.
/// (One of [TPMS_TDES_SYM_DETAILS, TPMS_AES_SYM_DETAILS, TPMS_SM4_SYM_DETAILS,
/// TPMS_CAMELLIA_SYM_DETAILS, TPMS_ANY_SYM_DETAILS, TPMS_XOR_SYM_DETAILS,
/// TPMS_NULL_SYM_DETAILS])
/// </summary>
class _DLLEXP_ TPMU_SYM_DETAILS: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SYM_DETAILS_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a
/// TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are determined
/// by context. When an object is being derived, the derivation values are present.
/// (One of [BYTE, TPMS_DERIVE])
/// </summary>
class _DLLEXP_ TPMU_SENSITIVE_CREATE: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SENSITIVE_CREATE_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// Table 157 Definition of TPMU_SCHEME_KEYEDHASH Union [IN/OUT]
/// (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
/// </summary>
class _DLLEXP_ TPMU_SCHEME_KEYEDHASH: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// This is the union of all of the signature schemes.
/// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
/// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
/// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
/// </summary>
class _DLLEXP_ TPMU_SIG_SCHEME: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SIG_SCHEME_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// Table 166 Definition of TPMU_KDF_SCHEME Union [IN/OUT]
/// (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
/// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
/// </summary>
class _DLLEXP_ TPMU_KDF_SCHEME: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_KDF_SCHEME_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// This union of all asymmetric schemes is used in each of the asymmetric scheme structures.
/// The actual scheme structure is defined by the interface type used for the
/// selector (TPMI_ALG_ASYM_SCHEME).
/// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
/// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
/// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
/// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
/// </summary>
class _DLLEXP_ TPMU_ASYM_SCHEME: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_ASYM_SCHEME_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by a
/// particular TPM implementation. The union allows substitution of any signature algorithm
/// wherever a signature is required in a structure.
/// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
/// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
/// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
/// </summary>
class _DLLEXP_ TPMU_SIGNATURE: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SIGNATURE_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
/// (One of [TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
/// TPMS_ECC_POINT, TPMS_DERIVE])
/// </summary>
class _DLLEXP_ TPMU_PUBLIC_ID: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_PUBLIC_ID_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// Table 199 defines the possible parameter definition structures that may be contained in
/// the public portion of a key. If the Object can be a parent, the first field must be a
/// TPMT_SYM_DEF_OBJECT. See 11.1.7.
/// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS,
/// TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
/// </summary>
class _DLLEXP_ TPMU_PUBLIC_PARMS: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_PUBLIC_PARMS_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary>
/// Table 205 Definition of TPMU_SENSITIVE_COMPOSITE Union [IN/OUT]
/// (One of [TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA, TPM2B_SYM_KEY,
/// TPM2B_PRIVATE_VENDOR_SPECIFIC])
/// </summary>
class _DLLEXP_ TPMU_SENSITIVE_COMPOSITE: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmTypeId GetTypeId() const { return TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID; };
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/// <summary> Handle of a loaded TPM key or other object [TSS] </summary>
class _DLLEXP_ _TPM_HANDLE : public TpmStructure
{
    /// <summary> Handle value </summary>
    public: UINT32 handle;

public:
    _TPM_HANDLE() { handle = TPM_RH::_NULL; }
    _TPM_HANDLE(UINT32 _handle)
      : handle(_handle)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPM_HANDLE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPM_HANDLE

#include "Extensions/TPM_HANDLE.h"

/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
class _DLLEXP_ TPMS_NULL_UNION : public virtual TpmStructure, public TPMU_SYM_DETAILS, public TPMU_SCHEME_KEYEDHASH, public TPMU_SIG_SCHEME, public TPMU_KDF_SCHEME, public TPMU_ASYM_SCHEME, public TPMU_SIGNATURE
{
public:
    TPMS_NULL_UNION() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    virtual const char* TypeName () const { return "TPMS_NULL_UNION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NULL_UNION

/// <summary>
/// This structure is used as a placeholder. In some cases, a union will have a selector value
/// with no data to unmarshal when that type is selected. Rather than leave the entry
/// empty, TPMS_EMPTY may be selected.
/// </summary>
class _DLLEXP_ TPMS_EMPTY : public virtual TpmStructure, public TPMU_ASYM_SCHEME
{
public:
    TPMS_EMPTY() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAES; }
    
    virtual const char* TypeName () const { return "TPMS_EMPTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_EMPTY

/// <summary>
/// This structure is a return value for a TPM2_GetCapability() that reads
/// the installed algorithms.
/// </summary>
class _DLLEXP_ TPMS_ALGORITHM_DESCRIPTION : public TpmStructure
{
    /// <summary> an algorithm </summary>
    public: TPM_ALG_ID alg;
    
    /// <summary> the attributes of the algorithm </summary>
    public: TPMA_ALGORITHM attributes;

public:
    TPMS_ALGORITHM_DESCRIPTION() { alg = TPM_ALG_ID::_NULL; }
    TPMS_ALGORITHM_DESCRIPTION(TPM_ALG_ID _alg, TPMA_ALGORITHM _attributes)
      : alg(_alg), attributes(_attributes)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ALGORITHM_DESCRIPTION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ALGORITHM_DESCRIPTION

/// <summary>
/// Table 80 shows the basic hash-agile structure used in this specification. To handle hash
/// agility, this structure uses the hashAlg parameter to indicate the algorithm used to
/// compute the digest and, by implication, the size of the digest.
/// </summary>
class _DLLEXP_ _TPMT_HA : public virtual TpmStructure, public TPMU_SIGNATURE
{
    /// <summary>
    /// selector of the hash contained in the digest that implies the size of the digest
    /// NOTE The leading + on the type indicates that this structure should pass an indication to
    /// the unmarshaling function for TPMI_ALG_HASH so that TPM_ALG_NULL will be allowed if a use of
    /// a TPMT_HA allows TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID hashAlg;
    
    /// <summary> Hash value </summary>
    public: ByteVec digest;

public:
    _TPMT_HA() { hashAlg = TPM_ALG_ID::_NULL; }
    _TPMT_HA(TPM_ALG_ID _hashAlg, const ByteVec& _digest)
      : hashAlg(_hashAlg), digest(_digest)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::HMAC; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPMT_HA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPMT_HA

#include "Extensions/TPMT_HA.h"

/// <summary>
/// This structure is used for a sized buffer that cannot be larger than the largest digest
/// produced by any hash algorithm implemented on the TPM.
/// </summary>
class _DLLEXP_ TPM2B_DIGEST : public virtual TpmStructure, public TPMU_PUBLIC_ID
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the buffer area that can be no larger than a digest </summary>
    public: ByteVec buffer;

public:
    TPM2B_DIGEST() {}
    TPM2B_DIGEST(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    operator ByteVec&() { return buffer; }
    operator const ByteVec&() const { return buffer; }
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_DIGEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_DIGEST

/// <summary>
/// This structure is used for a data buffer that is required to be no larger than the
/// size of the Name of an object.
/// </summary>
class _DLLEXP_ TPM2B_DATA : public TpmStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 size;
    
    public: ByteVec buffer;

public:
    TPM2B_DATA() {}
    TPM2B_DATA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_DATA

/// <summary> Table 83 Definition of Types for TPM2B_NONCE </summary>
typedef TPM2B_DIGEST TPM2B_NONCE;

/// <summary>
/// This structure is used for an authorization value and limits an authValue to being no
/// larger than the largest digest produced by a TPM. In order to ensure consistency within an
/// object, the authValue may be no larger than the size of the digest produced by the objects
/// nameAlg. This ensures that any TPM that can load the object will be able to handle
/// the authValue of the object.
/// </summary>
typedef TPM2B_DIGEST TPM2B_AUTH;

/// <summary>
/// This type is a sized buffer that can hold an operand for a comparison with an NV Index
/// location. The maximum size of the operand is implementation dependent but a TPM is
/// required to support an operand size that is at least as big as the digest produced by any
/// of the hash algorithms implemented on the TPM.
/// </summary>
typedef TPM2B_DIGEST TPM2B_OPERAND;

/// <summary> This type is a sized buffer that can hold event data. </summary>
class _DLLEXP_ TPM2B_EVENT : public TpmStructure
{
    /// <summary> size of the operand buffer </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the operand </summary>
    public: ByteVec buffer;

public:
    TPM2B_EVENT() {}
    TPM2B_EVENT(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_EVENT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_EVENT

/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for commands that use a
/// large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
/// </summary>
class _DLLEXP_ TPM2B_MAX_BUFFER : public TpmStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the operand </summary>
    public: ByteVec buffer;

public:
    TPM2B_MAX_BUFFER() {}
    TPM2B_MAX_BUFFER(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_MAX_BUFFER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_MAX_BUFFER

/// <summary>
/// This type is a sized buffer that can hold a maximally sized buffer for NV data commands
/// such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
/// </summary>
class _DLLEXP_ TPM2B_MAX_NV_BUFFER : public TpmStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 size;
    
    /// <summary>
    /// the operand
    /// NOTE MAX_NV_BUFFER_SIZE is TPM-dependent
    /// </summary>
    public: ByteVec buffer;

public:
    TPM2B_MAX_NV_BUFFER() {}
    TPM2B_MAX_NV_BUFFER(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_MAX_NV_BUFFER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_MAX_NV_BUFFER

/// <summary>
/// This TPM-dependent structure is used to provide the timeout value for an authorization.
/// The size shall be 8 or less.
/// </summary>
class _DLLEXP_ TPM2B_TIMEOUT : public TpmStructure
{
    /// <summary> size of the timeout value </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the timeout value </summary>
    public: ByteVec buffer;

public:
    TPM2B_TIMEOUT() {}
    TPM2B_TIMEOUT(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_TIMEOUT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_TIMEOUT

/// <summary>
/// This structure is used for passing an initial value for a symmetric block cipher to or
/// from the TPM. The size is set to be the largest block size of any implemented symmetric
/// cipher implemented on the TPM.
/// </summary>
class _DLLEXP_ TPM2B_IV : public TpmStructure
{
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the IV value </summary>
    public: ByteVec buffer;

public:
    TPM2B_IV() {}
    TPM2B_IV(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_IV"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_IV

/// <summary> This buffer holds a Name for any entity type. </summary>
class _DLLEXP_ TPM2B_NAME : public TpmStructure
{
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the Name structure </summary>
    public: ByteVec name;

public:
    TPM2B_NAME() {}
    TPM2B_NAME(const ByteVec& _name)
      : name(_name)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_NAME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_NAME

/// <summary> This structure provides a standard method of specifying a list of PCR. </summary>
class _DLLEXP_ TPMS_PCR_SELECT : public TpmStructure
{
    /// <summary> the size in octets of the pcrSelect array </summary>
    protected: mutable UINT8 sizeofSelect;
    
    /// <summary> the bit map of selected PCR </summary>
    public: ByteVec pcrSelect;

public:
    TPMS_PCR_SELECT() {}
    TPMS_PCR_SELECT(const ByteVec& _pcrSelect)
      : pcrSelect(_pcrSelect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_PCR_SELECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_PCR_SELECT

/// <summary> Table 94 Definition of TPMS_PCR_SELECTION Structure </summary>
class _DLLEXP_ _TPMS_PCR_SELECTION : public TpmStructure
{
    /// <summary> the hash algorithm associated with the selection </summary>
    public: TPM_ALG_ID hash;
    
    /// <summary> the size in octets of the pcrSelect array </summary>
    protected: mutable UINT8 sizeofSelect;
    
    /// <summary> the bit map of selected PCR </summary>
    public: ByteVec pcrSelect;

public:
    _TPMS_PCR_SELECTION() { hash = TPM_ALG_ID::_NULL; }
    _TPMS_PCR_SELECTION(TPM_ALG_ID _hash, const ByteVec& _pcrSelect)
      : hash(_hash), pcrSelect(_pcrSelect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPMS_PCR_SELECTION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPMS_PCR_SELECTION

#include "Extensions/TPMS_PCR_SELECTION.h"

/// <summary>
/// This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the
/// creation data to the object to which it applies. The ticket is computed by
/// </summary>
class _DLLEXP_ TPMT_TK_CREATION : public TpmStructure
{
    /// <summary> the hierarchy containing name </summary>
    public: TPM_HANDLE hierarchy;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 digestSize;
    
    /// <summary> This shall be the HMAC produced using a proof value of hierarchy. </summary>
    public: ByteVec digest;

public:
    TPMT_TK_CREATION() {}
    TPMT_TK_CREATION(const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_TK_CREATION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_TK_CREATION

/// <summary>
/// This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple
/// ticket uses. The ticket provides evidence that the TPM has validated that a digest was
/// signed by a key with the Name of keyName. The ticket is computed by
/// </summary>
class _DLLEXP_ TPMT_TK_VERIFIED : public TpmStructure
{
    /// <summary> the hierarchy containing keyName </summary>
    public: TPM_HANDLE hierarchy;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 digestSize;
    
    /// <summary> This shall be the HMAC produced using a proof value of hierarchy. </summary>
    public: ByteVec digest;

public:
    TPMT_TK_VERIFIED() {}
    TPMT_TK_VERIFIED(const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_TK_VERIFIED"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_TK_VERIFIED

/// <summary>
/// This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the
/// authorization has an expiration time. If nonceTPM was provided in the policy
/// command, the ticket is computed by
/// </summary>
class _DLLEXP_ TPMT_TK_AUTH : public TpmStructure
{
    /// <summary> ticket structure tag </summary>
    public: TPM_ST tag;
    
    /// <summary> the hierarchy of the object used to produce the ticket </summary>
    public: TPM_HANDLE hierarchy;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 digestSize;
    
    /// <summary> This shall be the HMAC produced using a proof value of hierarchy. </summary>
    public: ByteVec digest;

public:
    TPMT_TK_AUTH() {}
    TPMT_TK_AUTH(TPM_ST _tag, const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : tag(_tag), hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_TK_AUTH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_TK_AUTH

/// <summary>
/// This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that
/// was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
/// </summary>
class _DLLEXP_ _TPMT_TK_HASHCHECK : public TpmStructure
{
    /// <summary> the hierarchy </summary>
    public: TPM_HANDLE hierarchy;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 digestSize;
    
    /// <summary> This shall be the HMAC produced using a proof value of hierarchy. </summary>
    public: ByteVec digest;

public:
    _TPMT_TK_HASHCHECK() {}
    _TPMT_TK_HASHCHECK(const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPMT_TK_HASHCHECK"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPMT_TK_HASHCHECK

#include "Extensions/TPMT_TK_HASHCHECK.h"

/// <summary>
/// This structure is used to report the properties of an algorithm identifier. It is returned
/// in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
/// </summary>
class _DLLEXP_ TPMS_ALG_PROPERTY : public TpmStructure
{
    /// <summary> an algorithm identifier </summary>
    public: TPM_ALG_ID alg;
    
    /// <summary> the attributes of the algorithm </summary>
    public: TPMA_ALGORITHM algProperties;

public:
    TPMS_ALG_PROPERTY() { alg = TPM_ALG_ID::_NULL; }
    TPMS_ALG_PROPERTY(TPM_ALG_ID _alg, TPMA_ALGORITHM _algProperties)
      : alg(_alg), algProperties(_algProperties)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ALG_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ALG_PROPERTY

/// <summary>
/// This structure is used to report the properties that are UINT32 values. It is returned in
/// response to a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPMS_TAGGED_PROPERTY : public TpmStructure
{
    /// <summary> a property identifier </summary>
    public: TPM_PT property;
    
    /// <summary> the value of the property </summary>
    public: UINT32 value;

public:
    TPMS_TAGGED_PROPERTY() {}
    TPMS_TAGGED_PROPERTY(TPM_PT _property, UINT32 _value)
      : property(_property), value(_value)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_TAGGED_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_TAGGED_PROPERTY

/// <summary> This structure is used in TPM2_GetCapability() to return the attributes of the PCR. </summary>
class _DLLEXP_ TPMS_TAGGED_PCR_SELECT : public TpmStructure
{
    /// <summary> the property identifier </summary>
    public: TPM_PT_PCR tag;
    
    /// <summary> the size in octets of the pcrSelect array </summary>
    protected: mutable UINT8 sizeofSelect;
    
    /// <summary> the bit map of PCR with the identified property </summary>
    public: ByteVec pcrSelect;

public:
    TPMS_TAGGED_PCR_SELECT() {}
    TPMS_TAGGED_PCR_SELECT(TPM_PT_PCR _tag, const ByteVec& _pcrSelect)
      : tag(_tag), pcrSelect(_pcrSelect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_TAGGED_PCR_SELECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_TAGGED_PCR_SELECT

/// <summary>
/// This structure is used in TPM2_GetCapability() to return the policy
/// associated with a permanent handle.
/// </summary>
class _DLLEXP_ TPMS_TAGGED_POLICY : public TpmStructure
{
    /// <summary> a permanent handle </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> the policy algorithm and hash </summary>
    public: TPMT_HA policyHash;

public:
    TPMS_TAGGED_POLICY() {}
    TPMS_TAGGED_POLICY(const TPM_HANDLE& _handle, const TPMT_HA& _policyHash)
      : handle(_handle), policyHash(_policyHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_TAGGED_POLICY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_TAGGED_POLICY

/// <summary> This structure is used in TPM2_GetCapability() to return the ACT data. </summary>
class _DLLEXP_ TPMS_ACT_DATA : public TpmStructure
{
    /// <summary> a permanent handle </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> the current timeout of the ACT </summary>
    public: UINT32 timeout;
    
    /// <summary> the state of the ACT </summary>
    public: TPMA_ACT attributes;

public:
    TPMS_ACT_DATA() {}
    TPMS_ACT_DATA(const TPM_HANDLE& _handle, UINT32 _timeout, TPMA_ACT _attributes)
      : handle(_handle), timeout(_timeout), attributes(_attributes)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ACT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ACT_DATA

/// <summary>
/// A list of command codes may be input to the TPM or returned by the TPM
/// depending on the command.
/// </summary>
class _DLLEXP_ TPML_CC : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary> number of commands in the commandCode list; may be 0 </summary>
    protected: mutable UINT32 count;
    
    /// <summary>
    /// a list of command codes
    /// The maximum only applies to a command code list in a command. The response size is limited only by
    /// the size of the parameter buffer.
    /// </summary>
    public: vector<TPM_CC> commandCodes;

public:
    TPML_CC() {}
    TPML_CC(const vector<TPM_CC>& _commandCodes)
      : commandCodes(_commandCodes)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::PP_COMMANDS; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_CC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_CC

/// <summary> This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS). </summary>
class _DLLEXP_ TPML_CCA : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary> number of values in the commandAttributes list; may be 0 </summary>
    protected: mutable UINT32 count;
    
    /// <summary> a list of command codes attributes </summary>
    public: vector<TPMA_CC> commandAttributes;

public:
    TPML_CCA() {}
    TPML_CCA(const vector<TPMA_CC>& _commandAttributes)
      : commandAttributes(_commandAttributes)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::COMMANDS; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_CCA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_CCA

/// <summary> This list is returned by TPM2_IncrementalSelfTest(). </summary>
class _DLLEXP_ TPML_ALG : public TpmStructure
{
    /// <summary> number of algorithms in the algorithms list; may be 0 </summary>
    protected: mutable UINT32 count;
    
    /// <summary>
    /// a list of algorithm IDs
    /// The maximum only applies to an algorithm list in a command. The response size is limited only by
    /// the size of the parameter buffer.
    /// </summary>
    public: vector<TPM_ALG_ID> algorithms;

public:
    TPML_ALG() {}
    TPML_ALG(const vector<TPM_ALG_ID>& _algorithms)
      : algorithms(_algorithms)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_ALG"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_ALG

/// <summary>
/// This structure is used when the TPM returns a list of loaded handles when the capability in
/// TPM2_GetCapability() is TPM_CAP_HANDLE.
/// </summary>
class _DLLEXP_ TPML_HANDLE : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// the number of handles in the list
    /// may have a value of 0
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> an array of handles </summary>
    public: vector<TPM_HANDLE> handle;

public:
    TPML_HANDLE() {}
    TPML_HANDLE(const vector<TPM_HANDLE>& _handle)
      : handle(_handle)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::HANDLES; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_HANDLE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_HANDLE

/// <summary>
/// This list is used to convey a list of digest values. This type is used in
/// TPM2_PolicyOR() and in TPM2_PCR_Read().
/// </summary>
class _DLLEXP_ TPML_DIGEST : public TpmStructure
{
    /// <summary> number of digests in the list, minimum is two for TPM2_PolicyOR(). </summary>
    protected: mutable UINT32 count;
    
    /// <summary>
    /// a list of digests
    /// For TPM2_PolicyOR(), all digests will have been computed using the digest of the policy
    /// session. For TPM2_PCR_Read(), each digest will be the size of the digest for
    /// the bank containing the PCR.
    /// </summary>
    public: vector<TPM2B_DIGEST> digests;

public:
    TPML_DIGEST() {}
    TPML_DIGEST(const vector<TPM2B_DIGEST>& _digests)
      : digests(_digests)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_DIGEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_DIGEST

/// <summary>
/// This list is used to convey a list of digest values. This type is returned by
/// TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend().
/// </summary>
class _DLLEXP_ TPML_DIGEST_VALUES : public TpmStructure
{
    /// <summary> number of digests in the list </summary>
    protected: mutable UINT32 count;
    
    /// <summary> a list of tagged digests </summary>
    public: vector<TPMT_HA> digests;

public:
    TPML_DIGEST_VALUES() {}
    TPML_DIGEST_VALUES(const vector<TPMT_HA>& _digests)
      : digests(_digests)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_DIGEST_VALUES"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_DIGEST_VALUES

/// <summary>
/// This list is used to indicate the PCR that are included in a selection when more than
/// one PCR value may be selected.
/// </summary>
class _DLLEXP_ TPML_PCR_SELECTION : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> list of selections </summary>
    public: vector<TPMS_PCR_SELECTION> pcrSelections;

public:
    TPML_PCR_SELECTION() {}
    TPML_PCR_SELECTION(const vector<TPMS_PCR_SELECTION>& _pcrSelections)
      : pcrSelections(_pcrSelections)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::PCRS; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_PCR_SELECTION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_PCR_SELECTION

/// <summary>
/// This list is used to report on a list of algorithm attributes. It is returned
/// in a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_ALG_PROPERTY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// number of algorithm properties structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> list of properties </summary>
    public: vector<TPMS_ALG_PROPERTY> algProperties;

public:
    TPML_ALG_PROPERTY() {}
    TPML_ALG_PROPERTY(const vector<TPMS_ALG_PROPERTY>& _algProperties)
      : algProperties(_algProperties)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::ALGS; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_ALG_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_ALG_PROPERTY

/// <summary>
/// This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is
/// returned by a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_TAGGED_TPM_PROPERTY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// number of properties
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> an array of tagged properties </summary>
    public: vector<TPMS_TAGGED_PROPERTY> tpmProperty;

public:
    TPML_TAGGED_TPM_PROPERTY() {}
    TPML_TAGGED_TPM_PROPERTY(const vector<TPMS_TAGGED_PROPERTY>& _tpmProperty)
      : tpmProperty(_tpmProperty)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::TPM_PROPERTIES; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_TAGGED_TPM_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_TAGGED_TPM_PROPERTY

/// <summary>
/// This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is
/// returned by a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_TAGGED_PCR_PROPERTY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// number of properties
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> a tagged PCR selection </summary>
    public: vector<TPMS_TAGGED_PCR_SELECT> pcrProperty;

public:
    TPML_TAGGED_PCR_PROPERTY() {}
    TPML_TAGGED_PCR_PROPERTY(const vector<TPMS_TAGGED_PCR_SELECT>& _pcrProperty)
      : pcrProperty(_pcrProperty)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::PCR_PROPERTIES; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_TAGGED_PCR_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_TAGGED_PCR_PROPERTY

/// <summary>
/// This list is used to report the ECC curve ID values supported by the TPM. It is
/// returned by a TPM2_GetCapability().
/// </summary>
class _DLLEXP_ TPML_ECC_CURVE : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// number of curves
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> array of ECC curve identifiers </summary>
    public: vector<TPM_ECC_CURVE> eccCurves;

public:
    TPML_ECC_CURVE() {}
    TPML_ECC_CURVE(const vector<TPM_ECC_CURVE>& _eccCurves)
      : eccCurves(_eccCurves)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::ECC_CURVES; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_ECC_CURVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_ECC_CURVE

/// <summary>
/// This list is used to report the authorization policy values for permanent handles. This is
/// list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a
/// policy is not included in the list.
/// </summary>
class _DLLEXP_ TPML_TAGGED_POLICY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// number of tagged policies
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> array of tagged policies </summary>
    public: vector<TPMS_TAGGED_POLICY> policies;

public:
    TPML_TAGGED_POLICY() {}
    TPML_TAGGED_POLICY(const vector<TPMS_TAGGED_POLICY>& _policies)
      : policies(_policies)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::AUTH_POLICIES; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_TAGGED_POLICY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_TAGGED_POLICY

/// <summary>
/// This list is used to report the timeout and state for the ACT. This list may be generated
/// by TPM2_GetCapabilty(). Only implemented ACT are present in the list
/// </summary>
class _DLLEXP_ TPML_ACT_DATA : public virtual TpmStructure, public TPMU_CAPABILITIES
{
    /// <summary>
    /// number of ACT instances
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 count;
    
    /// <summary> array of ACT data </summary>
    public: vector<TPMS_ACT_DATA> actData;

public:
    TPML_ACT_DATA() {}
    TPML_ACT_DATA(const vector<TPMS_ACT_DATA>& _actData)
      : actData(_actData)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_CAP GetUnionSelector() const { return TPM_CAP::ACT; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_ACT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_ACT_DATA

/// <summary> This data area is returned in response to a TPM2_GetCapability(). </summary>
class _DLLEXP_ TPMS_CAPABILITY_DATA : public TpmStructure
{
    public: TPM_CAP get_capability() const { return data->GetUnionSelector(); }
    
    /// <summary> the capability </summary>
    protected: mutable TPM_CAP capability;
    
    /// <summary>
    /// the capability data
    /// (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA])
    /// </summary>
    public: shared_ptr<TPMU_CAPABILITIES> data;

public:
    TPMS_CAPABILITY_DATA() {}
    TPMS_CAPABILITY_DATA(const TPMU_CAPABILITIES& _data)
      : data(dynamic_cast<TPMU_CAPABILITIES*>(_data.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_CAPABILITY_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CAPABILITY_DATA

/// <summary> This structure is used in each of the attestation commands. </summary>
class _DLLEXP_ TPMS_CLOCK_INFO : public TpmStructure
{
    /// <summary>
    /// time value in milliseconds that advances while the TPM is powered
    /// NOTE The interpretation of the time-origin (clock=0) is out of the scope of this
    /// specification, although Coordinated Universal Time (UTC) is expected to be a common
    /// convention. This structure element is used to report on the TPM's Clock value.
    /// This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()).
    /// This value may be advanced by TPM2_ClockSet().
    /// </summary>
    public: UINT64 clock;
    
    /// <summary> number of occurrences of TPM Reset since the last TPM2_Clear() </summary>
    public: UINT32 resetCount;
    
    /// <summary>
    /// number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the
    /// last TPM Reset or TPM2_Clear().
    /// </summary>
    public: UINT32 restartCount;
    
    /// <summary>
    /// no value of Clock greater than the current value of Clock has been previously reported by the
    /// TPM. Set to YES on TPM2_Clear().
    /// </summary>
    public: BYTE safe;

public:
    TPMS_CLOCK_INFO() {}
    TPMS_CLOCK_INFO(UINT64 _clock, UINT32 _resetCount, UINT32 _restartCount, BYTE _safe)
      : clock(_clock), resetCount(_resetCount), restartCount(_restartCount), safe(_safe)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_CLOCK_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CLOCK_INFO

/// <summary> This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock(). </summary>
class _DLLEXP_ TPMS_TIME_INFO : public TpmStructure
{
    /// <summary>
    /// time in milliseconds since the TIme circuit was last reset
    /// This structure element is used to report on the TPM's Time value.
    /// </summary>
    public: UINT64 time;
    
    /// <summary> a structure containing the clock information </summary>
    public: TPMS_CLOCK_INFO clockInfo;

public:
    TPMS_TIME_INFO() {}
    TPMS_TIME_INFO(UINT64 _time, const TPMS_CLOCK_INFO& _clockInfo)
      : time(_time), clockInfo(_clockInfo)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_TIME_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_TIME_INFO

/// <summary> This structure is used when the TPM performs TPM2_GetTime. </summary>
class _DLLEXP_ TPMS_TIME_ATTEST_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary> the Time, Clock, resetCount, restartCount, and Safe indicator </summary>
    public: TPMS_TIME_INFO time;
    
    /// <summary> a TPM vendor-specific value indicating the version number of the firmware </summary>
    public: UINT64 firmwareVersion;

public:
    TPMS_TIME_ATTEST_INFO() {}
    TPMS_TIME_ATTEST_INFO(const TPMS_TIME_INFO& _time, UINT64 _firmwareVersion)
      : time(_time), firmwareVersion(_firmwareVersion)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_TIME; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_TIME_ATTEST_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_TIME_ATTEST_INFO

/// <summary> This is the attested data for TPM2_Certify(). </summary>
class _DLLEXP_ TPMS_CERTIFY_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nameSize;
    
    /// <summary> Name of the certified object </summary>
    public: ByteVec name;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 qualifiedNameSize;
    
    /// <summary> Qualified Name of the certified object </summary>
    public: ByteVec qualifiedName;

public:
    TPMS_CERTIFY_INFO() {}
    TPMS_CERTIFY_INFO(const ByteVec& _name, const ByteVec& _qualifiedName)
      : name(_name), qualifiedName(_qualifiedName)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_CERTIFY; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_CERTIFY_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CERTIFY_INFO

/// <summary> This is the attested data for TPM2_Quote(). </summary>
class _DLLEXP_ TPMS_QUOTE_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectCount;
    
    /// <summary> information on algID, PCR selected and digest </summary>
    public: vector<TPMS_PCR_SELECTION> pcrSelect;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 pcrDigestSize;
    
    /// <summary> digest of the selected PCR using the hash of the signing key </summary>
    public: ByteVec pcrDigest;

public:
    TPMS_QUOTE_INFO() {}
    TPMS_QUOTE_INFO(const vector<TPMS_PCR_SELECTION>& _pcrSelect, const ByteVec& _pcrDigest)
      : pcrSelect(_pcrSelect), pcrDigest(_pcrDigest)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_QUOTE; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_QUOTE_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_QUOTE_INFO

/// <summary> This is the attested data for TPM2_GetCommandAuditDigest(). </summary>
class _DLLEXP_ TPMS_COMMAND_AUDIT_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary> the monotonic audit counter </summary>
    public: UINT64 auditCounter;
    
    /// <summary> hash algorithm used for the command audit </summary>
    public: TPM_ALG_ID digestAlg;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 auditDigestSize;
    
    /// <summary> the current value of the audit digest </summary>
    public: ByteVec auditDigest;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 commandDigestSize;
    
    /// <summary> digest of the command codes being audited using digestAlg </summary>
    public: ByteVec commandDigest;

public:
    TPMS_COMMAND_AUDIT_INFO() { digestAlg = TPM_ALG_ID::_NULL; }
    TPMS_COMMAND_AUDIT_INFO(UINT64 _auditCounter, TPM_ALG_ID _digestAlg, const ByteVec& _auditDigest, const ByteVec& _commandDigest)
      : auditCounter(_auditCounter), digestAlg(_digestAlg), auditDigest(_auditDigest), commandDigest(_commandDigest)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_COMMAND_AUDIT; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_COMMAND_AUDIT_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_COMMAND_AUDIT_INFO

/// <summary> This is the attested data for TPM2_GetSessionAuditDigest(). </summary>
class _DLLEXP_ TPMS_SESSION_AUDIT_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary>
    /// current exclusive status of the session
    /// TRUE if all of the commands recorded in the sessionDigest were executed without any
    /// intervening TPM command that did not use this audit session
    /// </summary>
    public: BYTE exclusiveSession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 sessionDigestSize;
    
    /// <summary> the current value of the session audit digest </summary>
    public: ByteVec sessionDigest;

public:
    TPMS_SESSION_AUDIT_INFO() {}
    TPMS_SESSION_AUDIT_INFO(BYTE _exclusiveSession, const ByteVec& _sessionDigest)
      : exclusiveSession(_exclusiveSession), sessionDigest(_sessionDigest)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_SESSION_AUDIT; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SESSION_AUDIT_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SESSION_AUDIT_INFO

/// <summary> This is the attested data for TPM2_CertifyCreation(). </summary>
class _DLLEXP_ TPMS_CREATION_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 objectNameSize;
    
    /// <summary> Name of the object </summary>
    public: ByteVec objectName;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 creationHashSize;
    
    /// <summary> creationHash </summary>
    public: ByteVec creationHash;

public:
    TPMS_CREATION_INFO() {}
    TPMS_CREATION_INFO(const ByteVec& _objectName, const ByteVec& _creationHash)
      : objectName(_objectName), creationHash(_creationHash)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_CREATION; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_CREATION_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CREATION_INFO

/// <summary>
/// This structure contains the Name and contents of the selected NV Index that is
/// certified by TPM2_NV_Certify().
/// </summary>
class _DLLEXP_ TPMS_NV_CERTIFY_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 indexNameSize;
    
    /// <summary> Name of the NV Index </summary>
    public: ByteVec indexName;
    
    /// <summary> the offset parameter of TPM2_NV_Certify() </summary>
    public: UINT16 offset;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 nvContentsSize;
    
    /// <summary> contents of the NV Index </summary>
    public: ByteVec nvContents;

public:
    TPMS_NV_CERTIFY_INFO() {}
    TPMS_NV_CERTIFY_INFO(const ByteVec& _indexName, UINT16 _offset, const ByteVec& _nvContents)
      : indexName(_indexName), offset(_offset), nvContents(_nvContents)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_NV; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_NV_CERTIFY_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NV_CERTIFY_INFO

/// <summary>
/// This structure contains the Name and hash of the contents of the selected NV Index that is
/// certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
/// </summary>
class _DLLEXP_ TPMS_NV_DIGEST_CERTIFY_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 indexNameSize;
    
    /// <summary> Name of the NV Index </summary>
    public: ByteVec indexName;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nvDigestSize;
    
    /// <summary> hash of the contents of the index </summary>
    public: ByteVec nvDigest;

public:
    TPMS_NV_DIGEST_CERTIFY_INFO() {}
    TPMS_NV_DIGEST_CERTIFY_INFO(const ByteVec& _indexName, const ByteVec& _nvDigest)
      : indexName(_indexName), nvDigest(_nvDigest)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_NV_DIGEST; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_NV_DIGEST_CERTIFY_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NV_DIGEST_CERTIFY_INFO

/// <summary>
/// This structure is used on each TPM-generated signed structure. The
/// signature is over this structure.
/// </summary>
class _DLLEXP_ TPMS_ATTEST : public TpmStructure
{
    /// <summary> the indication that this structure was created by a TPM (always TPM_GENERATED_VALUE) </summary>
    public: TPM_GENERATED magic;
    public: TPM_ST get_type() const { return attested->GetUnionSelector(); }
    
    /// <summary> type of the attestation structure </summary>
    protected: mutable TPM_ST type;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 qualifiedSignerSize;
    
    /// <summary> Qualified Name of the signing key </summary>
    public: ByteVec qualifiedSigner;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 extraDataSize;
    
    /// <summary>
    /// external information supplied by caller
    /// NOTE A TPM2B_DATA structure provides room for a digest and a method indicator to indicate
    /// the components of the digest. The definition of this method indicator is outside the
    /// scope of this specification.
    /// </summary>
    public: ByteVec extraData;
    
    /// <summary> Clock, resetCount, restartCount, and Safe </summary>
    public: TPMS_CLOCK_INFO clockInfo;
    
    /// <summary> TPM-vendor-specific value identifying the version number of the firmware </summary>
    public: UINT64 firmwareVersion;
    
    /// <summary>
    /// the type-specific attestation information
    /// (One of [TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO, TPMS_COMMAND_AUDIT_INFO,
    /// TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO, TPMS_NV_CERTIFY_INFO,
    /// TPMS_NV_DIGEST_CERTIFY_INFO])
    /// </summary>
    public: shared_ptr<TPMU_ATTEST> attested;

public:
    TPMS_ATTEST() {}
    TPMS_ATTEST(TPM_GENERATED _magic, const ByteVec& _qualifiedSigner, const ByteVec& _extraData, const TPMS_CLOCK_INFO& _clockInfo, UINT64 _firmwareVersion, const TPMU_ATTEST& _attested)
      : magic(_magic), qualifiedSigner(_qualifiedSigner), extraData(_extraData), clockInfo(_clockInfo), firmwareVersion(_firmwareVersion), attested(dynamic_cast<TPMU_ATTEST*>(_attested.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ATTEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ATTEST

/// <summary>
/// This sized buffer to contain the signed structure. The attestationData is the signed
/// portion of the structure. The size parameter is not signed.
/// </summary>
class _DLLEXP_ TPM2B_ATTEST : public TpmStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the signed structure </summary>
    public: TPMS_ATTEST attestationData;

public:
    TPM2B_ATTEST() {}
    TPM2B_ATTEST(const TPMS_ATTEST& _attestationData)
      : attestationData(_attestationData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_ATTEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_ATTEST

/// <summary> This is the format used for each of the authorizations in the session area of a command. </summary>
class _DLLEXP_ TPMS_AUTH_COMMAND : public TpmStructure
{
    /// <summary> the session handle </summary>
    public: TPM_HANDLE sessionHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceSize;
    
    /// <summary> the session nonce, may be the Empty Buffer </summary>
    public: ByteVec nonce;
    
    /// <summary> the session attributes </summary>
    public: TPMA_SESSION sessionAttributes;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 hmacSize;
    
    /// <summary> either an HMAC, a password, or an EmptyAuth </summary>
    public: ByteVec hmac;

public:
    TPMS_AUTH_COMMAND() {}
    TPMS_AUTH_COMMAND(const TPM_HANDLE& _sessionHandle, const ByteVec& _nonce, TPMA_SESSION _sessionAttributes, const ByteVec& _hmac)
      : sessionHandle(_sessionHandle), nonce(_nonce), sessionAttributes(_sessionAttributes), hmac(_hmac)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_AUTH_COMMAND"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_AUTH_COMMAND

/// <summary>
/// This is the format for each of the authorizations in the session area of the response. If
/// the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same
/// number of authorizations as the command and the authorizations are in the same order.
/// </summary>
class _DLLEXP_ TPMS_AUTH_RESPONSE : public TpmStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceSize;
    
    /// <summary> the session nonce, may be the Empty Buffer </summary>
    public: ByteVec nonce;
    
    /// <summary> the session attributes </summary>
    public: TPMA_SESSION sessionAttributes;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 hmacSize;
    
    /// <summary> either an HMAC or an EmptyAuth </summary>
    public: ByteVec hmac;

public:
    TPMS_AUTH_RESPONSE() {}
    TPMS_AUTH_RESPONSE(const ByteVec& _nonce, TPMA_SESSION _sessionAttributes, const ByteVec& _hmac)
      : nonce(_nonce), sessionAttributes(_sessionAttributes), hmac(_hmac)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_AUTH_RESPONSE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_AUTH_RESPONSE

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TPMU_SYM_DETAILS
/// </summary>
class _DLLEXP_ TPMS_TDES_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
    TPMS_TDES_SYM_DETAILS() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::TDES; }
    
    virtual const char* TypeName () const { return "TPMS_TDES_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_TDES_SYM_DETAILS

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TPMU_SYM_DETAILS
/// </summary>
class _DLLEXP_ TPMS_AES_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
    TPMS_AES_SYM_DETAILS() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::AES; }
    
    virtual const char* TypeName () const { return "TPMS_AES_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_AES_SYM_DETAILS

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TPMU_SYM_DETAILS
/// </summary>
class _DLLEXP_ TPMS_SM4_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
    TPMS_SM4_SYM_DETAILS() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SM4; }
    
    virtual const char* TypeName () const { return "TPMS_SM4_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SM4_SYM_DETAILS

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TPMU_SYM_DETAILS
/// </summary>
class _DLLEXP_ TPMS_CAMELLIA_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
    TPMS_CAMELLIA_SYM_DETAILS() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::CAMELLIA; }
    
    virtual const char* TypeName () const { return "TPMS_CAMELLIA_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CAMELLIA_SYM_DETAILS

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TPMU_SYM_DETAILS
/// </summary>
class _DLLEXP_ TPMS_ANY_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
    TPMS_ANY_SYM_DETAILS() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY; }
    
    virtual const char* TypeName () const { return "TPMS_ANY_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ANY_SYM_DETAILS

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TPMU_SYM_DETAILS
/// </summary>
class _DLLEXP_ TPMS_XOR_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
    TPMS_XOR_SYM_DETAILS() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::XOR; }
    
    virtual const char* TypeName () const { return "TPMS_XOR_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_XOR_SYM_DETAILS

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SYM_DETAILS
/// </summary>
class _DLLEXP_ TPMS_NULL_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
    TPMS_NULL_SYM_DETAILS() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NULL_SYM_DETAILS

/// <summary>
/// The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter
/// encryption in those cases when different symmetric algorithms may be selected.
/// </summary>
class _DLLEXP_ _TPMT_SYM_DEF : public TpmStructure
{
    /// <summary> symmetric algorithm </summary>
    public: TPM_ALG_ID algorithm;
    
    /// <summary> key size in bits </summary>
    public: UINT16 keyBits;
    
    /// <summary> encryption mode </summary>
    public: TPM_ALG_ID mode;

public:
    _TPMT_SYM_DEF()
    {
        algorithm = TPM_ALG_ID::_NULL;
        mode = TPM_ALG_ID::_NULL;
    }

    _TPMT_SYM_DEF(TPM_ALG_ID _algorithm, UINT16 _keyBits, TPM_ALG_ID _mode)
      : algorithm(_algorithm), keyBits(_keyBits), mode(_mode)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPMT_SYM_DEF"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPMT_SYM_DEF

#include "Extensions/TPMT_SYM_DEF.h"

/// <summary>
/// This structure is used when different symmetric block cipher (not XOR) algorithms may be
/// selected. If the Object can be an ordinary parent (not a derivation parent), this must be
/// the first field in the Object's parameter (see 12.2.3.7) field.
/// </summary>
class _DLLEXP_ _TPMT_SYM_DEF_OBJECT : public TpmStructure
{
    /// <summary> symmetric algorithm </summary>
    public: TPM_ALG_ID algorithm;
    
    /// <summary> key size in bits </summary>
    public: UINT16 keyBits;
    
    /// <summary> encryption mode </summary>
    public: TPM_ALG_ID mode;

public:
    _TPMT_SYM_DEF_OBJECT()
    {
        algorithm = TPM_ALG_ID::_NULL;
        mode = TPM_ALG_ID::_NULL;
    }

    _TPMT_SYM_DEF_OBJECT(TPM_ALG_ID _algorithm, UINT16 _keyBits, TPM_ALG_ID _mode)
      : algorithm(_algorithm), keyBits(_keyBits), mode(_mode)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPMT_SYM_DEF_OBJECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPMT_SYM_DEF_OBJECT

#include "Extensions/TPMT_SYM_DEF_OBJECT.h"

/// <summary>
/// This structure is used to hold a symmetric key in the sensitive area
/// of an asymmetric object.
/// </summary>
class _DLLEXP_ TPM2B_SYM_KEY : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
    /// <summary> size, in octets, of the buffer containing the key; may be zero </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the key </summary>
    public: ByteVec buffer;

public:
    TPM2B_SYM_KEY() {}
    TPM2B_SYM_KEY(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SYMCIPHER; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_SYM_KEY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_SYM_KEY

/// <summary> This structure contains the parameters for a symmetric block cipher object. </summary>
class _DLLEXP_ TPMS_SYMCIPHER_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
    /// <summary> a symmetric block cipher </summary>
    public: TPMT_SYM_DEF_OBJECT sym;

public:
    TPMS_SYMCIPHER_PARMS() {}
    TPMS_SYMCIPHER_PARMS(const TPMT_SYM_DEF_OBJECT& _sym)
      : sym(_sym)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SYMCIPHER; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SYMCIPHER_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SYMCIPHER_PARMS

/// <summary>
/// This buffer holds a label or context value. For interoperability and backwards
/// compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the
/// largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
/// </summary>
class _DLLEXP_ TPM2B_LABEL : public TpmStructure
{
    protected: mutable UINT16 size;
    
    /// <summary> symmetric data for a created object or the label and context for a derived object </summary>
    public: ByteVec buffer;

public:
    TPM2B_LABEL() {}
    TPM2B_LABEL(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_LABEL"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_LABEL

/// <summary>
/// This structure contains the label and context fields for a derived object. These values
/// are used in the derivation KDF. The values in the unique field of inPublic area template
/// take precedence over the values in the inSensitive parameter.
/// </summary>
class _DLLEXP_ TPMS_DERIVE : public virtual TpmStructure, public TPMU_SENSITIVE_CREATE, public TPMU_PUBLIC_ID
{
    protected: mutable UINT16 labelSize;
    
    public: ByteVec label;
    
    protected: mutable UINT16 contextSize;
    
    public: ByteVec context;

public:
    TPMS_DERIVE() {}
    TPMS_DERIVE(const ByteVec& _label, const ByteVec& _context)
      : label(_label), context(_context)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY2; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_DERIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_DERIVE

/// <summary> Table 147 Definition of TPM2B_DERIVE Structure </summary>
class _DLLEXP_ TPM2B_DERIVE : public TpmStructure
{
    protected: mutable UINT16 size;
    
    /// <summary> symmetric data for a created object or the label and context for a derived object </summary>
    public: TPMS_DERIVE buffer;

public:
    TPM2B_DERIVE() {}
    TPM2B_DERIVE(const TPMS_DERIVE& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_DERIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_DERIVE

/// <summary> This buffer wraps the TPMU_SENSITIVE_CREATE structure. </summary>
class _DLLEXP_ TPM2B_SENSITIVE_DATA : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
    protected: mutable UINT16 size;
    
    /// <summary> symmetric data for a created object or the label and context for a derived object </summary>
    public: ByteVec buffer;

public:
    TPM2B_SENSITIVE_DATA() {}
    TPM2B_SENSITIVE_DATA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_SENSITIVE_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_SENSITIVE_DATA

/// <summary>
/// This structure defines the values to be placed in the sensitive area of a created object.
/// This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
/// </summary>
class _DLLEXP_ TPMS_SENSITIVE_CREATE : public TpmStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 userAuthSize;
    
    /// <summary> the USER auth secret value </summary>
    public: ByteVec userAuth;
    
    protected: mutable UINT16 dataSize;
    
    /// <summary> data to be sealed, a key, or derivation values </summary>
    public: ByteVec data;

public:
    TPMS_SENSITIVE_CREATE() {}
    TPMS_SENSITIVE_CREATE(const ByteVec& _userAuth, const ByteVec& _data)
      : userAuth(_userAuth), data(_data)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SENSITIVE_CREATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SENSITIVE_CREATE

/// <summary>
/// This structure contains the sensitive creation data in a sized buffer. This structure is
/// defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be
/// passed as a single parameter for parameter encryption purposes.
/// </summary>
class _DLLEXP_ TPM2B_SENSITIVE_CREATE : public TpmStructure
{
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE The userAuth and data parameters in this buffer may both be zero length but the
    /// minimum size of this parameter will be the sum of the size fields of the two parameters
    /// of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 size;
    
    /// <summary> data to be sealed or a symmetric key value. </summary>
    public: TPMS_SENSITIVE_CREATE sensitive;

public:
    TPM2B_SENSITIVE_CREATE() {}
    TPM2B_SENSITIVE_CREATE(const TPMS_SENSITIVE_CREATE& _sensitive)
      : sensitive(_sensitive)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_SENSITIVE_CREATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_SENSITIVE_CREATE

/// <summary>
/// This structure is the scheme data for schemes that only require a hash to
/// complete their definition.
/// </summary>
class _DLLEXP_ TPMS_SCHEME_HASH : public virtual TpmStructure, public TPMU_SCHEME_KEYEDHASH, public TPMU_SIG_SCHEME, public TPMU_KDF_SCHEME, public TPMU_ASYM_SCHEME, public TPMU_SIGNATURE
{
    /// <summary> the hash algorithm used to digest the message </summary>
    public: TPM_ALG_ID hashAlg;

public:
    TPMS_SCHEME_HASH() { hashAlg = TPM_ALG_ID::_NULL; }
    TPMS_SCHEME_HASH(TPM_ALG_ID _hashAlg)
      : hashAlg(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::HMAC; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_HASH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SCHEME_HASH

/// <summary> This definition is for split signing schemes that require a commit count. </summary>
class _DLLEXP_ TPMS_SCHEME_ECDAA : public virtual TpmStructure, public TPMU_SIG_SCHEME, public TPMU_ASYM_SCHEME
{
    /// <summary> the hash algorithm used to digest the message </summary>
    public: TPM_ALG_ID hashAlg;
    
    /// <summary> the counter value that is used between TPM2_Commit() and the sign operation </summary>
    public: UINT16 count;

public:
    TPMS_SCHEME_ECDAA() { hashAlg = TPM_ALG_ID::_NULL; }
    TPMS_SCHEME_ECDAA(TPM_ALG_ID _hashAlg, UINT16 _count)
      : hashAlg(_hashAlg), count(_count)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDAA; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_ECDAA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SCHEME_ECDAA

/// <summary> Table 155 Definition of Types for HMAC_SIG_SCHEME </summary>
class _DLLEXP_ TPMS_SCHEME_HMAC : public TPMS_SCHEME_HASH
{
public:
    TPMS_SCHEME_HMAC() {}
    TPMS_SCHEME_HMAC(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::HMAC; }
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_HMAC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SCHEME_HMAC

/// <summary> This structure is for the XOR encryption scheme. </summary>
class _DLLEXP_ TPMS_SCHEME_XOR : public virtual TpmStructure, public TPMU_SCHEME_KEYEDHASH
{
    /// <summary> the hash algorithm used to digest the message </summary>
    public: TPM_ALG_ID hashAlg;
    
    /// <summary> the key derivation function </summary>
    public: TPM_ALG_ID kdf;

public:
    TPMS_SCHEME_XOR()
    {
        hashAlg = TPM_ALG_ID::_NULL;
        kdf = TPM_ALG_ID::_NULL;
    }

    TPMS_SCHEME_XOR(TPM_ALG_ID _hashAlg, TPM_ALG_ID _kdf)
      : hashAlg(_hashAlg), kdf(_kdf)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::XOR; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_XOR"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SCHEME_XOR

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SCHEME_KEYEDHASH
/// </summary>
class _DLLEXP_ TPMS_NULL_SCHEME_KEYEDHASH : public TPMS_NULL_UNION
{
public:
    TPMS_NULL_SCHEME_KEYEDHASH() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SCHEME_KEYEDHASH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NULL_SCHEME_KEYEDHASH

/// <summary> This structure is used for a hash signing object. </summary>
class _DLLEXP_ TPMT_KEYEDHASH_SCHEME : public TpmStructure
{
    public: TPM_ALG_ID get_scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selects the scheme </summary>
    protected: mutable TPM_ALG_ID scheme;
    
    /// <summary>
    /// the scheme parameters
    /// (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
    /// </summary>
    public: shared_ptr<TPMU_SCHEME_KEYEDHASH> details;

public:
    TPMT_KEYEDHASH_SCHEME() {}
    TPMT_KEYEDHASH_SCHEME(const TPMU_SCHEME_KEYEDHASH& _details)
      : details(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_KEYEDHASH_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_KEYEDHASH_SCHEME

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_RSASSA : public TPMS_SCHEME_HASH
{
public:
    TPMS_SIG_SCHEME_RSASSA() {}
    TPMS_SIG_SCHEME_RSASSA(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSASSA; }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_RSASSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIG_SCHEME_RSASSA

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_RSAPSS : public TPMS_SCHEME_HASH
{
public:
    TPMS_SIG_SCHEME_RSAPSS() {}
    TPMS_SIG_SCHEME_RSAPSS(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAPSS; }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_RSAPSS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIG_SCHEME_RSAPSS

/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition
/// and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they
/// are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_ECDSA : public TPMS_SCHEME_HASH
{
public:
    TPMS_SIG_SCHEME_ECDSA() {}
    TPMS_SIG_SCHEME_ECDSA(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDSA; }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_ECDSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIG_SCHEME_ECDSA

/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition
/// and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they
/// are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_SM2 : public TPMS_SCHEME_HASH
{
public:
    TPMS_SIG_SCHEME_SM2() {}
    TPMS_SIG_SCHEME_SM2(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SM2; }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_SM2"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIG_SCHEME_SM2

/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition
/// and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they
/// are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_ECSCHNORR : public TPMS_SCHEME_HASH
{
public:
    TPMS_SIG_SCHEME_ECSCHNORR() {}
    TPMS_SIG_SCHEME_ECSCHNORR(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECSCHNORR; }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_ECSCHNORR"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIG_SCHEME_ECSCHNORR

/// <summary>
/// Most of the ECC signature schemes only require a hash algorithm to complete the definition
/// and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they
/// are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
class _DLLEXP_ TPMS_SIG_SCHEME_ECDAA : public TPMS_SCHEME_ECDAA
{
public:
    TPMS_SIG_SCHEME_ECDAA() {}
    TPMS_SIG_SCHEME_ECDAA(TPM_ALG_ID _hashAlg, UINT16 _count)
      : TPMS_SCHEME_ECDAA(_hashAlg, _count)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDAA; }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_ECDAA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIG_SCHEME_ECDAA

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIG_SCHEME
/// </summary>
class _DLLEXP_ TPMS_NULL_SIG_SCHEME : public TPMS_NULL_UNION
{
public:
    TPMS_NULL_SIG_SCHEME() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SIG_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NULL_SIG_SCHEME

/// <summary> Table 162 Definition of TPMT_SIG_SCHEME Structure </summary>
class _DLLEXP_ TPMT_SIG_SCHEME : public TpmStructure
{
    public: TPM_ALG_ID get_scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID scheme;
    
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> details;

public:
    TPMT_SIG_SCHEME() {}
    TPMT_SIG_SCHEME(const TPMU_SIG_SCHEME& _details)
      : details(dynamic_cast<TPMU_SIG_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_SIG_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_SIG_SCHEME

/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as
/// a controlling parameter.
/// </summary>
class _DLLEXP_ TPMS_ENC_SCHEME_OAEP : public TPMS_SCHEME_HASH
{
public:
    TPMS_ENC_SCHEME_OAEP() {}
    TPMS_ENC_SCHEME_OAEP(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::OAEP; }
    
    virtual const char* TypeName () const { return "TPMS_ENC_SCHEME_OAEP"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ENC_SCHEME_OAEP

/// <summary>
/// These are the RSA encryption schemes that only need a hash algorithm as
/// a controlling parameter.
/// </summary>
class _DLLEXP_ TPMS_ENC_SCHEME_RSAES : public TPMS_EMPTY
{
public:
    TPMS_ENC_SCHEME_RSAES() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAES; }
    
    virtual const char* TypeName () const { return "TPMS_ENC_SCHEME_RSAES"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ENC_SCHEME_RSAES

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
class _DLLEXP_ TPMS_KEY_SCHEME_ECDH : public TPMS_SCHEME_HASH
{
public:
    TPMS_KEY_SCHEME_ECDH() {}
    TPMS_KEY_SCHEME_ECDH(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDH; }
    
    virtual const char* TypeName () const { return "TPMS_KEY_SCHEME_ECDH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_KEY_SCHEME_ECDH

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
class _DLLEXP_ TPMS_KEY_SCHEME_ECMQV : public TPMS_SCHEME_HASH
{
public:
    TPMS_KEY_SCHEME_ECMQV() {}
    TPMS_KEY_SCHEME_ECMQV(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECMQV; }
    
    virtual const char* TypeName () const { return "TPMS_KEY_SCHEME_ECMQV"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_KEY_SCHEME_ECMQV

/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_KDF_SCHEME_MGF1 : public TPMS_SCHEME_HASH
{
public:
    TPMS_KDF_SCHEME_MGF1() {}
    TPMS_KDF_SCHEME_MGF1(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::MGF1; }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_MGF1"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_KDF_SCHEME_MGF1

/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_KDF_SCHEME_KDF1_SP800_56A : public TPMS_SCHEME_HASH
{
public:
    TPMS_KDF_SCHEME_KDF1_SP800_56A() {}
    TPMS_KDF_SCHEME_KDF1_SP800_56A(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KDF1_SP800_56A; }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_KDF1_SP800_56A"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_KDF_SCHEME_KDF1_SP800_56A

/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_KDF_SCHEME_KDF2 : public TPMS_SCHEME_HASH
{
public:
    TPMS_KDF_SCHEME_KDF2() {}
    TPMS_KDF_SCHEME_KDF2(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KDF2; }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_KDF2"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_KDF_SCHEME_KDF2

/// <summary>
/// These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
class _DLLEXP_ TPMS_KDF_SCHEME_KDF1_SP800_108 : public TPMS_SCHEME_HASH
{
public:
    TPMS_KDF_SCHEME_KDF1_SP800_108() {}
    TPMS_KDF_SCHEME_KDF1_SP800_108(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KDF1_SP800_108; }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_KDF1_SP800_108"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_KDF_SCHEME_KDF1_SP800_108

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_KDF_SCHEME
/// </summary>
class _DLLEXP_ TPMS_NULL_KDF_SCHEME : public TPMS_NULL_UNION
{
public:
    TPMS_NULL_KDF_SCHEME() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    virtual const char* TypeName () const { return "TPMS_NULL_KDF_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NULL_KDF_SCHEME

/// <summary> Table 167 Definition of TPMT_KDF_SCHEME Structure </summary>
class _DLLEXP_ TPMT_KDF_SCHEME : public TpmStructure
{
    public: TPM_ALG_ID get_scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID scheme;
    
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_KDF_SCHEME> details;

public:
    TPMT_KDF_SCHEME() {}
    TPMT_KDF_SCHEME(const TPMU_KDF_SCHEME& _details)
      : details(dynamic_cast<TPMU_KDF_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_KDF_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_KDF_SCHEME

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_ASYM_SCHEME
/// </summary>
class _DLLEXP_ TPMS_NULL_ASYM_SCHEME : public TPMS_NULL_UNION
{
public:
    TPMS_NULL_ASYM_SCHEME() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    virtual const char* TypeName () const { return "TPMS_NULL_ASYM_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NULL_ASYM_SCHEME

/// <summary>
/// This structure is defined to allow overlay of all of the schemes for any asymmetric
/// object. This structure is not sent on the interface. It is defined so that common
/// functions may operate on any similar scheme structure.
/// </summary>
class _DLLEXP_ TPMT_ASYM_SCHEME : public TpmStructure
{
    public: TPM_ALG_ID get_scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID scheme;
    
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_ASYM_SCHEME() {}
    TPMT_ASYM_SCHEME(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_ASYM_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_ASYM_SCHEME

/// <summary> Table 172 Definition of {RSA} TPMT_RSA_SCHEME Structure </summary>
class _DLLEXP_ TPMT_RSA_SCHEME : public TpmStructure
{
    public: TPM_ALG_ID get_scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID scheme;
    
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_RSA_SCHEME() {}
    TPMT_RSA_SCHEME(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_RSA_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_RSA_SCHEME

/// <summary> Table 174 Definition of {RSA} TPMT_RSA_DECRYPT Structure </summary>
class _DLLEXP_ TPMT_RSA_DECRYPT : public TpmStructure
{
    public: TPM_ALG_ID get_scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID scheme;
    
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_RSA_DECRYPT() {}
    TPMT_RSA_DECRYPT(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_RSA_DECRYPT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_RSA_DECRYPT

/// <summary> This sized buffer holds the largest RSA public key supported by the TPM. </summary>
class _DLLEXP_ TPM2B_PUBLIC_KEY_RSA : public virtual TpmStructure, public TPMU_PUBLIC_ID
{
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 size;
    
    /// <summary> Value </summary>
    public: ByteVec buffer;

public:
    TPM2B_PUBLIC_KEY_RSA() {}
    TPM2B_PUBLIC_KEY_RSA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_PUBLIC_KEY_RSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_PUBLIC_KEY_RSA

/// <summary> This sized buffer holds the largest RSA prime number supported by the TPM. </summary>
class _DLLEXP_ TPM2B_PRIVATE_KEY_RSA : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
    protected: mutable UINT16 size;
    
    public: ByteVec buffer;

public:
    TPM2B_PRIVATE_KEY_RSA() {}
    TPM2B_PRIVATE_KEY_RSA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_PRIVATE_KEY_RSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_PRIVATE_KEY_RSA

/// <summary> This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM. </summary>
class _DLLEXP_ TPM2B_ECC_PARAMETER : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the parameter data </summary>
    public: ByteVec buffer;

public:
    TPM2B_ECC_PARAMETER() {}
    TPM2B_ECC_PARAMETER(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECC; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_ECC_PARAMETER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_ECC_PARAMETER

/// <summary> This structure holds two ECC coordinates that, together, make up an ECC point. </summary>
class _DLLEXP_ TPMS_ECC_POINT : public virtual TpmStructure, public TPMU_PUBLIC_ID
{
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 xSize;
    
    /// <summary> X coordinate </summary>
    public: ByteVec x;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 ySize;
    
    /// <summary> Y coordinate </summary>
    public: ByteVec y;

public:
    TPMS_ECC_POINT() {}
    TPMS_ECC_POINT(const ByteVec& _x, const ByteVec& _y)
      : x(_x), y(_y)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECC; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ECC_POINT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ECC_POINT

/// <summary>
/// This structure is defined to allow a point to be a single sized parameter so
/// that it may be encrypted.
/// </summary>
class _DLLEXP_ TPM2B_ECC_POINT : public TpmStructure
{
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 size;
    
    /// <summary> coordinates </summary>
    public: TPMS_ECC_POINT point;

public:
    TPM2B_ECC_POINT() {}
    TPM2B_ECC_POINT(const TPMS_ECC_POINT& _point)
      : point(_point)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_ECC_POINT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_ECC_POINT

/// <summary> Table 183 Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure </summary>
class _DLLEXP_ TPMT_ECC_SCHEME : public TpmStructure
{
    public: TPM_ALG_ID get_scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID scheme;
    
    /// <summary>
    /// scheme parameters
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_ECC_SCHEME() {}
    TPMT_ECC_SCHEME(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_ECC_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_ECC_SCHEME

/// <summary>
/// This structure is used to report on the curve parameters of an ECC curve. It is
/// returned by TPM2_ECC_Parameters().
/// </summary>
class _DLLEXP_ TPMS_ALGORITHM_DETAIL_ECC : public TpmStructure
{
    /// <summary> identifier for the curve </summary>
    public: TPM_ECC_CURVE curveID;
    
    /// <summary> Size in bits of the key </summary>
    public: UINT16 keySize;
    public: TPM_ALG_ID get_kdfScheme() const { return kdf ? kdf->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID kdfScheme;
    
    /// <summary>
    /// if not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations
    /// (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_KDF_SCHEME> kdf;
    public: TPM_ALG_ID get_signScheme() const { return sign ? sign->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID signScheme;
    
    /// <summary>
    /// If not TPM_ALG_NULL, this is the mandatory signature scheme that is required
    /// to be used with this curve.
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> sign;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 pSize;
    
    /// <summary> Fp (the modulus) </summary>
    public: ByteVec p;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 aSize;
    
    /// <summary> coefficient of the linear term in the curve equation </summary>
    public: ByteVec a;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 bSize;
    
    /// <summary> constant term for curve equation </summary>
    public: ByteVec b;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 gXSize;
    
    /// <summary> x coordinate of base point G </summary>
    public: ByteVec gX;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 gYSize;
    
    /// <summary> y coordinate of base point G </summary>
    public: ByteVec gY;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 nSize;
    
    /// <summary> order of G </summary>
    public: ByteVec n;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 hSize;
    
    /// <summary> cofactor (a size of zero indicates a cofactor of 1) </summary>
    public: ByteVec h;

public:
    TPMS_ALGORITHM_DETAIL_ECC() {}
    TPMS_ALGORITHM_DETAIL_ECC(TPM_ECC_CURVE _curveID, UINT16 _keySize, const TPMU_KDF_SCHEME& _kdf, const TPMU_ASYM_SCHEME& _sign, const ByteVec& _p, const ByteVec& _a, const ByteVec& _b, const ByteVec& _gX, const ByteVec& _gY, const ByteVec& _n, const ByteVec& _h)
      : curveID(_curveID), keySize(_keySize), kdf(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone())), sign(dynamic_cast<TPMU_ASYM_SCHEME*>(_sign.Clone())), p(_p), a(_a), b(_b), gX(_gX), gY(_gY), n(_n), h(_h)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ALGORITHM_DETAIL_ECC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ALGORITHM_DETAIL_ECC

/// <summary> Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_RSA : public virtual TpmStructure, public TPMU_SIGNATURE
{
    /// <summary>
    /// the hash algorithm used to digest the message
    /// TPM_ALG_NULL is not allowed.
    /// </summary>
    public: TPM_ALG_ID hash;
    
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 sigSize;
    
    /// <summary> The signature is the size of a public key. </summary>
    public: ByteVec sig;

public:
    TPMS_SIGNATURE_RSA() { hash = TPM_ALG_ID::_NULL; }
    TPMS_SIGNATURE_RSA(TPM_ALG_ID _hash, const ByteVec& _sig)
      : hash(_hash), sig(_sig)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSASSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_RSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_RSA

/// <summary> Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_RSASSA : public TPMS_SIGNATURE_RSA
{
public:
    TPMS_SIGNATURE_RSASSA() {}
    TPMS_SIGNATURE_RSASSA(TPM_ALG_ID _hash, const ByteVec& _sig)
      : TPMS_SIGNATURE_RSA(_hash, _sig)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSASSA; }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_RSASSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_RSASSA

/// <summary> Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_RSAPSS : public TPMS_SIGNATURE_RSA
{
public:
    TPMS_SIGNATURE_RSAPSS() {}
    TPMS_SIGNATURE_RSAPSS(TPM_ALG_ID _hash, const ByteVec& _sig)
      : TPMS_SIGNATURE_RSA(_hash, _sig)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAPSS; }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_RSAPSS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_RSAPSS

/// <summary> Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECC : public virtual TpmStructure, public TPMU_SIGNATURE
{
    /// <summary>
    /// the hash algorithm used in the signature process
    /// TPM_ALG_NULL is not allowed.
    /// </summary>
    public: TPM_ALG_ID hash;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 signatureRSize;
    
    public: ByteVec signatureR;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 signatureSSize;
    
    public: ByteVec signatureS;

public:
    TPMS_SIGNATURE_ECC() { hash = TPM_ALG_ID::_NULL; }
    TPMS_SIGNATURE_ECC(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : hash(_hash), signatureR(_signatureR), signatureS(_signatureS)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_ECC

/// <summary> Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECDSA : public TPMS_SIGNATURE_ECC
{
public:
    TPMS_SIGNATURE_ECDSA() {}
    TPMS_SIGNATURE_ECDSA(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDSA; }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECDSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_ECDSA

/// <summary> Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECDAA : public TPMS_SIGNATURE_ECC
{
public:
    TPMS_SIGNATURE_ECDAA() {}
    TPMS_SIGNATURE_ECDAA(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDAA; }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECDAA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_ECDAA

/// <summary> Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_SM2 : public TPMS_SIGNATURE_ECC
{
public:
    TPMS_SIGNATURE_SM2() {}
    TPMS_SIGNATURE_SM2(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SM2; }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_SM2"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_SM2

/// <summary> Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
class _DLLEXP_ TPMS_SIGNATURE_ECSCHNORR : public TPMS_SIGNATURE_ECC
{
public:
    TPMS_SIGNATURE_ECSCHNORR() {}
    TPMS_SIGNATURE_ECSCHNORR(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECSCHNORR; }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECSCHNORR"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_SIGNATURE_ECSCHNORR

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIGNATURE
/// </summary>
class _DLLEXP_ TPMS_NULL_SIGNATURE : public TPMS_NULL_UNION
{
public:
    TPMS_NULL_SIGNATURE() {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SIGNATURE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NULL_SIGNATURE

/// <summary>
/// Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric
/// signature is indicated. The sigAlg parameter indicates the algorithm used for the
/// signature. This structure is output from commands such as the attestation commands and
/// TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(),
/// TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
/// </summary>
class _DLLEXP_ TPMT_SIGNATURE : public TpmStructure
{
    public: TPM_ALG_ID get_sigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID sigAlg;
    
    /// <summary>
    /// This shall be the actual signature information.
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    TPMT_SIGNATURE() {}
    TPMT_SIGNATURE(const TPMU_SIGNATURE& _signature)
      : signature(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_SIGNATURE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_SIGNATURE

/// <summary> Table 192 Definition of TPM2B_ENCRYPTED_SECRET Structure </summary>
class _DLLEXP_ TPM2B_ENCRYPTED_SECRET : public TpmStructure
{
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 size;
    
    /// <summary> secret </summary>
    public: ByteVec secret;

public:
    TPM2B_ENCRYPTED_SECRET() {}
    TPM2B_ENCRYPTED_SECRET(const ByteVec& _secret)
      : secret(_secret)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_ENCRYPTED_SECRET"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_ENCRYPTED_SECRET

/// <summary>
/// This structure describes the parameters that would appear in the public
/// area of a KEYEDHASH object.
/// </summary>
class _DLLEXP_ TPMS_KEYEDHASH_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
    public: TPM_ALG_ID get_schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selects the scheme </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    
    /// <summary>
    /// Indicates the signing method used for a keyedHash signing object. This field also
    /// determines the size of the data field for a data object created with
    /// TPM2_Create() or TPM2_CreatePrimary().
    /// (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
    /// </summary>
    public: shared_ptr<TPMU_SCHEME_KEYEDHASH> scheme;

public:
    TPMS_KEYEDHASH_PARMS() {}
    TPMS_KEYEDHASH_PARMS(const TPMU_SCHEME_KEYEDHASH& _scheme)
      : scheme(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_scheme.Clone()))
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_KEYEDHASH_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_KEYEDHASH_PARMS

/// <summary>
/// This structure contains the common public area parameters for an asymmetric key. The first
/// two parameters of the parameter definition structures of an asymmetric key shall have
/// the same two first components.
/// </summary>
class _DLLEXP_ TPMS_ASYM_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
    /// <summary>
    /// the companion symmetric algorithm for a restricted decryption key and shall be set to a
    /// supported symmetric algorithm
    /// This field is optional for keys that are not decryption keys and shall be set
    /// to TPM_ALG_NULL if not used.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetric;
    public: TPM_ALG_ID get_schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    
    /// <summary>
    /// for a key with the sign attribute SET, a valid signing scheme for the key type
    /// for a key with the decrypt attribute SET, a valid key exchange protocol
    /// for a key with sign and decrypt attributes, shall be TPM_ALG_NULL
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> scheme;

public:
    TPMS_ASYM_PARMS() {}
    TPMS_ASYM_PARMS(const TPMT_SYM_DEF_OBJECT& _symmetric, const TPMU_ASYM_SCHEME& _scheme)
      : symmetric(_symmetric), scheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()))
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ASYM_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ASYM_PARMS

/// <summary>
/// A TPM compatible with this specification and supporting RSA shall support two primes and
/// an exponent of zero. An exponent of zero indicates that the exponent is the default of 216
/// + 1. Support for other values is optional. Use of other exponents in duplicated keys is
/// not recommended because the resulting keys would not be interoperable with other TPMs.
/// </summary>
class _DLLEXP_ TPMS_RSA_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
    /// <summary>
    /// for a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size, and mode.
    /// if the key is not a restricted decryption key, this field shall be set to
    /// TPM_ALG_NULL.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetric;
    public: TPM_ALG_ID get_schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    
    /// <summary>
    /// scheme.scheme shall be:
    /// for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL
    /// for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA
    /// for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL unless
    /// the object also has the sign attribute
    /// for a restricted decryption key, TPM_ALG_NULL
    /// NOTE When both sign and decrypt are SET, restricted shall be CLEAR and
    /// scheme shall be TPM_ALG_NULL.
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> scheme;
    
    /// <summary> number of bits in the public modulus </summary>
    public: UINT16 keyBits;
    
    /// <summary>
    /// the public exponent
    /// A prime number greater than 2.
    /// </summary>
    public: UINT32 exponent;

public:
    TPMS_RSA_PARMS() {}
    TPMS_RSA_PARMS(const TPMT_SYM_DEF_OBJECT& _symmetric, const TPMU_ASYM_SCHEME& _scheme, UINT16 _keyBits, UINT32 _exponent)
      : symmetric(_symmetric), scheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone())), keyBits(_keyBits), exponent(_exponent)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_RSA_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_RSA_PARMS

/// <summary> This structure contains the parameters for prime modulus ECC. </summary>
class _DLLEXP_ TPMS_ECC_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
    /// <summary>
    /// for a restricted decryption key, shall be set to a supported symmetric algorithm, key
    /// size. and mode.
    /// if the key is not a restricted decryption key, this field shall be set to
    /// TPM_ALG_NULL.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetric;
    public: TPM_ALG_ID get_schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID schemeScheme;
    
    /// <summary>
    /// If the sign attribute of the key is SET, then this shall be a valid signing scheme.
    /// NOTE If the sign parameter in curveID indicates a mandatory scheme, then this field shall
    /// have the same value.
    /// If the decrypt attribute of the key is SET, then this shall be a valid key exchange scheme
    /// or TPM_ALG_NULL.
    /// If the key is a Storage Key, then this field shall be TPM_ALG_NULL.
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> scheme;
    
    /// <summary> ECC curve ID </summary>
    public: TPM_ECC_CURVE curveID;
    public: TPM_ALG_ID get_kdfScheme() const { return kdf ? kdf->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID kdfScheme;
    
    /// <summary>
    /// an optional key derivation scheme for generating a symmetric key from a Z value
    /// If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required to
    /// be NULL.
    /// NOTE There are currently no commands where this parameter has effect and, in the reference
    /// code, this field needs to be set to TPM_ALG_NULL.
    /// (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_KDF_SCHEME> kdf;

public:
    TPMS_ECC_PARMS() {}
    TPMS_ECC_PARMS(const TPMT_SYM_DEF_OBJECT& _symmetric, const TPMU_ASYM_SCHEME& _scheme, TPM_ECC_CURVE _curveID, const TPMU_KDF_SCHEME& _kdf)
      : symmetric(_symmetric), scheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone())), curveID(_curveID), kdf(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone()))
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECC; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ECC_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ECC_PARMS

/// <summary>
/// This structure is used in TPM2_TestParms() to validate that a set of algorithm
/// parameters is supported by the TPM.
/// </summary>
class _DLLEXP_ TPMT_PUBLIC_PARMS : public TpmStructure
{
    public: TPM_ALG_ID get_type() const { return parameters->GetUnionSelector(); }
    
    /// <summary> the algorithm to be tested </summary>
    protected: mutable TPM_ALG_ID type;
    
    /// <summary>
    /// the algorithm details
    /// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS,
    /// TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
    /// </summary>
    public: shared_ptr<TPMU_PUBLIC_PARMS> parameters;

public:
    TPMT_PUBLIC_PARMS() {}
    TPMT_PUBLIC_PARMS(const TPMU_PUBLIC_PARMS& _parameters)
      : parameters(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMT_PUBLIC_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMT_PUBLIC_PARMS

/// <summary>
/// Table 201 defines the public area structure. The Name of the object is nameAlg
/// concatenated with the digest of this structure using nameAlg.
/// </summary>
class _DLLEXP_ _TPMT_PUBLIC : public TpmStructure
{
    public: TPM_ALG_ID get_type() const { return parameters->GetUnionSelector(); }
    
    /// <summary> algorithm associated with this object </summary>
    protected: mutable TPM_ALG_ID type;
    
    /// <summary>
    /// algorithm used for computing the Name of the object
    /// NOTE The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate that
    /// the nameAlg may be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID nameAlg;
    
    /// <summary> attributes that, along with type, determine the manipulations of this object </summary>
    public: TPMA_OBJECT objectAttributes;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authPolicySize;
    
    /// <summary>
    /// optional policy for using this key
    /// The policy is computed using the nameAlg of the object.
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    /// </summary>
    public: ByteVec authPolicy;
    
    /// <summary>
    /// the algorithm or structure details
    /// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS,
    /// TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
    /// </summary>
    public: shared_ptr<TPMU_PUBLIC_PARMS> parameters;
    
    /// <summary>
    /// the unique identifier of the structure
    /// For an asymmetric key, this would be the public key.
    /// (One of [TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
    /// TPMS_ECC_POINT, TPMS_DERIVE])
    /// </summary>
    public: shared_ptr<TPMU_PUBLIC_ID> unique;

public:
    _TPMT_PUBLIC() { nameAlg = TPM_ALG_ID::_NULL; }
    _TPMT_PUBLIC(TPM_ALG_ID _nameAlg, TPMA_OBJECT _objectAttributes, const ByteVec& _authPolicy, const TPMU_PUBLIC_PARMS& _parameters, const TPMU_PUBLIC_ID& _unique)
      : nameAlg(_nameAlg), objectAttributes(_objectAttributes), authPolicy(_authPolicy), parameters(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone())), unique(dynamic_cast<TPMU_PUBLIC_ID*>(_unique.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPMT_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPMT_PUBLIC

#include "Extensions/TPMT_PUBLIC.h"

/// <summary>
/// This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any
/// response that returns a public area.
/// </summary>
class _DLLEXP_ TPM2B_PUBLIC : public TpmStructure
{
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 size;
    
    /// <summary>
    /// the public area
    /// NOTE The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed
    /// for nameAlg.
    /// </summary>
    public: TPMT_PUBLIC publicArea;

public:
    TPM2B_PUBLIC() {}
    TPM2B_PUBLIC(const TPMT_PUBLIC& _publicArea)
      : publicArea(_publicArea)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_PUBLIC

/// <summary> This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded(). </summary>
class _DLLEXP_ TPM2B_TEMPLATE : public TpmStructure
{
    /// <summary> size of publicArea </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the public area </summary>
    public: ByteVec buffer;

public:
    TPM2B_TEMPLATE() {}
    TPM2B_TEMPLATE(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_TEMPLATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_TEMPLATE

/// <summary>
/// This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of
/// the key will be in a canonical form. For an RSA key, this will be one of the prime factors
/// of the public modulus. After loading, it is typical that other values will be computed so
/// that computations using the private key will not need to start with just one prime factor.
/// This structure can be used to store the results of such vendor-specific calculations.
/// </summary>
class _DLLEXP_ TPM2B_PRIVATE_VENDOR_SPECIFIC : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
    protected: mutable UINT16 size;
    
    public: ByteVec buffer;

public:
    TPM2B_PRIVATE_VENDOR_SPECIFIC() {}
    TPM2B_PRIVATE_VENDOR_SPECIFIC(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY; }
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_PRIVATE_VENDOR_SPECIFIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_PRIVATE_VENDOR_SPECIFIC

/// <summary>
/// authValue shall not be larger than the size of the digest produced by the nameAlg of the
/// object. seedValue shall be the size of the digest produced by the nameAlg of the object.
/// </summary>
class _DLLEXP_ _TPMT_SENSITIVE : public TpmStructure
{
    public: TPM_ALG_ID get_sensitiveType() const { return sensitive->GetUnionSelector(); }
    
    /// <summary>
    /// identifier for the sensitive area
    /// This shall be the same as the type parameter of the associated public area.
    /// </summary>
    protected: mutable TPM_ALG_ID sensitiveType;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authValueSize;
    
    /// <summary>
    /// user authorization data
    /// The authValue may be a zero-length string.
    /// </summary>
    public: ByteVec authValue;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 seedValueSize;
    
    /// <summary>
    /// for a parent object, the optional protection seed; for other
    /// objects, the obfuscation value
    /// </summary>
    public: ByteVec seedValue;
    
    /// <summary>
    /// the type-specific private data
    /// (One of [TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA, TPM2B_SYM_KEY,
    /// TPM2B_PRIVATE_VENDOR_SPECIFIC])
    /// </summary>
    public: shared_ptr<TPMU_SENSITIVE_COMPOSITE> sensitive;

public:
    _TPMT_SENSITIVE() {}
    _TPMT_SENSITIVE(const ByteVec& _authValue, const ByteVec& _seedValue, const TPMU_SENSITIVE_COMPOSITE& _sensitive)
      : authValue(_authValue), seedValue(_seedValue), sensitive(dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(_sensitive.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TPMT_SENSITIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TPMT_SENSITIVE

#include "Extensions/TPMT_SENSITIVE.h"

/// <summary>
/// The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an
/// unencrypted sensitive area but it may be encrypted using parameter encryption.
/// </summary>
class _DLLEXP_ TPM2B_SENSITIVE : public TpmStructure
{
    /// <summary> size of the private structure </summary>
    protected: mutable UINT16 size;
    
    /// <summary> an unencrypted sensitive area </summary>
    public: TPMT_SENSITIVE sensitiveArea;

public:
    TPM2B_SENSITIVE() {}
    TPM2B_SENSITIVE(const TPMT_SENSITIVE& _sensitiveArea)
      : sensitiveArea(_sensitiveArea)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_SENSITIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_SENSITIVE

/// <summary>
/// This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not
/// directly marshaled or unmarshaled.
/// </summary>
class _DLLEXP_ _PRIVATE : public TpmStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 integrityOuterSize;
    
    public: ByteVec integrityOuter;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 integrityInnerSize;
    
    /// <summary> could also be a TPM2B_IV </summary>
    public: ByteVec integrityInner;
    
    /// <summary> size of the private structure </summary>
    protected: mutable UINT16 sensitiveSize;
    
    /// <summary> the sensitive area </summary>
    public: TPMT_SENSITIVE sensitive;

public:
    _PRIVATE() {}
    _PRIVATE(const ByteVec& _integrityOuter, const ByteVec& _integrityInner, const TPMT_SENSITIVE& _sensitive)
      : integrityOuter(_integrityOuter), integrityInner(_integrityInner), sensitive(_sensitive)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_PRIVATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _PRIVATE

/// <summary>
/// The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and
/// modify the sensitive area of an object.
/// </summary>
class _DLLEXP_ TPM2B_PRIVATE : public TpmStructure
{
    /// <summary> size of the private structure </summary>
    protected: mutable UINT16 size;
    
    /// <summary> an encrypted private area </summary>
    public: ByteVec buffer;

public:
    TPM2B_PRIVATE() {}
    TPM2B_PRIVATE(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_PRIVATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_PRIVATE

/// <summary> This structure is used for sizing the TPM2B_ID_OBJECT. </summary>
class _DLLEXP_ TPMS_ID_OBJECT : public TpmStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 integrityHMACSize;
    
    /// <summary> HMAC using the nameAlg of the storage key on the target TPM </summary>
    public: ByteVec integrityHMAC;
    
    /// <summary>
    /// credential protector information returned if name matches the referenced object
    /// All of the encIdentity is encrypted, including the size field.
    /// NOTE The TPM is not required to check that the size is not larger than the digest of the
    /// nameAlg. However, if the size is larger, the ID object may not be usable on a TPM that has no
    /// digest larger than produced by nameAlg.
    /// </summary>
    public: ByteVec encIdentity;

public:
    TPMS_ID_OBJECT() {}
    TPMS_ID_OBJECT(const ByteVec& _integrityHMAC, const ByteVec& _encIdentity)
      : integrityHMAC(_integrityHMAC), encIdentity(_encIdentity)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_ID_OBJECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_ID_OBJECT

/// <summary>
/// This structure is an output from TPM2_MakeCredential() and is an input to
/// TPM2_ActivateCredential().
/// </summary>
class _DLLEXP_ TPM2B_ID_OBJECT : public TpmStructure
{
    /// <summary> size of the credential structure </summary>
    protected: mutable UINT16 size;
    
    /// <summary> an encrypted credential area </summary>
    public: TPMS_ID_OBJECT credential;

public:
    TPM2B_ID_OBJECT() {}
    TPM2B_ID_OBJECT(const TPMS_ID_OBJECT& _credential)
      : credential(_credential)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_ID_OBJECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_ID_OBJECT

/// <summary>
/// This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL
/// non-volatile index. pinCount is the most significant octets. pinLimit is the
/// least significant octets.
/// </summary>
class _DLLEXP_ TPMS_NV_PIN_COUNTER_PARAMETERS : public TpmStructure
{
    /// <summary>
    /// This counter shows the current number of successful authValue authorization attempts to
    /// access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue
    /// authorization attempts to access a TPM_NT_PIN_FAIL index.
    /// </summary>
    public: UINT32 pinCount;
    
    /// <summary>
    /// This threshold is the value of pinCount at which the authValue authorization of the host
    /// TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
    /// </summary>
    public: UINT32 pinLimit;

public:
    TPMS_NV_PIN_COUNTER_PARAMETERS() {}
    TPMS_NV_PIN_COUNTER_PARAMETERS(UINT32 _pinCount, UINT32 _pinLimit)
      : pinCount(_pinCount), pinLimit(_pinLimit)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_NV_PIN_COUNTER_PARAMETERS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NV_PIN_COUNTER_PARAMETERS

/// <summary> This structure describes an NV Index. </summary>
class _DLLEXP_ TPMS_NV_PUBLIC : public TpmStructure
{
    /// <summary> the handle of the data area </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary>
    /// hash algorithm used to compute the name of the Index and used for the authPolicy. For an
    /// extend index, the hash algorithm used for the extend.
    /// </summary>
    public: TPM_ALG_ID nameAlg;
    
    /// <summary> the Index attributes </summary>
    public: TPMA_NV attributes;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authPolicySize;
    
    /// <summary>
    /// optional access policy for the Index
    /// The policy is computed using the nameAlg
    /// NOTE Shall be the Empty Policy if no authorization policy is present.
    /// </summary>
    public: ByteVec authPolicy;
    
    /// <summary>
    /// the size of the data area
    /// The maximum size is implementation-dependent. The minimum maximum size is
    /// platform-specific.
    /// </summary>
    public: UINT16 dataSize;

public:
    TPMS_NV_PUBLIC() { nameAlg = TPM_ALG_ID::_NULL; }
    TPMS_NV_PUBLIC(const TPM_HANDLE& _nvIndex, TPM_ALG_ID _nameAlg, TPMA_NV _attributes, const ByteVec& _authPolicy, UINT16 _dataSize)
      : nvIndex(_nvIndex), nameAlg(_nameAlg), attributes(_attributes), authPolicy(_authPolicy), dataSize(_dataSize)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_NV_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_NV_PUBLIC

/// <summary> This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface. </summary>
class _DLLEXP_ TPM2B_NV_PUBLIC : public TpmStructure
{
    /// <summary> size of nvPublic </summary>
    protected: mutable UINT16 size;
    
    /// <summary> the public area </summary>
    public: TPMS_NV_PUBLIC nvPublic;

public:
    TPM2B_NV_PUBLIC() {}
    TPM2B_NV_PUBLIC(const TPMS_NV_PUBLIC& _nvPublic)
      : nvPublic(_nvPublic)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_NV_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_NV_PUBLIC

/// <summary>
/// This structure holds the object or session context data. When saved, the
/// full structure is encrypted.
/// </summary>
class _DLLEXP_ TPM2B_CONTEXT_SENSITIVE : public TpmStructure
{
    protected: mutable UINT16 size;
    
    /// <summary> the sensitive data </summary>
    public: ByteVec buffer;

public:
    TPM2B_CONTEXT_SENSITIVE() {}
    TPM2B_CONTEXT_SENSITIVE(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_CONTEXT_SENSITIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_CONTEXT_SENSITIVE

/// <summary> This structure holds the integrity value and the encrypted data for a context. </summary>
class _DLLEXP_ TPMS_CONTEXT_DATA : public TpmStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 integritySize;
    
    /// <summary> the integrity value </summary>
    public: ByteVec integrity;
    
    /// <summary> the sensitive area </summary>
    public: ByteVec encrypted;

public:
    TPMS_CONTEXT_DATA() {}
    TPMS_CONTEXT_DATA(const ByteVec& _integrity, const ByteVec& _encrypted)
      : integrity(_integrity), encrypted(_encrypted)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_CONTEXT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CONTEXT_DATA

/// <summary> This structure is used in a TPMS_CONTEXT. </summary>
class _DLLEXP_ TPM2B_CONTEXT_DATA : public TpmStructure
{
    protected: mutable UINT16 size;
    
    public: TPMS_CONTEXT_DATA buffer;

public:
    TPM2B_CONTEXT_DATA() {}
    TPM2B_CONTEXT_DATA(const TPMS_CONTEXT_DATA& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_CONTEXT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_CONTEXT_DATA

/// <summary>
/// This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the
/// TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the
/// context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
/// </summary>
class _DLLEXP_ TPMS_CONTEXT : public TpmStructure
{
    /// <summary>
    /// the sequence number of the context
    /// NOTE Transient object contexts and session contexts used different counters.
    /// </summary>
    public: UINT64 sequence;
    
    /// <summary>
    /// a handle indicating if the context is a session, object, or sequence object (see
    /// Table 222 Context Handle Values
    /// </summary>
    public: TPM_HANDLE savedHandle;
    
    /// <summary> the hierarchy of the context </summary>
    public: TPM_HANDLE hierarchy;
    
    protected: mutable UINT16 contextBlobSize;
    
    /// <summary> the context data and integrity HMAC </summary>
    public: TPMS_CONTEXT_DATA contextBlob;

public:
    TPMS_CONTEXT() {}
    TPMS_CONTEXT(UINT64 _sequence, const TPM_HANDLE& _savedHandle, const TPM_HANDLE& _hierarchy, const TPMS_CONTEXT_DATA& _contextBlob)
      : sequence(_sequence), savedHandle(_savedHandle), hierarchy(_hierarchy), contextBlob(_contextBlob)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_CONTEXT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CONTEXT

/// <summary>
/// This structure provides information relating to the creation environment for the object.
/// The creation data includes the parent Name, parent Qualified Name, and the digest of
/// selected PCR. These values represent the environment in which the object was created.
/// Creation data allows a relying party to determine if an object was created when some
/// appropriate protections were present.
/// </summary>
class _DLLEXP_ TPMS_CREATION_DATA : public TpmStructure
{
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectCount;
    
    /// <summary> list indicating the PCR included in pcrDigest </summary>
    public: vector<TPMS_PCR_SELECTION> pcrSelect;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 pcrDigestSize;
    
    /// <summary>
    /// digest of the selected PCR using nameAlg of the object for which this structure is being
    /// created
    /// pcrDigest.size shall be zero if the pcrSelect list is empty.
    /// </summary>
    public: ByteVec pcrDigest;
    
    /// <summary> the locality at which the object was created </summary>
    public: TPMA_LOCALITY locality;
    
    /// <summary> nameAlg of the parent </summary>
    public: TPM_ALG_ID parentNameAlg;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 parentNameSize;
    
    /// <summary>
    /// Name of the parent at time of creation
    /// The size will match digest size associated with parentNameAlg unless it is TPM_ALG_NULL,
    /// in which case the size will be 4 and parentName will be the hierarchy handle.
    /// </summary>
    public: ByteVec parentName;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 parentQualifiedNameSize;
    
    /// <summary>
    /// Qualified Name of the parent at the time of creation
    /// Size is the same as parentName.
    /// </summary>
    public: ByteVec parentQualifiedName;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 outsideInfoSize;
    
    /// <summary>
    /// association with additional information added by the key creator
    /// This will be the contents of the outsideInfo parameter in TPM2_Create()
    /// or TPM2_CreatePrimary().
    /// </summary>
    public: ByteVec outsideInfo;

public:
    TPMS_CREATION_DATA() { parentNameAlg = TPM_ALG_ID::_NULL; }
    TPMS_CREATION_DATA(const vector<TPMS_PCR_SELECTION>& _pcrSelect, const ByteVec& _pcrDigest, TPMA_LOCALITY _locality, TPM_ALG_ID _parentNameAlg, const ByteVec& _parentName, const ByteVec& _parentQualifiedName, const ByteVec& _outsideInfo)
      : pcrSelect(_pcrSelect), pcrDigest(_pcrDigest), locality(_locality), parentNameAlg(_parentNameAlg), parentName(_parentName), parentQualifiedName(_parentQualifiedName), outsideInfo(_outsideInfo)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_CREATION_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_CREATION_DATA

/// <summary>
/// This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the
/// TPM and never has a size of zero.
/// </summary>
class _DLLEXP_ TPM2B_CREATION_DATA : public TpmStructure
{
    /// <summary> size of the creation data </summary>
    protected: mutable UINT16 size;
    
    public: TPMS_CREATION_DATA creationData;

public:
    TPM2B_CREATION_DATA() {}
    TPM2B_CREATION_DATA(const TPMS_CREATION_DATA& _creationData)
      : creationData(_creationData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2B_CREATION_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_CREATION_DATA

/// <summary>
/// TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter
/// indicates the type of the data value.
/// </summary>
class _DLLEXP_ TPMS_AC_OUTPUT : public TpmStructure
{
    /// <summary> tag indicating the contents of data </summary>
    public: TPM_AT tag;
    
    /// <summary> the data returned from the AC </summary>
    public: UINT32 data;

public:
    TPMS_AC_OUTPUT() {}
    TPMS_AC_OUTPUT(TPM_AT _tag, UINT32 _data)
      : tag(_tag), data(_data)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPMS_AC_OUTPUT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPMS_AC_OUTPUT

/// <summary> This list is only used in TPM2_AC_GetCapability(). </summary>
class _DLLEXP_ TPML_AC_CAPABILITIES : public TpmStructure
{
    /// <summary> number of values in the acCapabilities list; may be 0 </summary>
    protected: mutable UINT32 count;
    
    /// <summary> a list of AC values </summary>
    public: vector<TPMS_AC_OUTPUT> acCapabilities;

public:
    TPML_AC_CAPABILITIES() {}
    TPML_AC_CAPABILITIES(const vector<TPMS_AC_OUTPUT>& _acCapabilities)
      : acCapabilities(_acCapabilities)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPML_AC_CAPABILITIES"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPML_AC_CAPABILITIES

/// <summary>
/// TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM
/// initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid
/// after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed
/// successfully. If a TPM requires TPM2_Startup() and another command is received, or if the
/// TPM receives TPM2_Startup() when it is not required, the TPM shall
/// return TPM_RC_INITIALIZE.
/// </summary>
class _DLLEXP_ TPM2_Startup_REQUEST : public ReqStructure
{
    /// <summary> TPM_SU_CLEAR or TPM_SU_STATE </summary>
    public: TPM_SU startupType;

public:
    TPM2_Startup_REQUEST() {}
    TPM2_Startup_REQUEST(TPM_SU _startupType)
      : startupType(_startupType)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Startup_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_Startup_REQUEST

/// <summary>
/// This command is used to prepare the TPM for a power cycle. The shutdownType parameter
/// indicates how the subsequent TPM2_Startup() will be processed.
/// </summary>
class _DLLEXP_ TPM2_Shutdown_REQUEST : public ReqStructure
{
    /// <summary> TPM_SU_CLEAR or TPM_SU_STATE </summary>
    public: TPM_SU shutdownType;

public:
    TPM2_Shutdown_REQUEST() {}
    TPM2_Shutdown_REQUEST(TPM_SU _shutdownType)
      : shutdownType(_shutdownType)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Shutdown_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_Shutdown_REQUEST

/// <summary>
/// This command causes the TPM to perform a test of its capabilities. If the fullTest is YES,
/// the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that
/// have not previously been tested.
/// </summary>
class _DLLEXP_ TPM2_SelfTest_REQUEST : public ReqStructure
{
    /// <summary>
    /// YES if full test to be performed
    /// NO if only test of untested functions required
    /// </summary>
    public: BYTE fullTest;

public:
    TPM2_SelfTest_REQUEST() {}
    TPM2_SelfTest_REQUEST(BYTE _fullTest)
      : fullTest(_fullTest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_SelfTest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_SelfTest_REQUEST

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
class _DLLEXP_ TPM2_IncrementalSelfTest_REQUEST : public ReqStructure
{
    /// <summary> number of algorithms in the algorithms list; may be 0 </summary>
    protected: mutable UINT32 toTestCount;
    
    /// <summary> list of algorithms that should be tested </summary>
    public: vector<TPM_ALG_ID> toTest;

public:
    TPM2_IncrementalSelfTest_REQUEST() {}
    TPM2_IncrementalSelfTest_REQUEST(const vector<TPM_ALG_ID>& _toTest)
      : toTest(_toTest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_IncrementalSelfTest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {4, 2}; }
}; // class TPM2_IncrementalSelfTest_REQUEST

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
class _DLLEXP_ IncrementalSelfTestResponse : public RespStructure
{
    /// <summary> number of algorithms in the algorithms list; may be 0 </summary>
    protected: mutable UINT32 toDoListCount;
    
    /// <summary> list of algorithms that need testing </summary>
    public: vector<TPM_ALG_ID> toDoList;

public:
    IncrementalSelfTestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "IncrementalSelfTestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {4, 2}; }
}; // class IncrementalSelfTestResponse

/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and
/// an indication of the test status.
/// </summary>
class _DLLEXP_ TPM2_GetTestResult_REQUEST : public ReqStructure
{
public:
    TPM2_GetTestResult_REQUEST() {}
    
    virtual const char* TypeName () const { return "TPM2_GetTestResult_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_GetTestResult_REQUEST

/// <summary>
/// This command returns manufacturer-specific information regarding the results of a self-test and
/// an indication of the test status.
/// </summary>
class _DLLEXP_ GetTestResultResponse : public RespStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 outDataSize;
    
    /// <summary>
    /// test result data
    /// contains manufacturer-specific information
    /// </summary>
    public: ByteVec outData;
    
    public: TPM_RC testResult;

public:
    GetTestResultResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "GetTestResultResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetTestResultResponse

/// <summary>
/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive values
/// used for authorization and for encrypting parameters.
/// </summary>
class _DLLEXP_ TPM2_StartAuthSession_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of a loaded decrypt key used to encrypt salt
    /// may be TPM_RH_NULL
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE tpmKey;
    
    /// <summary>
    /// entity providing the authValue
    /// may be TPM_RH_NULL
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE bind;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceCallerSize;
    
    /// <summary>
    /// initial nonceCaller, sets nonceTPM size for the session
    /// shall be at least 16 octets
    /// </summary>
    public: ByteVec nonceCaller;
    
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 encryptedSaltSize;
    
    /// <summary>
    /// value encrypted according to the type of tpmKey
    /// If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
    /// </summary>
    public: ByteVec encryptedSalt;
    
    /// <summary> indicates the type of the session; simple HMAC or policy (including a trial policy) </summary>
    public: TPM_SE sessionType;
    
    /// <summary>
    /// the algorithm and key size for parameter encryption
    /// may select TPM_ALG_NULL
    /// </summary>
    public: TPMT_SYM_DEF symmetric;
    
    /// <summary>
    /// hash algorithm to use for the session
    /// Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
    /// </summary>
    public: TPM_ALG_ID authHash;

public:
    TPM2_StartAuthSession_REQUEST() { authHash = TPM_ALG_ID::_NULL; }
    TPM2_StartAuthSession_REQUEST(const TPM_HANDLE& _tpmKey, const TPM_HANDLE& _bind, const ByteVec& _nonceCaller, const ByteVec& _encryptedSalt, TPM_SE _sessionType, const TPMT_SYM_DEF& _symmetric, TPM_ALG_ID _authHash)
      : tpmKey(_tpmKey), bind(_bind), nonceCaller(_nonceCaller), encryptedSalt(_encryptedSalt), sessionType(_sessionType), symmetric(_symmetric), authHash(_authHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_StartAuthSession_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {tpmKey, bind}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_StartAuthSession_REQUEST

/// <summary>
/// This command is used to start an authorization session using alternative methods of
/// establishing the session key (sessionKey). The session key is then used to derive values
/// used for authorization and for encrypting parameters.
/// </summary>
class _DLLEXP_ StartAuthSessionResponse : public RespStructure
{
    /// <summary> handle for the newly created session </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceTPMSize;
    
    /// <summary> the initial nonce from the TPM, used in the computation of the sessionKey </summary>
    public: ByteVec nonceTPM;

public:
    StartAuthSessionResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "StartAuthSessionResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class StartAuthSessionResponse

/// <summary>
/// This command allows a policy authorization session to be returned to its initial state.
/// This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code
/// indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was
/// executed. Restarting the session allows the authorizations to be replayed because the
/// session restarts with the same nonceTPM. If the PCR are valid for the policy,
/// the policy may then succeed.
/// </summary>
class _DLLEXP_ TPM2_PolicyRestart_REQUEST : public ReqStructure
{
    /// <summary> the handle for the policy session </summary>
    public: TPM_HANDLE sessionHandle;

public:
    TPM2_PolicyRestart_REQUEST() {}
    TPM2_PolicyRestart_REQUEST(const TPM_HANDLE& _sessionHandle)
      : sessionHandle(_sessionHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_PolicyRestart_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {sessionHandle}; }
}; // class TPM2_PolicyRestart_REQUEST

/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load().
/// If the command completes successfully, the TPM will create the new object and return the
/// objects creation data (creationData), its public area (outPublic), and its encrypted
/// sensitive area (outPrivate). Preservation of the returned data is the responsibility of
/// the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The
/// only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC
/// object is in the unique field.
/// </summary>
class _DLLEXP_ TPM2_Create_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of parent for new object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE The userAuth and data parameters in this buffer may both be zero length but the
    /// minimum size of this parameter will be the sum of the size fields of the two parameters
    /// of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 inSensitiveSize;
    
    /// <summary> the sensitive data </summary>
    public: TPMS_SENSITIVE_CREATE inSensitive;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    
    /// <summary> the public template </summary>
    public: TPMT_PUBLIC inPublic;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 outsideInfoSize;
    
    /// <summary>
    /// data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    /// </summary>
    public: ByteVec outsideInfo;
    
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 creationPCRCount;
    
    /// <summary> PCR that will be used in creation data </summary>
    public: vector<TPMS_PCR_SELECTION> creationPCR;

public:
    TPM2_Create_REQUEST() {}
    TPM2_Create_REQUEST(const TPM_HANDLE& _parentHandle, const TPMS_SENSITIVE_CREATE& _inSensitive, const TPMT_PUBLIC& _inPublic, const ByteVec& _outsideInfo, const vector<TPMS_PCR_SELECTION>& _creationPCR)
      : parentHandle(_parentHandle), inSensitive(_inSensitive), inPublic(_inPublic), outsideInfo(_outsideInfo), creationPCR(_creationPCR)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Create_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Create_REQUEST

/// <summary>
/// This command is used to create an object that can be loaded into a TPM using TPM2_Load().
/// If the command completes successfully, the TPM will create the new object and return the
/// objects creation data (creationData), its public area (outPublic), and its encrypted
/// sensitive area (outPrivate). Preservation of the returned data is the responsibility of
/// the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The
/// only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC
/// object is in the unique field.
/// </summary>
class _DLLEXP_ CreateResponse : public RespStructure
{
    /// <summary> the private portion of the object </summary>
    public: TPM2B_PRIVATE outPrivate;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    
    /// <summary> the public portion of the created object </summary>
    public: TPMT_PUBLIC outPublic;
    
    /// <summary> size of the creation data </summary>
    protected: mutable UINT16 creationDataSize;
    
    /// <summary> contains a TPMS_CREATION_DATA </summary>
    public: TPMS_CREATION_DATA creationData;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 creationHashSize;
    
    /// <summary> digest of creationData using nameAlg of outPublic </summary>
    public: ByteVec creationHash;
    
    /// <summary>
    /// ticket used by TPM2_CertifyCreation() to validate that the creation data
    /// was produced by the TPM
    /// </summary>
    public: TPMT_TK_CREATION creationTicket;

public:
    CreateResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CreateResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class CreateResponse

/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the
/// TPM2_LoadExternal command is used.
/// </summary>
class _DLLEXP_ TPM2_Load_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM handle of parent key; shall not be a reserved handle
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    
    /// <summary> the private portion of the object </summary>
    public: TPM2B_PRIVATE inPrivate;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    
    /// <summary> the public portion of the object </summary>
    public: TPMT_PUBLIC inPublic;

public:
    TPM2_Load_REQUEST() {}
    TPM2_Load_REQUEST(const TPM_HANDLE& _parentHandle, const TPM2B_PRIVATE& _inPrivate, const TPMT_PUBLIC& _inPublic)
      : parentHandle(_parentHandle), inPrivate(_inPrivate), inPublic(_inPublic)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Load_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
}; // class TPM2_Load_REQUEST

/// <summary>
/// This command is used to load objects into the TPM. This command is used when both a
/// TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the
/// TPM2_LoadExternal command is used.
/// </summary>
class _DLLEXP_ LoadResponse : public RespStructure
{
    /// <summary> handle of type TPM_HT_TRANSIENT for the loaded object </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nameSize;
    
    /// <summary> Name of the loaded object </summary>
    public: ByteVec name;

public:
    LoadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "LoadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class LoadResponse

/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The
/// command allows loading of a public area or both a public and sensitive area.
/// </summary>
class _DLLEXP_ TPM2_LoadExternal_REQUEST : public ReqStructure
{
    /// <summary> size of the private structure </summary>
    protected: mutable UINT16 inPrivateSize;
    
    /// <summary> the sensitive portion of the object (optional) </summary>
    public: TPMT_SENSITIVE inPrivate;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    
    /// <summary> the public portion of the object </summary>
    public: TPMT_PUBLIC inPublic;
    
    /// <summary> hierarchy with which the object area is associated </summary>
    public: TPM_HANDLE hierarchy;

public:
    TPM2_LoadExternal_REQUEST() {}
    TPM2_LoadExternal_REQUEST(const TPMT_SENSITIVE& _inPrivate, const TPMT_PUBLIC& _inPublic, const TPM_HANDLE& _hierarchy)
      : inPrivate(_inPrivate), inPublic(_inPublic), hierarchy(_hierarchy)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_LoadExternal_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_LoadExternal_REQUEST

/// <summary>
/// This command is used to load an object that is not a Protected Object into the TPM. The
/// command allows loading of a public area or both a public and sensitive area.
/// </summary>
class _DLLEXP_ LoadExternalResponse : public RespStructure
{
    /// <summary> handle of type TPM_HT_TRANSIENT for the loaded object </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nameSize;
    
    /// <summary> name of the loaded object </summary>
    public: ByteVec name;

public:
    LoadExternalResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "LoadExternalResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class LoadExternalResponse

/// <summary> This command allows access to the public area of a loaded object. </summary>
class _DLLEXP_ TPM2_ReadPublic_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM handle of an object
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE objectHandle;

public:
    TPM2_ReadPublic_REQUEST() {}
    TPM2_ReadPublic_REQUEST(const TPM_HANDLE& _objectHandle)
      : objectHandle(_objectHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_ReadPublic_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {objectHandle}; }
}; // class TPM2_ReadPublic_REQUEST

/// <summary> This command allows access to the public area of a loaded object. </summary>
class _DLLEXP_ ReadPublicResponse : public RespStructure
{
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    
    /// <summary> structure containing the public area of an object </summary>
    public: TPMT_PUBLIC outPublic;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nameSize;
    
    /// <summary> name of the object </summary>
    public: ByteVec name;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 qualifiedNameSize;
    
    /// <summary> the Qualified Name of the object </summary>
    public: ByteVec qualifiedName;

public:
    ReadPublicResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ReadPublicResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ReadPublicResponse

/// <summary>
/// This command enables the association of a credential with an object in a way that ensures
/// that the TPM has validated the parameters of the credentialed object.
/// </summary>
class _DLLEXP_ TPM2_ActivateCredential_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the object associated with certificate in credentialBlob
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE activateHandle;
    
    /// <summary>
    /// loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size of the credential structure </summary>
    protected: mutable UINT16 credentialBlobSize;
    
    /// <summary> the credential </summary>
    public: TPMS_ID_OBJECT credentialBlob;
    
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 secretSize;
    
    /// <summary> keyHandle algorithm-dependent encrypted seed that protects credentialBlob </summary>
    public: ByteVec secret;

public:
    TPM2_ActivateCredential_REQUEST() {}
    TPM2_ActivateCredential_REQUEST(const TPM_HANDLE& _activateHandle, const TPM_HANDLE& _keyHandle, const TPMS_ID_OBJECT& _credentialBlob, const ByteVec& _secret)
      : activateHandle(_activateHandle), keyHandle(_keyHandle), credentialBlob(_credentialBlob), secret(_secret)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ActivateCredential_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {activateHandle, keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ActivateCredential_REQUEST

/// <summary>
/// This command enables the association of a credential with an object in a way that ensures
/// that the TPM has validated the parameters of the credentialed object.
/// </summary>
class _DLLEXP_ ActivateCredentialResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 certInfoSize;
    
    /// <summary>
    /// the decrypted certificate information
    /// the data should be no larger than the size of the digest of the nameAlg
    /// associated with keyHandle
    /// </summary>
    public: ByteVec certInfo;

public:
    ActivateCredentialResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ActivateCredentialResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ActivateCredentialResponse

/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
class _DLLEXP_ TPM2_MakeCredential_REQUEST : public ReqStructure
{
    /// <summary>
    /// loaded public area, used to encrypt the sensitive area containing the
    /// credential key
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 credentialSize;
    
    /// <summary> the credential information </summary>
    public: ByteVec credential;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 objectNameSize;
    
    /// <summary> Name of the object to which the credential applies </summary>
    public: ByteVec objectName;

public:
    TPM2_MakeCredential_REQUEST() {}
    TPM2_MakeCredential_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _credential, const ByteVec& _objectName)
      : handle(_handle), credential(_credential), objectName(_objectName)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_MakeCredential_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_MakeCredential_REQUEST

/// <summary>
/// This command allows the TPM to perform the actions required of a Certificate Authority
/// (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
/// </summary>
class _DLLEXP_ MakeCredentialResponse : public RespStructure
{
    /// <summary> size of the credential structure </summary>
    protected: mutable UINT16 credentialBlobSize;
    
    /// <summary> the credential </summary>
    public: TPMS_ID_OBJECT credentialBlob;
    
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 secretSize;
    
    /// <summary> handle algorithm-dependent data that wraps the key that encrypts credentialBlob </summary>
    public: ByteVec secret;

public:
    MakeCredentialResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "MakeCredentialResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class MakeCredentialResponse

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
class _DLLEXP_ TPM2_Unseal_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of a loaded data object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE itemHandle;

public:
    TPM2_Unseal_REQUEST() {}
    TPM2_Unseal_REQUEST(const TPM_HANDLE& _itemHandle)
      : itemHandle(_itemHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_Unseal_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {itemHandle}; }
}; // class TPM2_Unseal_REQUEST

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
class _DLLEXP_ UnsealResponse : public RespStructure
{
    protected: mutable UINT16 outDataSize;
    
    /// <summary>
    /// unsealed data
    /// Size of outData is limited to be no more than 128 octets.
    /// </summary>
    public: ByteVec outData;

public:
    UnsealResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "UnsealResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class UnsealResponse

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
class _DLLEXP_ TPM2_ObjectChangeAuth_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the object
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE objectHandle;
    
    /// <summary>
    /// handle of the parent
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE parentHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 newAuthSize;
    
    /// <summary> new authorization value </summary>
    public: ByteVec newAuth;

public:
    TPM2_ObjectChangeAuth_REQUEST() {}
    TPM2_ObjectChangeAuth_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _parentHandle, const ByteVec& _newAuth)
      : objectHandle(_objectHandle), parentHandle(_parentHandle), newAuth(_newAuth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ObjectChangeAuth_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {objectHandle, parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ObjectChangeAuth_REQUEST

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
class _DLLEXP_ ObjectChangeAuthResponse : public RespStructure
{
    /// <summary> private area containing the new authorization value </summary>
    public: TPM2B_PRIVATE outPrivate;

public:
    ObjectChangeAuthResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ObjectChangeAuthResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class ObjectChangeAuthResponse

/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of
/// any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle.
/// If parentHandle references a Primary Seed, then a Primary Object is created; if
/// parentHandle references a Storage Parent, then an Ordinary Object is created; and if
/// parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
class _DLLEXP_ TPM2_CreateLoaded_REQUEST : public ReqStructure
{
    /// <summary>
    /// Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT,
    /// TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE The userAuth and data parameters in this buffer may both be zero length but the
    /// minimum size of this parameter will be the sum of the size fields of the two parameters
    /// of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 inSensitiveSize;
    
    /// <summary> the sensitive data, see TPM 2.0 Part 1 Sensitive Values </summary>
    public: TPMS_SENSITIVE_CREATE inSensitive;
    
    /// <summary> size of publicArea </summary>
    protected: mutable UINT16 inPublicSize;
    
    /// <summary> the public template </summary>
    public: ByteVec inPublic;

public:
    TPM2_CreateLoaded_REQUEST() {}
    TPM2_CreateLoaded_REQUEST(const TPM_HANDLE& _parentHandle, const TPMS_SENSITIVE_CREATE& _inSensitive, const ByteVec& _inPublic)
      : parentHandle(_parentHandle), inSensitive(_inSensitive), inPublic(_inPublic)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_CreateLoaded_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CreateLoaded_REQUEST

/// <summary>
/// This command creates an object and loads it in the TPM. This command allows creation of
/// any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle.
/// If parentHandle references a Primary Seed, then a Primary Object is created; if
/// parentHandle references a Storage Parent, then an Ordinary Object is created; and if
/// parentHandle references a Derivation Parent, then a Derived Object is generated.
/// </summary>
class _DLLEXP_ CreateLoadedResponse : public RespStructure
{
    /// <summary> handle of type TPM_HT_TRANSIENT for created object </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> the sensitive area of the object (optional) </summary>
    public: TPM2B_PRIVATE outPrivate;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    
    /// <summary> the public portion of the created object </summary>
    public: TPMT_PUBLIC outPublic;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nameSize;
    
    /// <summary> the name of the created object </summary>
    public: ByteVec name;

public:
    CreateLoadedResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CreateLoadedResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class CreateLoadedResponse

/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy.
/// The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL.
/// Only the public area of newParentHandle is required to be loaded.
/// </summary>
class _DLLEXP_ TPM2_Duplicate_REQUEST : public ReqStructure
{
    /// <summary>
    /// loaded object to duplicate
    /// Auth Index: 1
    /// Auth Role: DUP
    /// </summary>
    public: TPM_HANDLE objectHandle;
    
    /// <summary>
    /// shall reference the public area of an asymmetric key
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE newParentHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 encryptionKeyInSize;
    
    /// <summary>
    /// optional symmetric encryption key
    /// The size for this key is set to zero when the TPM is to generate the key. This
    /// parameter may be encrypted.
    /// </summary>
    public: ByteVec encryptionKeyIn;
    
    /// <summary>
    /// definition for the symmetric algorithm to be used for the inner wrapper
    /// may be TPM_ALG_NULL if no inner wrapper is applied
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetricAlg;

public:
    TPM2_Duplicate_REQUEST() {}
    TPM2_Duplicate_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _newParentHandle, const ByteVec& _encryptionKeyIn, const TPMT_SYM_DEF_OBJECT& _symmetricAlg)
      : objectHandle(_objectHandle), newParentHandle(_newParentHandle), encryptionKeyIn(_encryptionKeyIn), symmetricAlg(_symmetricAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Duplicate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {objectHandle, newParentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Duplicate_REQUEST

/// <summary>
/// This command duplicates a loaded object so that it may be used in a different hierarchy.
/// The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL.
/// Only the public area of newParentHandle is required to be loaded.
/// </summary>
class _DLLEXP_ DuplicateResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 encryptionKeyOutSize;
    
    /// <summary>
    /// If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then this
    /// will be the Empty Buffer; otherwise, it shall contain the TPM-generated, symmetric
    /// encryption key for the inner wrapper.
    /// </summary>
    public: ByteVec encryptionKeyOut;
    
    /// <summary> private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted </summary>
    public: TPM2B_PRIVATE duplicate;
    
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 outSymSeedSize;
    
    /// <summary> seed protected by the asymmetric algorithms of new parent (NP) </summary>
    public: ByteVec outSymSeed;

public:
    DuplicateResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "DuplicateResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class DuplicateResponse

/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric key
/// are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new
/// protection seed value is generated according to the methods appropriate for newParent and
/// the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is
/// returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
class _DLLEXP_ TPM2_Rewrap_REQUEST : public ReqStructure
{
    /// <summary>
    /// parent of object
    /// Auth Index: 1
    /// Auth Role: User
    /// </summary>
    public: TPM_HANDLE oldParent;
    
    /// <summary>
    /// new parent of the object
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE newParent;
    
    /// <summary> an object encrypted using symmetric key derived from inSymSeed </summary>
    public: TPM2B_PRIVATE inDuplicate;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nameSize;
    
    /// <summary> the Name of the object being rewrapped </summary>
    public: ByteVec name;
    
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 inSymSeedSize;
    
    /// <summary>
    /// the seed for the symmetric key and HMAC key
    /// needs oldParent private key to recover the seed and generate the symmetric key
    /// </summary>
    public: ByteVec inSymSeed;

public:
    TPM2_Rewrap_REQUEST() {}
    TPM2_Rewrap_REQUEST(const TPM_HANDLE& _oldParent, const TPM_HANDLE& _newParent, const TPM2B_PRIVATE& _inDuplicate, const ByteVec& _name, const ByteVec& _inSymSeed)
      : oldParent(_oldParent), newParent(_newParent), inDuplicate(_inDuplicate), name(_name), inSymSeed(_inSymSeed)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Rewrap_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {oldParent, newParent}; }
}; // class TPM2_Rewrap_REQUEST

/// <summary>
/// This command allows the TPM to serve in the role as a Duplication Authority. If proper
/// authorization for use of the oldParent is provided, then an HMAC key and a symmetric key
/// are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new
/// protection seed value is generated according to the methods appropriate for newParent and
/// the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is
/// returned in outDuplicate and the symmetric key returned in outSymKey.
/// </summary>
class _DLLEXP_ RewrapResponse : public RespStructure
{
    /// <summary> an object encrypted using symmetric key derived from outSymSeed </summary>
    public: TPM2B_PRIVATE outDuplicate;
    
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 outSymSeedSize;
    
    /// <summary> seed for a symmetric key protected by newParent asymmetric key </summary>
    public: ByteVec outSymSeed;

public:
    RewrapResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "RewrapResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class RewrapResponse

/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a
/// Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The
/// imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
class _DLLEXP_ TPM2_Import_REQUEST : public ReqStructure
{
    /// <summary>
    /// the handle of the new parent for the object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE parentHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 encryptionKeySize;
    
    /// <summary>
    /// the optional symmetric encryption key used as the inner wrapper for duplicate
    /// If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
    /// </summary>
    public: ByteVec encryptionKey;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 objectPublicSize;
    
    /// <summary>
    /// the public area of the object to be imported
    /// This is provided so that the integrity value for duplicate and the object attributes can
    /// be checked.
    /// NOTE Even if the integrity value of the object is not checked on input, the object Name is
    /// required to create the integrity value for the imported object.
    /// </summary>
    public: TPMT_PUBLIC objectPublic;
    
    /// <summary> the symmetrically encrypted duplicate object that may contain an inner symmetric wrapper </summary>
    public: TPM2B_PRIVATE duplicate;
    
    /// <summary> size of the secret value </summary>
    protected: mutable UINT16 inSymSeedSize;
    
    /// <summary>
    /// the seed for the symmetric key and HMAC key
    /// inSymSeed is encrypted/encoded using the algorithms of newParent.
    /// </summary>
    public: ByteVec inSymSeed;
    
    /// <summary>
    /// definition for the symmetric algorithm to use for the inner wrapper
    /// If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey
    /// shall be the Empty Buffer.
    /// </summary>
    public: TPMT_SYM_DEF_OBJECT symmetricAlg;

public:
    TPM2_Import_REQUEST() {}
    TPM2_Import_REQUEST(const TPM_HANDLE& _parentHandle, const ByteVec& _encryptionKey, const TPMT_PUBLIC& _objectPublic, const TPM2B_PRIVATE& _duplicate, const ByteVec& _inSymSeed, const TPMT_SYM_DEF_OBJECT& _symmetricAlg)
      : parentHandle(_parentHandle), encryptionKey(_encryptionKey), objectPublic(_objectPublic), duplicate(_duplicate), inSymSeed(_inSymSeed), symmetricAlg(_symmetricAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Import_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Import_REQUEST

/// <summary>
/// This command allows an object to be encrypted using the symmetric encryption values of a
/// Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The
/// imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
/// </summary>
class _DLLEXP_ ImportResponse : public RespStructure
{
    /// <summary> the sensitive area encrypted with the symmetric key of parentHandle </summary>
    public: TPM2B_PRIVATE outPrivate;

public:
    ImportResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ImportResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class ImportResponse

/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF
/// RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to
/// specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme
/// shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ TPM2_RSA_Encrypt_REQUEST : public ReqStructure
{
    /// <summary>
    /// reference to public portion of RSA key to use for encryption
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 messageSize;
    
    /// <summary>
    /// message to be encrypted
    /// NOTE 1 The data type was chosen because it limits the overall size of the input to no
    /// greater than the size of the largest RSA public key. This may be larger
    /// than allowed for keyHandle.
    /// </summary>
    public: ByteVec message;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> inScheme;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 labelSize;
    
    /// <summary>
    /// optional label L to be associated with the message
    /// Size of the buffer is zero if no label is present
    /// NOTE 2 See description of label above.
    /// </summary>
    public: ByteVec label;

public:
    TPM2_RSA_Encrypt_REQUEST() {}
    TPM2_RSA_Encrypt_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _message, const TPMU_ASYM_SCHEME& _inScheme, const ByteVec& _label)
      : keyHandle(_keyHandle), message(_message), inScheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone())), label(_label)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_RSA_Encrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_RSA_Encrypt_REQUEST

/// <summary>
/// This command performs RSA encryption using the indicated padding scheme according to IETF
/// RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to
/// specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme
/// shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ RSA_EncryptResponse : public RespStructure
{
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 outDataSize;
    
    /// <summary> encrypted output </summary>
    public: ByteVec outData;

public:
    RSA_EncryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "RSA_EncryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class RSA_EncryptResponse

/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according
/// to IETF RFC 8017 ((PKCS#1).
/// </summary>
class _DLLEXP_ TPM2_RSA_Decrypt_REQUEST : public ReqStructure
{
    /// <summary>
    /// RSA key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 cipherTextSize;
    
    /// <summary>
    /// cipher text to be decrypted
    /// NOTE An encrypted RSA data block is the size of the public modulus.
    /// </summary>
    public: ByteVec cipherText;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
    /// TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2,
    /// TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP,
    /// TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_ASYM_SCHEME> inScheme;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 labelSize;
    
    /// <summary> label whose association with the message is to be verified </summary>
    public: ByteVec label;

public:
    TPM2_RSA_Decrypt_REQUEST() {}
    TPM2_RSA_Decrypt_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _cipherText, const TPMU_ASYM_SCHEME& _inScheme, const ByteVec& _label)
      : keyHandle(_keyHandle), cipherText(_cipherText), inScheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone())), label(_label)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_RSA_Decrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_RSA_Decrypt_REQUEST

/// <summary>
/// This command performs RSA decryption using the indicated padding scheme according
/// to IETF RFC 8017 ((PKCS#1).
/// </summary>
class _DLLEXP_ RSA_DecryptResponse : public RespStructure
{
    /// <summary>
    /// size of the buffer
    /// The value of zero is only valid for create.
    /// </summary>
    protected: mutable UINT16 messageSize;
    
    /// <summary> decrypted output </summary>
    public: ByteVec message;

public:
    RSA_DecryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "RSA_DecryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class RSA_DecryptResponse

/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It
/// uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
/// </summary>
class _DLLEXP_ TPM2_ECDH_KeyGen_REQUEST : public ReqStructure
{
    /// <summary>
    /// Handle of a loaded ECC key public area.
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;

public:
    TPM2_ECDH_KeyGen_REQUEST() {}
    TPM2_ECDH_KeyGen_REQUEST(const TPM_HANDLE& _keyHandle)
      : keyHandle(_keyHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_ECDH_KeyGen_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
}; // class TPM2_ECDH_KeyGen_REQUEST

/// <summary>
/// This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It
/// uses the private ephemeral key and a loaded public key (QS) to compute the shared
/// secret value (P [hde]QS).
/// </summary>
class _DLLEXP_ ECDH_KeyGenResponse : public RespStructure
{
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 zPointSize;
    
    /// <summary> results of P h[de]Qs </summary>
    public: TPMS_ECC_POINT zPoint;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 pubPointSize;
    
    /// <summary> generated ephemeral public point (Qe) </summary>
    public: TPMS_ECC_POINT pubPoint;

public:
    ECDH_KeyGenResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ECDH_KeyGenResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECDH_KeyGenResponse

/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private
/// key (ds). It will perform the multiplication of the provided inPoint (QB) with the private
/// key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h
/// is the cofactor of the curve).
/// </summary>
class _DLLEXP_ TPM2_ECDH_ZGen_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of a loaded ECC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 inPointSize;
    
    /// <summary> a public key </summary>
    public: TPMS_ECC_POINT inPoint;

public:
    TPM2_ECDH_ZGen_REQUEST() {}
    TPM2_ECDH_ZGen_REQUEST(const TPM_HANDLE& _keyHandle, const TPMS_ECC_POINT& _inPoint)
      : keyHandle(_keyHandle), inPoint(_inPoint)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ECDH_ZGen_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ECDH_ZGen_REQUEST

/// <summary>
/// This command uses the TPM to recover the Z value from a public point (QB) and a private
/// key (ds). It will perform the multiplication of the provided inPoint (QB) with the private
/// key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h
/// is the cofactor of the curve).
/// </summary>
class _DLLEXP_ ECDH_ZGenResponse : public RespStructure
{
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 outPointSize;
    
    /// <summary> X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB </summary>
    public: TPMS_ECC_POINT outPoint;

public:
    ECDH_ZGenResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ECDH_ZGenResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECDH_ZGenResponse

/// <summary>
/// This command returns the parameters of an ECC curve identified by
/// its TCG-assigned curveID.
/// </summary>
class _DLLEXP_ TPM2_ECC_Parameters_REQUEST : public ReqStructure
{
    /// <summary> parameter set selector </summary>
    public: TPM_ECC_CURVE curveID;

public:
    TPM2_ECC_Parameters_REQUEST() {}
    TPM2_ECC_Parameters_REQUEST(TPM_ECC_CURVE _curveID)
      : curveID(_curveID)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ECC_Parameters_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_ECC_Parameters_REQUEST

/// <summary>
/// This command returns the parameters of an ECC curve identified by
/// its TCG-assigned curveID.
/// </summary>
class _DLLEXP_ ECC_ParametersResponse : public RespStructure
{
    /// <summary> ECC parameters for the selected curve </summary>
    public: TPMS_ALGORITHM_DETAIL_ECC parameters;

public:
    ECC_ParametersResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ECC_ParametersResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class ECC_ParametersResponse

/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination
/// with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the
/// public point of that ephemeral key along with a numeric value that allows the TPM to
/// regenerate the associated private key.
/// </summary>
class _DLLEXP_ TPM2_ZGen_2Phase_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of an unrestricted decryption key ECC
    /// The private key referenced by this handle is used as dS,A
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyA;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 inQsBSize;
    
    /// <summary> other partys static public key (Qs,B = (Xs,B, Ys,B)) </summary>
    public: TPMS_ECC_POINT inQsB;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 inQeBSize;
    
    /// <summary> other party's ephemeral public key (Qe,B = (Xe,B, Ye,B)) </summary>
    public: TPMS_ECC_POINT inQeB;
    
    /// <summary> the key exchange scheme </summary>
    public: TPM_ALG_ID inScheme;
    
    /// <summary> value returned by TPM2_EC_Ephemeral() </summary>
    public: UINT16 counter;

public:
    TPM2_ZGen_2Phase_REQUEST() { inScheme = TPM_ALG_ID::_NULL; }
    TPM2_ZGen_2Phase_REQUEST(const TPM_HANDLE& _keyA, const TPMS_ECC_POINT& _inQsB, const TPMS_ECC_POINT& _inQeB, TPM_ALG_ID _inScheme, UINT16 _counter)
      : keyA(_keyA), inQsB(_inQsB), inQeB(_inQeB), inScheme(_inScheme), counter(_counter)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ZGen_2Phase_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyA}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ZGen_2Phase_REQUEST

/// <summary>
/// This command supports two-phase key exchange protocols. The command is used in combination
/// with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the
/// public point of that ephemeral key along with a numeric value that allows the TPM to
/// regenerate the associated private key.
/// </summary>
class _DLLEXP_ ZGen_2PhaseResponse : public RespStructure
{
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 outZ1Size;
    
    /// <summary> X and Y coordinates of the computed value (scheme dependent) </summary>
    public: TPMS_ECC_POINT outZ1;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 outZ2Size;
    
    /// <summary> X and Y coordinates of the second computed value (scheme dependent) </summary>
    public: TPMS_ECC_POINT outZ2;

public:
    ZGen_2PhaseResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ZGen_2PhaseResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ZGen_2PhaseResponse

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
class _DLLEXP_ TPM2_ECC_Encrypt_REQUEST : public ReqStructure
{
    /// <summary>
    /// reference to public portion of ECC key to use for encryption
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 plainTextSize;
    
    /// <summary> Plaintext to be encrypted </summary>
    public: ByteVec plainText;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// the KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_KDF_SCHEME> inScheme;

public:
    TPM2_ECC_Encrypt_REQUEST() {}
    TPM2_ECC_Encrypt_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _plainText, const TPMU_KDF_SCHEME& _inScheme)
      : keyHandle(_keyHandle), plainText(_plainText), inScheme(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ECC_Encrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ECC_Encrypt_REQUEST

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
class _DLLEXP_ ECC_EncryptResponse : public RespStructure
{
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 C1Size;
    
    /// <summary> the public ephemeral key used for ECDH </summary>
    public: TPMS_ECC_POINT C1;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 C2Size;
    
    /// <summary> the data block produced by the XOR process </summary>
    public: ByteVec C2;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 C3Size;
    
    /// <summary> the integrity value </summary>
    public: ByteVec C3;

public:
    ECC_EncryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ECC_EncryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECC_EncryptResponse

/// <summary> This command performs ECC decryption. </summary>
class _DLLEXP_ TPM2_ECC_Decrypt_REQUEST : public ReqStructure
{
    /// <summary>
    /// ECC key to use for decryption
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 C1Size;
    
    /// <summary> the public ephemeral key used for ECDH </summary>
    public: TPMS_ECC_POINT C1;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 C2Size;
    
    /// <summary> the data block produced by the XOR process </summary>
    public: ByteVec C2;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 C3Size;
    
    /// <summary> the integrity value </summary>
    public: ByteVec C3;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// the KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
    /// TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_KDF_SCHEME> inScheme;

public:
    TPM2_ECC_Decrypt_REQUEST() {}
    TPM2_ECC_Decrypt_REQUEST(const TPM_HANDLE& _keyHandle, const TPMS_ECC_POINT& _C1, const ByteVec& _C2, const ByteVec& _C3, const TPMU_KDF_SCHEME& _inScheme)
      : keyHandle(_keyHandle), C1(_C1), C2(_C2), C3(_C3), inScheme(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ECC_Decrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ECC_Decrypt_REQUEST

/// <summary> This command performs ECC decryption. </summary>
class _DLLEXP_ ECC_DecryptResponse : public RespStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 plainTextSize;
    
    /// <summary> decrypted output </summary>
    public: ByteVec plainText;

public:
    ECC_DecryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ECC_DecryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECC_DecryptResponse

/// <summary>
/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be
/// reflected in platform-specific specifications.
/// </summary>
class _DLLEXP_ TPM2_EncryptDecrypt_REQUEST : public ReqStructure
{
    /// <summary>
    /// the symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> if YES, then the operation is decryption; if NO, the operation is encryption </summary>
    public: BYTE decrypt;
    
    /// <summary>
    /// symmetric encryption/decryption mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID mode;
    
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivInSize;
    
    /// <summary> an initial value as required by the algorithm </summary>
    public: ByteVec ivIn;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 inDataSize;
    
    /// <summary> the data to be encrypted/decrypted </summary>
    public: ByteVec inData;

public:
    TPM2_EncryptDecrypt_REQUEST() { mode = TPM_ALG_ID::_NULL; }
    TPM2_EncryptDecrypt_REQUEST(const TPM_HANDLE& _keyHandle, BYTE _decrypt, TPM_ALG_ID _mode, const ByteVec& _ivIn, const ByteVec& _inData)
      : keyHandle(_keyHandle), decrypt(_decrypt), mode(_mode), ivIn(_ivIn), inData(_inData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_EncryptDecrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
}; // class TPM2_EncryptDecrypt_REQUEST

/// <summary>
/// NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be
/// reflected in platform-specific specifications.
/// </summary>
class _DLLEXP_ EncryptDecryptResponse : public RespStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 outDataSize;
    
    /// <summary> encrypted or decrypted output </summary>
    public: ByteVec outData;
    
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivOutSize;
    
    /// <summary> chaining value to use for IV in next round </summary>
    public: ByteVec ivOut;

public:
    EncryptDecryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "EncryptDecryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class EncryptDecryptResponse

/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is
/// the first parameter. This permits inData to be parameter encrypted.
/// </summary>
class _DLLEXP_ TPM2_EncryptDecrypt2_REQUEST : public ReqStructure
{
    /// <summary>
    /// the symmetric key used for the operation
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 inDataSize;
    
    /// <summary> the data to be encrypted/decrypted </summary>
    public: ByteVec inData;
    
    /// <summary> if YES, then the operation is decryption; if NO, the operation is encryption </summary>
    public: BYTE decrypt;
    
    /// <summary>
    /// symmetric mode
    /// this field shall match the default mode of the key or be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID mode;
    
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivInSize;
    
    /// <summary> an initial value as required by the algorithm </summary>
    public: ByteVec ivIn;

public:
    TPM2_EncryptDecrypt2_REQUEST() { mode = TPM_ALG_ID::_NULL; }
    TPM2_EncryptDecrypt2_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _inData, BYTE _decrypt, TPM_ALG_ID _mode, const ByteVec& _ivIn)
      : keyHandle(_keyHandle), inData(_inData), decrypt(_decrypt), mode(_mode), ivIn(_ivIn)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_EncryptDecrypt2_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_EncryptDecrypt2_REQUEST

/// <summary>
/// This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is
/// the first parameter. This permits inData to be parameter encrypted.
/// </summary>
class _DLLEXP_ EncryptDecrypt2Response : public RespStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 outDataSize;
    
    /// <summary> encrypted or decrypted output </summary>
    public: ByteVec outData;
    
    /// <summary>
    /// size of the IV value
    /// This value is fixed for a TPM implementation.
    /// </summary>
    protected: mutable UINT16 ivOutSize;
    
    /// <summary> chaining value to use for IV in next round </summary>
    public: ByteVec ivOut;

public:
    EncryptDecrypt2Response() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "EncryptDecrypt2Response"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class EncryptDecrypt2Response

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
class _DLLEXP_ TPM2_Hash_REQUEST : public ReqStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 dataSize;
    
    /// <summary> data to be hashed </summary>
    public: ByteVec data;
    
    /// <summary> algorithm for the hash being computed shall not be TPM_ALG_NULL </summary>
    public: TPM_ALG_ID hashAlg;
    
    /// <summary> hierarchy to use for the ticket (TPM_RH_NULL allowed) </summary>
    public: TPM_HANDLE hierarchy;

public:
    TPM2_Hash_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_Hash_REQUEST(const ByteVec& _data, TPM_ALG_ID _hashAlg, const TPM_HANDLE& _hierarchy)
      : data(_data), hashAlg(_hashAlg), hierarchy(_hierarchy)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Hash_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Hash_REQUEST

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
class _DLLEXP_ HashResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 outHashSize;
    
    /// <summary> results </summary>
    public: ByteVec outHash;
    
    /// <summary>
    /// ticket indicating that the sequence of octets used to compute outDigest did not start with
    /// TPM_GENERATED_VALUE
    /// will be a NULL ticket if the digest may not be signed with a restricted
    /// key
    /// </summary>
    public: TPMT_TK_HASHCHECK validation;

public:
    HashResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "HashResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class HashResponse

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
class _DLLEXP_ TPM2_HMAC_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the symmetric signing key providing the HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 bufferSize;
    
    /// <summary> HMAC data </summary>
    public: ByteVec buffer;
    
    /// <summary> algorithm to use for HMAC </summary>
    public: TPM_ALG_ID hashAlg;

public:
    TPM2_HMAC_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_HMAC_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _buffer, TPM_ALG_ID _hashAlg)
      : handle(_handle), buffer(_buffer), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_HMAC_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HMAC_REQUEST

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
class _DLLEXP_ HMACResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 outHMACSize;
    
    /// <summary> the returned HMAC in a sized buffer </summary>
    public: ByteVec outHMAC;

public:
    HMACResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "HMACResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class HMACResponse

/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data
/// using the indicated algorithm.
/// </summary>
class _DLLEXP_ TPM2_MAC_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the symmetric signing key providing the MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 bufferSize;
    
    /// <summary> MAC data </summary>
    public: ByteVec buffer;
    
    /// <summary> algorithm to use for MAC </summary>
    public: TPM_ALG_ID inScheme;

public:
    TPM2_MAC_REQUEST() { inScheme = TPM_ALG_ID::_NULL; }
    TPM2_MAC_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _buffer, TPM_ALG_ID _inScheme)
      : handle(_handle), buffer(_buffer), inScheme(_inScheme)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_MAC_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_MAC_REQUEST

/// <summary>
/// This command performs an HMAC or a block cipher MAC on the supplied data
/// using the indicated algorithm.
/// </summary>
class _DLLEXP_ MACResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 outMACSize;
    
    /// <summary> the returned MAC in a sized buffer </summary>
    public: ByteVec outMAC;

public:
    MACResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "MACResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class MACResponse

/// <summary>
/// This command returns the next bytesRequested octets from the random
/// number generator (RNG).
/// </summary>
class _DLLEXP_ TPM2_GetRandom_REQUEST : public ReqStructure
{
    /// <summary> number of octets to return </summary>
    public: UINT16 bytesRequested;

public:
    TPM2_GetRandom_REQUEST() {}
    TPM2_GetRandom_REQUEST(UINT16 _bytesRequested)
      : bytesRequested(_bytesRequested)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_GetRandom_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_GetRandom_REQUEST

/// <summary>
/// This command returns the next bytesRequested octets from the random
/// number generator (RNG).
/// </summary>
class _DLLEXP_ GetRandomResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 randomBytesSize;
    
    /// <summary> the random octets </summary>
    public: ByteVec randomBytes;

public:
    GetRandomResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "GetRandomResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetRandomResponse

/// <summary> This command is used to add "additional information" to the RNG state. </summary>
class _DLLEXP_ TPM2_StirRandom_REQUEST : public ReqStructure
{
    protected: mutable UINT16 inDataSize;
    
    /// <summary> additional information </summary>
    public: ByteVec inData;

public:
    TPM2_StirRandom_REQUEST() {}
    TPM2_StirRandom_REQUEST(const ByteVec& _inData)
      : inData(_inData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_StirRandom_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_StirRandom_REQUEST

/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
/// </summary>
class _DLLEXP_ TPM2_HMAC_Start_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of an HMAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authSize;
    
    /// <summary> authorization value for subsequent use of the sequence </summary>
    public: ByteVec auth;
    
    /// <summary> the hash algorithm to use for the HMAC </summary>
    public: TPM_ALG_ID hashAlg;

public:
    TPM2_HMAC_Start_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_HMAC_Start_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _auth, TPM_ALG_ID _hashAlg)
      : handle(_handle), auth(_auth), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_HMAC_Start_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HMAC_Start_REQUEST

/// <summary>
/// This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
/// </summary>
class _DLLEXP_ HMAC_StartResponse : public RespStructure
{
    /// <summary> a handle to reference the sequence </summary>
    public: TPM_HANDLE handle;

public:
    HMAC_StartResponse() {}
    
    virtual const char* TypeName () const { return "HMAC_StartResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class HMAC_StartResponse

/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
/// </summary>
class _DLLEXP_ TPM2_MAC_Start_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of a MAC key
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authSize;
    
    /// <summary> authorization value for subsequent use of the sequence </summary>
    public: ByteVec auth;
    
    /// <summary> the algorithm to use for the MAC </summary>
    public: TPM_ALG_ID inScheme;

public:
    TPM2_MAC_Start_REQUEST() { inScheme = TPM_ALG_ID::_NULL; }
    TPM2_MAC_Start_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _auth, TPM_ALG_ID _inScheme)
      : handle(_handle), auth(_auth), inScheme(_inScheme)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_MAC_Start_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_MAC_Start_REQUEST

/// <summary>
/// This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
/// structure, assign a handle to the sequence, and set the authValue of the sequence
/// object to the value in auth.
/// </summary>
class _DLLEXP_ MAC_StartResponse : public RespStructure
{
    /// <summary> a handle to reference the sequence </summary>
    public: TPM_HANDLE handle;

public:
    MAC_StartResponse() {}
    
    virtual const char* TypeName () const { return "MAC_StartResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class MAC_StartResponse

/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a
/// hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started.
/// If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
/// </summary>
class _DLLEXP_ TPM2_HashSequenceStart_REQUEST : public ReqStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authSize;
    
    /// <summary> authorization value for subsequent use of the sequence </summary>
    public: ByteVec auth;
    
    /// <summary>
    /// the hash algorithm to use for the hash sequence
    /// An Event Sequence starts if this is TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID hashAlg;

public:
    TPM2_HashSequenceStart_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_HashSequenceStart_REQUEST(const ByteVec& _auth, TPM_ALG_ID _hashAlg)
      : auth(_auth), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_HashSequenceStart_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HashSequenceStart_REQUEST

/// <summary>
/// This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a
/// hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started.
/// If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
/// shall return TPM_RC_HASH.
/// </summary>
class _DLLEXP_ HashSequenceStartResponse : public RespStructure
{
    /// <summary> a handle to reference the sequence </summary>
    public: TPM_HANDLE handle;

public:
    HashSequenceStartResponse() {}
    
    virtual const char* TypeName () const { return "HashSequenceStartResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class HashSequenceStartResponse

/// <summary>
/// This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any
/// size up to the limits of the TPM.
/// </summary>
class _DLLEXP_ TPM2_SequenceUpdate_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the sequence object
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE sequenceHandle;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 bufferSize;
    
    /// <summary> data to be added to hash </summary>
    public: ByteVec buffer;

public:
    TPM2_SequenceUpdate_REQUEST() {}
    TPM2_SequenceUpdate_REQUEST(const TPM_HANDLE& _sequenceHandle, const ByteVec& _buffer)
      : sequenceHandle(_sequenceHandle), buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_SequenceUpdate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {sequenceHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_SequenceUpdate_REQUEST

/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence
/// and returns the result.
/// </summary>
class _DLLEXP_ TPM2_SequenceComplete_REQUEST : public ReqStructure
{
    /// <summary>
    /// authorization for the sequence
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE sequenceHandle;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 bufferSize;
    
    /// <summary> data to be added to the hash/HMAC </summary>
    public: ByteVec buffer;
    
    /// <summary> hierarchy of the ticket for a hash </summary>
    public: TPM_HANDLE hierarchy;

public:
    TPM2_SequenceComplete_REQUEST() {}
    TPM2_SequenceComplete_REQUEST(const TPM_HANDLE& _sequenceHandle, const ByteVec& _buffer, const TPM_HANDLE& _hierarchy)
      : sequenceHandle(_sequenceHandle), buffer(_buffer), hierarchy(_hierarchy)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_SequenceComplete_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {sequenceHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_SequenceComplete_REQUEST

/// <summary>
/// This command adds the last part of data, if any, to a hash/HMAC sequence
/// and returns the result.
/// </summary>
class _DLLEXP_ SequenceCompleteResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 resultSize;
    
    /// <summary> the returned HMAC or digest in a sized buffer </summary>
    public: ByteVec result;
    
    /// <summary>
    /// ticket indicating that the sequence of octets used to compute outDigest did not start with
    /// TPM_GENERATED_VALUE
    /// This is a NULL Ticket when the sequence is HMAC.
    /// </summary>
    public: TPMT_TK_HASHCHECK validation;

public:
    SequenceCompleteResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "SequenceCompleteResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class SequenceCompleteResponse

/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input parameter to
/// TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is
/// extended with the associated digest value from the list.
/// </summary>
class _DLLEXP_ TPM2_EventSequenceComplete_REQUEST : public ReqStructure
{
    /// <summary>
    /// PCR to be extended with the Event data
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    
    /// <summary>
    /// authorization for the sequence
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE sequenceHandle;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 bufferSize;
    
    /// <summary> data to be added to the Event </summary>
    public: ByteVec buffer;

public:
    TPM2_EventSequenceComplete_REQUEST() {}
    TPM2_EventSequenceComplete_REQUEST(const TPM_HANDLE& _pcrHandle, const TPM_HANDLE& _sequenceHandle, const ByteVec& _buffer)
      : pcrHandle(_pcrHandle), sequenceHandle(_sequenceHandle), buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_EventSequenceComplete_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {pcrHandle, sequenceHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_EventSequenceComplete_REQUEST

/// <summary>
/// This command adds the last part of data, if any, to an Event Sequence and returns the
/// result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
/// returned digest list is processed in the same manner as the digest list input parameter to
/// TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is
/// extended with the associated digest value from the list.
/// </summary>
class _DLLEXP_ EventSequenceCompleteResponse : public RespStructure
{
    /// <summary> number of digests in the list </summary>
    protected: mutable UINT32 resultsCount;
    
    /// <summary> list of digests computed for the PCR </summary>
    public: vector<TPMT_HA> results;

public:
    EventSequenceCompleteResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "EventSequenceCompleteResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {4, 66}; }
}; // class EventSequenceCompleteResponse

/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in
/// the TPM. By certifying that the object is loaded, the TPM warrants that a public area with
/// a given Name is self-consistent and associated with a valid sensitive area. If a relying
/// party has a public area that has the same Name as a Name certified with this command, then the
/// values in that public area are correct.
/// </summary>
class _DLLEXP_ TPM2_Certify_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE objectHandle;
    
    /// <summary>
    /// handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 qualifyingDataSize;
    
    /// <summary> user provided qualifying data </summary>
    public: ByteVec qualifyingData;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_Certify_REQUEST() {}
    TPM2_Certify_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : objectHandle(_objectHandle), signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Certify_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {objectHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Certify_REQUEST

/// <summary>
/// The purpose of this command is to prove that an object with a specific Name is loaded in
/// the TPM. By certifying that the object is loaded, the TPM warrants that a public area with
/// a given Name is self-consistent and associated with a valid sensitive area. If a relying
/// party has a public area that has the same Name as a Name certified with this command, then the
/// values in that public area are correct.
/// </summary>
class _DLLEXP_ CertifyResponse : public RespStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 certifyInfoSize;
    
    /// <summary> the structure that was signed </summary>
    public: TPMS_ATTEST certifyInfo;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the asymmetric signature over certifyInfo using the key referenced by signHandle
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    CertifyResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CertifyResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CertifyResponse

/// <summary>
/// This command is used to prove the association between an object and its creation data. The
/// TPM will validate that the ticket was produced by the TPM and that the ticket validates
/// the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
/// </summary>
class _DLLEXP_ TPM2_CertifyCreation_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the key that will sign the attestation block
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary>
    /// the object associated with the creation data
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE objectHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 qualifyingDataSize;
    
    /// <summary> user-provided qualifying data </summary>
    public: ByteVec qualifyingData;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 creationHashSize;
    
    /// <summary> hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary() </summary>
    public: ByteVec creationHash;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /// <summary> ticket produced by TPM2_Create() or TPM2_CreatePrimary() </summary>
    public: TPMT_TK_CREATION creationTicket;

public:
    TPM2_CertifyCreation_REQUEST() {}
    TPM2_CertifyCreation_REQUEST(const TPM_HANDLE& _signHandle, const TPM_HANDLE& _objectHandle, const ByteVec& _qualifyingData, const ByteVec& _creationHash, const TPMU_SIG_SCHEME& _inScheme, const TPMT_TK_CREATION& _creationTicket)
      : signHandle(_signHandle), objectHandle(_objectHandle), qualifyingData(_qualifyingData), creationHash(_creationHash), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), creationTicket(_creationTicket)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_CertifyCreation_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {signHandle, objectHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CertifyCreation_REQUEST

/// <summary>
/// This command is used to prove the association between an object and its creation data. The
/// TPM will validate that the ticket was produced by the TPM and that the ticket validates
/// the association between a loaded public area and the provided hash of the
/// creation data (creationHash).
/// </summary>
class _DLLEXP_ CertifyCreationResponse : public RespStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 certifyInfoSize;
    
    /// <summary> the structure that was signed </summary>
    public: TPMS_ATTEST certifyInfo;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the signature over certifyInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    CertifyCreationResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CertifyCreationResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CertifyCreationResponse

/// <summary> This command is used to quote PCR values. </summary>
class _DLLEXP_ TPM2_Quote_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of key that will perform signature
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 qualifyingDataSize;
    
    /// <summary> data supplied by the caller </summary>
    public: ByteVec qualifyingData;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 PCRselectCount;
    
    /// <summary> PCR set to quote </summary>
    public: vector<TPMS_PCR_SELECTION> PCRselect;

public:
    TPM2_Quote_REQUEST() {}
    TPM2_Quote_REQUEST(const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme, const vector<TPMS_PCR_SELECTION>& _PCRselect)
      : signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), PCRselect(_PCRselect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Quote_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Quote_REQUEST

/// <summary> This command is used to quote PCR values. </summary>
class _DLLEXP_ QuoteResponse : public RespStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 quotedSize;
    
    /// <summary> the quoted information </summary>
    public: TPMS_ATTEST quoted;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the signature over quoted
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    QuoteResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "QuoteResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class QuoteResponse

/// <summary> This command returns a digital signature of the audit session digest. </summary>
class _DLLEXP_ TPM2_GetSessionAuditDigest_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE privacyAdminHandle;
    
    /// <summary>
    /// handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary>
    /// handle of the audit session
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE sessionHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 qualifyingDataSize;
    
    /// <summary> user-provided qualifying data may be zero-length </summary>
    public: ByteVec qualifyingData;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_GetSessionAuditDigest_REQUEST() {}
    TPM2_GetSessionAuditDigest_REQUEST(const TPM_HANDLE& _privacyAdminHandle, const TPM_HANDLE& _signHandle, const TPM_HANDLE& _sessionHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : privacyAdminHandle(_privacyAdminHandle), signHandle(_signHandle), sessionHandle(_sessionHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_GetSessionAuditDigest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {privacyAdminHandle, signHandle, sessionHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_GetSessionAuditDigest_REQUEST

/// <summary> This command returns a digital signature of the audit session digest. </summary>
class _DLLEXP_ GetSessionAuditDigestResponse : public RespStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 auditInfoSize;
    
    /// <summary> the audit information that was signed </summary>
    public: TPMS_ATTEST auditInfo;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the signature over auditInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    GetSessionAuditDigestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "GetSessionAuditDigestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetSessionAuditDigestResponse

/// <summary>
/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
/// </summary>
class _DLLEXP_ TPM2_GetCommandAuditDigest_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE privacyHandle;
    
    /// <summary>
    /// the handle of the signing key
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 qualifyingDataSize;
    
    /// <summary> other data to associate with this audit digest </summary>
    public: ByteVec qualifyingData;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_GetCommandAuditDigest_REQUEST() {}
    TPM2_GetCommandAuditDigest_REQUEST(const TPM_HANDLE& _privacyHandle, const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : privacyHandle(_privacyHandle), signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_GetCommandAuditDigest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {privacyHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_GetCommandAuditDigest_REQUEST

/// <summary>
/// This command returns the current value of the command audit digest, a digest of the
/// commands being audited, and the audit hash algorithm. These values are placed in an
/// attestation structure and signed with the key referenced by signHandle.
/// </summary>
class _DLLEXP_ GetCommandAuditDigestResponse : public RespStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 auditInfoSize;
    
    /// <summary> the auditInfo that was signed </summary>
    public: TPMS_ATTEST auditInfo;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the signature over auditInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    GetCommandAuditDigestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "GetCommandAuditDigestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetCommandAuditDigestResponse

/// <summary> This command returns the current values of Time and Clock. </summary>
class _DLLEXP_ TPM2_GetTime_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the privacy administrator (TPM_RH_ENDORSEMENT)
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE privacyAdminHandle;
    
    /// <summary>
    /// the keyHandle identifier of a loaded key that can perform digital signatures
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 qualifyingDataSize;
    
    /// <summary> data to tick stamp </summary>
    public: ByteVec qualifyingData;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_GetTime_REQUEST() {}
    TPM2_GetTime_REQUEST(const TPM_HANDLE& _privacyAdminHandle, const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : privacyAdminHandle(_privacyAdminHandle), signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_GetTime_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {privacyAdminHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_GetTime_REQUEST

/// <summary> This command returns the current values of Time and Clock. </summary>
class _DLLEXP_ GetTimeResponse : public RespStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 timeInfoSize;
    
    /// <summary> standard TPM-generated attestation block </summary>
    public: TPMS_ATTEST timeInfo;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the signature over timeInfo
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    GetTimeResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "GetTimeResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetTimeResponse

/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with
/// a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify,
/// which uses a TCG-defined data structure to convey attestation information,
/// TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate
/// that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and
/// Certificate Revocation List (CRL) Profile.
/// </summary>
class _DLLEXP_ TPM2_CertifyX509_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the object to be certified
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE objectHandle;
    
    /// <summary>
    /// handle of the key used to sign the attestation structure
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 reservedSize;
    
    /// <summary> shall be an Empty Buffer </summary>
    public: ByteVec reserved;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 partialCertificateSize;
    
    /// <summary> a DER encoded partial certificate </summary>
    public: ByteVec partialCertificate;

public:
    TPM2_CertifyX509_REQUEST() {}
    TPM2_CertifyX509_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _signHandle, const ByteVec& _reserved, const TPMU_SIG_SCHEME& _inScheme, const ByteVec& _partialCertificate)
      : objectHandle(_objectHandle), signHandle(_signHandle), reserved(_reserved), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), partialCertificate(_partialCertificate)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_CertifyX509_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {objectHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CertifyX509_REQUEST

/// <summary>
/// The purpose of this command is to generate an X.509 certificate that proves an object with
/// a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify,
/// which uses a TCG-defined data structure to convey attestation information,
/// TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate
/// that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and
/// Certificate Revocation List (CRL) Profile.
/// </summary>
class _DLLEXP_ CertifyX509Response : public RespStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 addedToCertificateSize;
    
    /// <summary>
    /// a DER encoded SEQUENCE containing the DER encoded fields added to partialCertificate to make it a
    /// complete RFC5280 TBSCertificate.
    /// </summary>
    public: ByteVec addedToCertificate;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 tbsDigestSize;
    
    /// <summary> the digest that was signed </summary>
    public: ByteVec tbsDigest;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// The signature over tbsDigest
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    CertifyX509Response() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CertifyX509Response"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CertifyX509Response

/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will
/// perform the point multiplications on the provided points and return intermediate signing
/// values. The signHandle parameter shall refer to an ECC key and the signing scheme must
/// be anonymous (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ TPM2_Commit_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the key that will be used in the signing operation
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 P1Size;
    
    /// <summary> a point (M) on the curve used by signHandle </summary>
    public: TPMS_ECC_POINT P1;
    
    protected: mutable UINT16 s2Size;
    
    /// <summary> octet array used to derive x-coordinate of a base point </summary>
    public: ByteVec s2;
    
    /// <summary> size of buffer </summary>
    protected: mutable UINT16 y2Size;
    
    /// <summary> y coordinate of the point associated with s2 </summary>
    public: ByteVec y2;

public:
    TPM2_Commit_REQUEST() {}
    TPM2_Commit_REQUEST(const TPM_HANDLE& _signHandle, const TPMS_ECC_POINT& _P1, const ByteVec& _s2, const ByteVec& _y2)
      : signHandle(_signHandle), P1(_P1), s2(_s2), y2(_y2)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Commit_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Commit_REQUEST

/// <summary>
/// TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will
/// perform the point multiplications on the provided points and return intermediate signing
/// values. The signHandle parameter shall refer to an ECC key and the signing scheme must
/// be anonymous (TPM_RC_SCHEME).
/// </summary>
class _DLLEXP_ CommitResponse : public RespStructure
{
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 KSize;
    
    /// <summary> ECC point K [ds](x2, y2) </summary>
    public: TPMS_ECC_POINT K;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 LSize;
    
    /// <summary> ECC point L [r](x2, y2) </summary>
    public: TPMS_ECC_POINT L;
    
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 ESize;
    
    /// <summary> ECC point E [r]P1 </summary>
    public: TPMS_ECC_POINT E;
    
    /// <summary> least-significant 16 bits of commitCount </summary>
    public: UINT16 counter;

public:
    CommitResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CommitResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CommitResponse

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
class _DLLEXP_ TPM2_EC_Ephemeral_REQUEST : public ReqStructure
{
    /// <summary> The curve for the computed ephemeral point </summary>
    public: TPM_ECC_CURVE curveID;

public:
    TPM2_EC_Ephemeral_REQUEST() {}
    TPM2_EC_Ephemeral_REQUEST(TPM_ECC_CURVE _curveID)
      : curveID(_curveID)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_EC_Ephemeral_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_EC_Ephemeral_REQUEST

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
class _DLLEXP_ EC_EphemeralResponse : public RespStructure
{
    /// <summary> size of the remainder of this structure </summary>
    protected: mutable UINT16 QSize;
    
    /// <summary> ephemeral public key Q [r]G </summary>
    public: TPMS_ECC_POINT Q;
    
    /// <summary> least-significant 16 bits of commitCount </summary>
    public: UINT16 counter;

public:
    EC_EphemeralResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "EC_EphemeralResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class EC_EphemeralResponse

/// <summary>
/// This command uses loaded keys to validate a signature on a message with the
/// message digest passed to the TPM.
/// </summary>
class _DLLEXP_ TPM2_VerifySignature_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of public key that will be used in the validation
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 digestSize;
    
    /// <summary> digest of the signed message </summary>
    public: ByteVec digest;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// signature to be tested
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    TPM2_VerifySignature_REQUEST() {}
    TPM2_VerifySignature_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _digest, const TPMU_SIGNATURE& _signature)
      : keyHandle(_keyHandle), digest(_digest), signature(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_VerifySignature_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_VerifySignature_REQUEST

/// <summary>
/// This command uses loaded keys to validate a signature on a message with the
/// message digest passed to the TPM.
/// </summary>
class _DLLEXP_ VerifySignatureResponse : public RespStructure
{
    public: TPMT_TK_VERIFIED validation;

public:
    VerifySignatureResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "VerifySignatureResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class VerifySignatureResponse

/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
/// </summary>
class _DLLEXP_ TPM2_Sign_REQUEST : public ReqStructure
{
    /// <summary>
    /// Handle of key that will perform signing
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 digestSize;
    
    /// <summary> digest to be signed </summary>
    public: ByteVec digest;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /// <summary>
    /// proof that digest was created by the TPM
    /// If keyHandle is not a restricted signing key, then this may be a NULL Ticket
    /// with tag = TPM_ST_CHECKHASH.
    /// </summary>
    public: TPMT_TK_HASHCHECK validation;

public:
    TPM2_Sign_REQUEST() {}
    TPM2_Sign_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _digest, const TPMU_SIG_SCHEME& _inScheme, const TPMT_TK_HASHCHECK& _validation)
      : keyHandle(_keyHandle), digest(_digest), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), validation(_validation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Sign_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Sign_REQUEST

/// <summary>
/// This command causes the TPM to sign an externally provided hash with the specified
/// symmetric or asymmetric signing key.
/// </summary>
class _DLLEXP_ SignResponse : public RespStructure
{
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the signature
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    SignResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "SignResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class SignResponse

/// <summary>
/// This command may be used by the Privacy Administrator or platform to change the audit
/// status of a command or to set the hash algorithm used for the audit digest, but
/// not both at the same time.
/// </summary>
class _DLLEXP_ TPM2_SetCommandCodeAuditStatus_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    
    /// <summary> hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed </summary>
    public: TPM_ALG_ID auditAlg;
    
    /// <summary> number of commands in the commandCode list; may be 0 </summary>
    protected: mutable UINT32 setListCount;
    
    /// <summary> list of commands that will be added to those that will be audited </summary>
    public: vector<TPM_CC> setList;
    
    /// <summary> number of commands in the commandCode list; may be 0 </summary>
    protected: mutable UINT32 clearListCount;
    
    /// <summary> list of commands that will no longer be audited </summary>
    public: vector<TPM_CC> clearList;

public:
    TPM2_SetCommandCodeAuditStatus_REQUEST() { auditAlg = TPM_ALG_ID::_NULL; }
    TPM2_SetCommandCodeAuditStatus_REQUEST(const TPM_HANDLE& _auth, TPM_ALG_ID _auditAlg, const vector<TPM_CC>& _setList, const vector<TPM_CC>& _clearList)
      : auth(_auth), auditAlg(_auditAlg), setList(_setList), clearList(_clearList)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_SetCommandCodeAuditStatus_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_SetCommandCodeAuditStatus_REQUEST

/// <summary>
/// This command is used to cause an update to the indicated PCR. The digests parameter
/// contains one or more tagged digest values identified by an algorithm ID. For each digest,
/// the PCR associated with pcrHandle is Extended into the bank
/// identified by the tag (hashAlg).
/// </summary>
class _DLLEXP_ TPM2_PCR_Extend_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    
    /// <summary> number of digests in the list </summary>
    protected: mutable UINT32 digestsCount;
    
    /// <summary> list of tagged digest values to be extended </summary>
    public: vector<TPMT_HA> digests;

public:
    TPM2_PCR_Extend_REQUEST() {}
    TPM2_PCR_Extend_REQUEST(const TPM_HANDLE& _pcrHandle, const vector<TPMT_HA>& _digests)
      : pcrHandle(_pcrHandle), digests(_digests)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PCR_Extend_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 66}; }
}; // class TPM2_PCR_Extend_REQUEST

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
class _DLLEXP_ TPM2_PCR_Event_REQUEST : public ReqStructure
{
    /// <summary>
    /// Handle of the PCR
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    
    /// <summary> size of the operand buffer </summary>
    protected: mutable UINT16 eventDataSize;
    
    /// <summary> Event data in sized buffer </summary>
    public: ByteVec eventData;

public:
    TPM2_PCR_Event_REQUEST() {}
    TPM2_PCR_Event_REQUEST(const TPM_HANDLE& _pcrHandle, const ByteVec& _eventData)
      : pcrHandle(_pcrHandle), eventData(_eventData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PCR_Event_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PCR_Event_REQUEST

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
class _DLLEXP_ PCR_EventResponse : public RespStructure
{
    /// <summary> number of digests in the list </summary>
    protected: mutable UINT32 digestsCount;
    
    public: vector<TPMT_HA> digests;

public:
    PCR_EventResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "PCR_EventResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {4, 66}; }
}; // class PCR_EventResponse

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
class _DLLEXP_ TPM2_PCR_Read_REQUEST : public ReqStructure
{
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectionInCount;
    
    /// <summary> The selection of PCR to read </summary>
    public: vector<TPMS_PCR_SELECTION> pcrSelectionIn;

public:
    TPM2_PCR_Read_REQUEST() {}
    TPM2_PCR_Read_REQUEST(const vector<TPMS_PCR_SELECTION>& _pcrSelectionIn)
      : pcrSelectionIn(_pcrSelectionIn)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PCR_Read_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {4, 3}; }
}; // class TPM2_PCR_Read_REQUEST

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
class _DLLEXP_ PCR_ReadResponse : public RespStructure
{
    /// <summary> the current value of the PCR update counter </summary>
    public: UINT32 pcrUpdateCounter;
    
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrSelectionOutCount;
    
    /// <summary> the PCR in the returned list </summary>
    public: vector<TPMS_PCR_SELECTION> pcrSelectionOut;
    
    /// <summary> number of digests in the list, minimum is two for TPM2_PolicyOR(). </summary>
    protected: mutable UINT32 pcrValuesCount;
    
    /// <summary> the contents of the PCR indicated in pcrSelectOut- pcrSelection[] as tagged digests </summary>
    public: vector<TPM2B_DIGEST> pcrValues;

public:
    PCR_ReadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "PCR_ReadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class PCR_ReadResponse

/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command
/// requires Platform Authorization.
/// </summary>
class _DLLEXP_ TPM2_PCR_Allocate_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrAllocationCount;
    
    /// <summary> the requested allocation </summary>
    public: vector<TPMS_PCR_SELECTION> pcrAllocation;

public:
    TPM2_PCR_Allocate_REQUEST() {}
    TPM2_PCR_Allocate_REQUEST(const TPM_HANDLE& _authHandle, const vector<TPMS_PCR_SELECTION>& _pcrAllocation)
      : authHandle(_authHandle), pcrAllocation(_pcrAllocation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PCR_Allocate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 3}; }
}; // class TPM2_PCR_Allocate_REQUEST

/// <summary>
/// This command is used to set the desired PCR allocation of PCR and algorithms. This command
/// requires Platform Authorization.
/// </summary>
class _DLLEXP_ PCR_AllocateResponse : public RespStructure
{
    /// <summary> YES if the allocation succeeded </summary>
    public: BYTE allocationSuccess;
    
    /// <summary> maximum number of PCR that may be in a bank </summary>
    public: UINT32 maxPCR;
    
    /// <summary> number of octets required to satisfy the request </summary>
    public: UINT32 sizeNeeded;
    
    /// <summary> Number of octets available. Computed before the allocation. </summary>
    public: UINT32 sizeAvailable;

public:
    PCR_AllocateResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "PCR_AllocateResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class PCR_AllocateResponse

/// <summary>
/// This command is used to associate a policy with a PCR or group of PCR. The policy
/// determines the conditions under which a PCR may be extended or reset.
/// </summary>
class _DLLEXP_ TPM2_PCR_SetAuthPolicy_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authPolicySize;
    
    /// <summary> the desired authPolicy </summary>
    public: ByteVec authPolicy;
    
    /// <summary> the hash algorithm of the policy </summary>
    public: TPM_ALG_ID hashAlg;
    
    /// <summary> the PCR for which the policy is to be set </summary>
    public: TPM_HANDLE pcrNum;

public:
    TPM2_PCR_SetAuthPolicy_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_PCR_SetAuthPolicy_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _authPolicy, TPM_ALG_ID _hashAlg, const TPM_HANDLE& _pcrNum)
      : authHandle(_authHandle), authPolicy(_authPolicy), hashAlg(_hashAlg), pcrNum(_pcrNum)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PCR_SetAuthPolicy_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PCR_SetAuthPolicy_REQUEST

/// <summary> This command changes the authValue of a PCR or group of PCR. </summary>
class _DLLEXP_ TPM2_PCR_SetAuthValue_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for a PCR that may have an authorization value set
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authSize;
    
    /// <summary> the desired authorization value </summary>
    public: ByteVec auth;

public:
    TPM2_PCR_SetAuthValue_REQUEST() {}
    TPM2_PCR_SetAuthValue_REQUEST(const TPM_HANDLE& _pcrHandle, const ByteVec& _auth)
      : pcrHandle(_pcrHandle), auth(_auth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PCR_SetAuthValue_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PCR_SetAuthValue_REQUEST

/// <summary>
/// If the attribute of a PCR allows the PCR to be reset and proper authorization is provided,
/// then this command may be used to set the PCR in all banks to zero. The attributes of the
/// PCR may restrict the locality that can perform the reset operation.
/// </summary>
class _DLLEXP_ TPM2_PCR_Reset_REQUEST : public ReqStructure
{
    /// <summary>
    /// the PCR to reset
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE pcrHandle;

public:
    TPM2_PCR_Reset_REQUEST() {}
    TPM2_PCR_Reset_REQUEST(const TPM_HANDLE& _pcrHandle)
      : pcrHandle(_pcrHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_PCR_Reset_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
}; // class TPM2_PCR_Reset_REQUEST

/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a
/// signing key by including the Name of the signing key in the policyDigest
/// </summary>
class _DLLEXP_ TPM2_PolicySigned_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for a key that will validate the signature
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE authObject;
    
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceTPMSize;
    
    /// <summary>
    /// the policy nonce for the session
    /// This can be the Empty Buffer.
    /// </summary>
    public: ByteVec nonceTPM;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 cpHashASize;
    
    /// <summary>
    /// digest of the command parameters to which this authorization is limited
    /// This is not the cpHash for this command but the cpHash for the command to which this
    /// policy session will be applied. If it is not limited, the parameter
    /// will be the Empty Buffer.
    /// </summary>
    public: ByteVec cpHashA;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 policyRefSize;
    
    /// <summary>
    /// a reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    /// </summary>
    public: ByteVec policyRef;
    
    /// <summary>
    /// time when authorization will expire, measured in seconds from the time that nonceTPM was
    /// generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    /// </summary>
    public: INT32 expiration;
    public: TPM_ALG_ID get_authSigAlg() const { return auth ? auth->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID authSigAlg;
    
    /// <summary>
    /// signed authorization (not optional)
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> auth;

public:
    TPM2_PolicySigned_REQUEST() {}
    TPM2_PolicySigned_REQUEST(const TPM_HANDLE& _authObject, const TPM_HANDLE& _policySession, const ByteVec& _nonceTPM, const ByteVec& _cpHashA, const ByteVec& _policyRef, INT32 _expiration, const TPMU_SIGNATURE& _auth)
      : authObject(_authObject), policySession(_policySession), nonceTPM(_nonceTPM), cpHashA(_cpHashA), policyRef(_policyRef), expiration(_expiration), auth(dynamic_cast<TPMU_SIGNATURE*>(_auth.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicySigned_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authObject, policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicySigned_REQUEST

/// <summary>
/// This command includes a signed authorization in a policy. The command ties the policy to a
/// signing key by including the Name of the signing key in the policyDigest
/// </summary>
class _DLLEXP_ PolicySignedResponse : public RespStructure
{
    /// <summary> size of the timeout value </summary>
    protected: mutable UINT16 timeoutSize;
    
    /// <summary>
    /// implementation-specific time value, used to indicate to the TPM when the ticket expires
    /// NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
    /// </summary>
    public: ByteVec timeout;
    
    /// <summary>
    /// produced if the command succeeds and expiration in the command was non-zero; this ticket
    /// will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
    /// </summary>
    public: TPMT_TK_AUTH policyTicket;

public:
    PolicySignedResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "PolicySignedResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class PolicySignedResponse

/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
class _DLLEXP_ TPM2_PolicySecret_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for an entity providing the authorization
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceTPMSize;
    
    /// <summary>
    /// the policy nonce for the session
    /// This can be the Empty Buffer.
    /// </summary>
    public: ByteVec nonceTPM;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 cpHashASize;
    
    /// <summary>
    /// digest of the command parameters to which this authorization is limited
    /// This not the cpHash for this command but the cpHash for the command to which this policy
    /// session will be applied. If it is not limited, the parameter will be the Empty Buffer.
    /// </summary>
    public: ByteVec cpHashA;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 policyRefSize;
    
    /// <summary>
    /// a reference to a policy relating to the authorization may be the Empty Buffer
    /// Size is limited to be no larger than the nonce size supported on the TPM.
    /// </summary>
    public: ByteVec policyRef;
    
    /// <summary>
    /// time when authorization will expire, measured in seconds from the time that nonceTPM was
    /// generated
    /// If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
    /// </summary>
    public: INT32 expiration;

public:
    TPM2_PolicySecret_REQUEST() {}
    TPM2_PolicySecret_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _policySession, const ByteVec& _nonceTPM, const ByteVec& _cpHashA, const ByteVec& _policyRef, INT32 _expiration)
      : authHandle(_authHandle), policySession(_policySession), nonceTPM(_nonceTPM), cpHashA(_cpHashA), policyRef(_policyRef), expiration(_expiration)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicySecret_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicySecret_REQUEST

/// <summary>
/// This command includes a secret-based authorization to a policy. The caller proves
/// knowledge of the secret value using an authorization session using the authValue
/// associated with authHandle. A password session, an HMAC session, or a policy session
/// containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
/// </summary>
class _DLLEXP_ PolicySecretResponse : public RespStructure
{
    /// <summary> size of the timeout value </summary>
    protected: mutable UINT16 timeoutSize;
    
    /// <summary> implementation-specific time value used to indicate to the TPM when the ticket expires </summary>
    public: ByteVec timeout;
    
    /// <summary>
    /// produced if the command succeeds and expiration in the command was non-zero ( See 23.2.5).
    /// This ticket will use the TPMT_ST_AUTH_SECRET structure tag
    /// </summary>
    public: TPMT_TK_AUTH policyTicket;

public:
    PolicySecretResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "PolicySecretResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class PolicySecretResponse

/// <summary>
/// This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a
/// signed authorization. The ticket represents a validated authorization that had an
/// expiration time associated with it.
/// </summary>
class _DLLEXP_ TPM2_PolicyTicket_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size of the timeout value </summary>
    protected: mutable UINT16 timeoutSize;
    
    /// <summary>
    /// time when authorization will expire
    /// The contents are TPM specific. This shall be the value returned when ticket was produced.
    /// </summary>
    public: ByteVec timeout;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 cpHashASize;
    
    /// <summary>
    /// digest of the command parameters to which this authorization is limited
    /// If it is not limited, the parameter will be the Empty Buffer.
    /// </summary>
    public: ByteVec cpHashA;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 policyRefSize;
    
    /// <summary> reference to a qualifier for the policy may be the Empty Buffer </summary>
    public: ByteVec policyRef;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 authNameSize;
    
    /// <summary> name of the object that provided the authorization </summary>
    public: ByteVec authName;
    
    /// <summary>
    /// an authorization ticket returned by the TPM in response to a
    /// TPM2_PolicySigned() or TPM2_PolicySecret()
    /// </summary>
    public: TPMT_TK_AUTH ticket;

public:
    TPM2_PolicyTicket_REQUEST() {}
    TPM2_PolicyTicket_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _timeout, const ByteVec& _cpHashA, const ByteVec& _policyRef, const ByteVec& _authName, const TPMT_TK_AUTH& _ticket)
      : policySession(_policySession), timeout(_timeout), cpHashA(_cpHashA), policyRef(_policyRef), authName(_authName), ticket(_ticket)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyTicket_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyTicket_REQUEST

/// <summary>
/// This command allows options in authorizations without requiring that the TPM evaluate all
/// of the options. If a policy may be satisfied by different sets of conditions, the TPM need
/// only evaluate one set that satisfies the policy. This command will indicate that one of
/// the required sets of conditions has been satisfied.
/// </summary>
class _DLLEXP_ TPM2_PolicyOR_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> number of digests in the list, minimum is two for TPM2_PolicyOR(). </summary>
    protected: mutable UINT32 pHashListCount;
    
    /// <summary> the list of hashes to check for a match </summary>
    public: vector<TPM2B_DIGEST> pHashList;

public:
    TPM2_PolicyOR_REQUEST() {}
    TPM2_PolicyOR_REQUEST(const TPM_HANDLE& _policySession, const vector<TPM2B_DIGEST>& _pHashList)
      : policySession(_policySession), pHashList(_pHashList)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyOR_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 2}; }
}; // class TPM2_PolicyOR_REQUEST

/// <summary>
/// This command is used to cause conditional gating of a policy based on PCR. This command
/// together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in
/// one state and a different set of authorizations when the PCR are in a different state.
/// </summary>
class _DLLEXP_ TPM2_PolicyPCR_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 pcrDigestSize;
    
    /// <summary>
    /// expected digest value of the selected PCR using the hash algorithm of the
    /// session; may be zero length
    /// </summary>
    public: ByteVec pcrDigest;
    
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 pcrsCount;
    
    /// <summary> the PCR to include in the check digest </summary>
    public: vector<TPMS_PCR_SELECTION> pcrs;

public:
    TPM2_PolicyPCR_REQUEST() {}
    TPM2_PolicyPCR_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _pcrDigest, const vector<TPMS_PCR_SELECTION>& _pcrs)
      : policySession(_policySession), pcrDigest(_pcrDigest), pcrs(_pcrs)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyPCR_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyPCR_REQUEST

/// <summary> This command indicates that the authorization will be limited to a specific locality. </summary>
class _DLLEXP_ TPM2_PolicyLocality_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> the allowed localities for the policy </summary>
    public: TPMA_LOCALITY locality;

public:
    TPM2_PolicyLocality_REQUEST() {}
    TPM2_PolicyLocality_REQUEST(const TPM_HANDLE& _policySession, TPMA_LOCALITY _locality)
      : policySession(_policySession), locality(_locality)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyLocality_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyLocality_REQUEST

/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of an
/// NV Index. It is an immediate assertion. The NV index is validated during the
/// TPM2_PolicyNV() command, not when the session is used for authorization.
/// </summary>
class _DLLEXP_ TPM2_PolicyNV_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index of the area to read
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 operandBSize;
    
    /// <summary> the second operand </summary>
    public: ByteVec operandB;
    
    /// <summary> the octet offset in the NV Index for the start of operand A </summary>
    public: UINT16 offset;
    
    /// <summary> the comparison to make </summary>
    public: TPM_EO operation;

public:
    TPM2_PolicyNV_REQUEST() {}
    TPM2_PolicyNV_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const TPM_HANDLE& _policySession, const ByteVec& _operandB, UINT16 _offset, TPM_EO _operation)
      : authHandle(_authHandle), nvIndex(_nvIndex), policySession(_policySession), operandB(_operandB), offset(_offset), operation(_operation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyNV_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex, policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyNV_REQUEST

/// <summary>
/// This command is used to cause conditional gating of a policy based on the contents of
/// the TPMS_TIME_INFO structure.
/// </summary>
class _DLLEXP_ TPM2_PolicyCounterTimer_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 operandBSize;
    
    /// <summary> the second operand </summary>
    public: ByteVec operandB;
    
    /// <summary> the octet offset in the TPMS_TIME_INFO structure for the start of operand A </summary>
    public: UINT16 offset;
    
    /// <summary> the comparison to make </summary>
    public: TPM_EO operation;

public:
    TPM2_PolicyCounterTimer_REQUEST() {}
    TPM2_PolicyCounterTimer_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _operandB, UINT16 _offset, TPM_EO _operation)
      : policySession(_policySession), operandB(_operandB), offset(_offset), operation(_operation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyCounterTimer_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyCounterTimer_REQUEST

/// <summary> This command indicates that the authorization will be limited to a specific command code. </summary>
class _DLLEXP_ TPM2_PolicyCommandCode_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> the allowed commandCode </summary>
    public: TPM_CC code;

public:
    TPM2_PolicyCommandCode_REQUEST() {}
    TPM2_PolicyCommandCode_REQUEST(const TPM_HANDLE& _policySession, TPM_CC _code)
      : policySession(_policySession), code(_code)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyCommandCode_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyCommandCode_REQUEST

/// <summary>
/// This command indicates that physical presence will need to be asserted at the time
/// the authorization is performed.
/// </summary>
class _DLLEXP_ TPM2_PolicyPhysicalPresence_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;

public:
    TPM2_PolicyPhysicalPresence_REQUEST() {}
    TPM2_PolicyPhysicalPresence_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    virtual const char* TypeName () const { return "TPM2_PolicyPhysicalPresence_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyPhysicalPresence_REQUEST

/// <summary>
/// This command is used to allow a policy to be bound to a specific command
/// and command parameters.
/// </summary>
class _DLLEXP_ TPM2_PolicyCpHash_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 cpHashASize;
    
    /// <summary> the cpHash added to the policy </summary>
    public: ByteVec cpHashA;

public:
    TPM2_PolicyCpHash_REQUEST() {}
    TPM2_PolicyCpHash_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _cpHashA)
      : policySession(_policySession), cpHashA(_cpHashA)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyCpHash_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyCpHash_REQUEST

/// <summary>
/// This command allows a policy to be bound to a specific set of TPM entities without being
/// bound to the parameters of the command. This is most useful for commands such as
/// TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
/// </summary>
class _DLLEXP_ TPM2_PolicyNameHash_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nameHashSize;
    
    /// <summary> the digest to be added to the policy </summary>
    public: ByteVec nameHash;

public:
    TPM2_PolicyNameHash_REQUEST() {}
    TPM2_PolicyNameHash_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _nameHash)
      : policySession(_policySession), nameHash(_nameHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyNameHash_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyNameHash_REQUEST

/// <summary>
/// This command allows qualification of duplication to allow duplication
/// to a selected new parent.
/// </summary>
class _DLLEXP_ TPM2_PolicyDuplicationSelect_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 objectNameSize;
    
    /// <summary> the Name of the object to be duplicated </summary>
    public: ByteVec objectName;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 newParentNameSize;
    
    /// <summary> the Name of the new parent </summary>
    public: ByteVec newParentName;
    
    /// <summary> if YES, the objectName will be included in the value in policySessionpolicyDigest </summary>
    public: BYTE includeObject;

public:
    TPM2_PolicyDuplicationSelect_REQUEST() {}
    TPM2_PolicyDuplicationSelect_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _objectName, const ByteVec& _newParentName, BYTE _includeObject)
      : policySession(_policySession), objectName(_objectName), newParentName(_newParentName), includeObject(_includeObject)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyDuplicationSelect_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyDuplicationSelect_REQUEST

/// <summary>
/// This command allows policies to change. If a policy were static, then it would be
/// difficult to add users to a policy. This command lets a policy authority sign a new policy
/// so that it may be used in an existing policy.
/// </summary>
class _DLLEXP_ TPM2_PolicyAuthorize_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 approvedPolicySize;
    
    /// <summary> digest of the policy being approved </summary>
    public: ByteVec approvedPolicy;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 policyRefSize;
    
    /// <summary> a policy qualifier </summary>
    public: ByteVec policyRef;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 keySignSize;
    
    /// <summary> Name of a key that can sign a policy addition </summary>
    public: ByteVec keySign;
    
    /// <summary> ticket validating that approvedPolicy and policyRef were signed by keySign </summary>
    public: TPMT_TK_VERIFIED checkTicket;

public:
    TPM2_PolicyAuthorize_REQUEST() {}
    TPM2_PolicyAuthorize_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _approvedPolicy, const ByteVec& _policyRef, const ByteVec& _keySign, const TPMT_TK_VERIFIED& _checkTicket)
      : policySession(_policySession), approvedPolicy(_approvedPolicy), policyRef(_policyRef), keySign(_keySign), checkTicket(_checkTicket)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyAuthorize_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyAuthorize_REQUEST

/// <summary>
/// This command allows a policy to be bound to the authorization value
/// of the authorized entity.
/// </summary>
class _DLLEXP_ TPM2_PolicyAuthValue_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;

public:
    TPM2_PolicyAuthValue_REQUEST() {}
    TPM2_PolicyAuthValue_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    virtual const char* TypeName () const { return "TPM2_PolicyAuthValue_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyAuthValue_REQUEST

/// <summary>
/// This command allows a policy to be bound to the authorization value
/// of the authorized object.
/// </summary>
class _DLLEXP_ TPM2_PolicyPassword_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;

public:
    TPM2_PolicyPassword_REQUEST() {}
    TPM2_PolicyPassword_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    virtual const char* TypeName () const { return "TPM2_PolicyPassword_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyPassword_REQUEST

/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM
/// to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
class _DLLEXP_ TPM2_PolicyGetDigest_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;

public:
    TPM2_PolicyGetDigest_REQUEST() {}
    TPM2_PolicyGetDigest_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    virtual const char* TypeName () const { return "TPM2_PolicyGetDigest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyGetDigest_REQUEST

/// <summary>
/// This command returns the current policyDigest of the session. This command allows the TPM
/// to be used to perform the actions required to pre-compute the authPolicy for an object.
/// </summary>
class _DLLEXP_ PolicyGetDigestResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 policyDigestSize;
    
    /// <summary> the current value of the policySessionpolicyDigest </summary>
    public: ByteVec policyDigest;

public:
    PolicyGetDigestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "PolicyGetDigestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class PolicyGetDigestResponse

/// <summary>
/// This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
/// deferred assertion. Values are stored in the policy session context and checked when the
/// policy is used for authorization.
/// </summary>
class _DLLEXP_ TPM2_PolicyNvWritten_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary>
    /// YES if NV Index is required to have been written
    /// NO if NV Index is required not to have been written
    /// </summary>
    public: BYTE writtenSet;

public:
    TPM2_PolicyNvWritten_REQUEST() {}
    TPM2_PolicyNvWritten_REQUEST(const TPM_HANDLE& _policySession, BYTE _writtenSet)
      : policySession(_policySession), writtenSet(_writtenSet)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyNvWritten_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyNvWritten_REQUEST

/// <summary>
/// This command allows a policy to be bound to a specific creation template. This is most
/// useful for an object creation command such as TPM2_Create(),
/// TPM2_CreatePrimary(), or TPM2_CreateLoaded().
/// </summary>
class _DLLEXP_ TPM2_PolicyTemplate_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 templateHashSize;
    
    /// <summary> the digest to be added to the policy </summary>
    public: ByteVec templateHash;

public:
    TPM2_PolicyTemplate_REQUEST() {}
    TPM2_PolicyTemplate_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _templateHash)
      : policySession(_policySession), templateHash(_templateHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PolicyTemplate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyTemplate_REQUEST

/// <summary>
/// This command provides a capability that is the equivalent of a revocable policy. With
/// TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may
/// not be withdrawn. With this command, the approved policy is kept in an NV Index location
/// so that the policy may be changed as needed to render the old policy unusable.
/// </summary>
class _DLLEXP_ TPM2_PolicyAuthorizeNV_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index of the area to read
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;

public:
    TPM2_PolicyAuthorizeNV_REQUEST() {}
    TPM2_PolicyAuthorizeNV_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const TPM_HANDLE& _policySession)
      : authHandle(_authHandle), nvIndex(_nvIndex), policySession(_policySession)
    {}
    
    virtual const char* TypeName () const { return "TPM2_PolicyAuthorizeNV_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex, policySession}; }
}; // class TPM2_PolicyAuthorizeNV_REQUEST

/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the
/// object to be created. The size of the unique field shall not be checked for consistency
/// with the other object parameters. The command will create and load a Primary Object. The
/// sensitive area is not returned.
/// </summary>
class _DLLEXP_ TPM2_CreatePrimary_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE primaryHandle;
    
    /// <summary>
    /// size of sensitive in octets (may not be zero)
    /// NOTE The userAuth and data parameters in this buffer may both be zero length but the
    /// minimum size of this parameter will be the sum of the size fields of the two parameters
    /// of the TPMS_SENSITIVE_CREATE.
    /// </summary>
    protected: mutable UINT16 inSensitiveSize;
    
    /// <summary> the sensitive data, see TPM 2.0 Part 1 Sensitive Values </summary>
    public: TPMS_SENSITIVE_CREATE inSensitive;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 inPublicSize;
    
    /// <summary> the public template </summary>
    public: TPMT_PUBLIC inPublic;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 outsideInfoSize;
    
    /// <summary>
    /// data that will be included in the creation data for this object to provide permanent,
    /// verifiable linkage between this object and some object owner data
    /// </summary>
    public: ByteVec outsideInfo;
    
    /// <summary>
    /// number of selection structures
    /// A value of zero is allowed.
    /// </summary>
    protected: mutable UINT32 creationPCRCount;
    
    /// <summary> PCR that will be used in creation data </summary>
    public: vector<TPMS_PCR_SELECTION> creationPCR;

public:
    TPM2_CreatePrimary_REQUEST() {}
    TPM2_CreatePrimary_REQUEST(const TPM_HANDLE& _primaryHandle, const TPMS_SENSITIVE_CREATE& _inSensitive, const TPMT_PUBLIC& _inPublic, const ByteVec& _outsideInfo, const vector<TPMS_PCR_SELECTION>& _creationPCR)
      : primaryHandle(_primaryHandle), inSensitive(_inSensitive), inPublic(_inPublic), outsideInfo(_outsideInfo), creationPCR(_creationPCR)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_CreatePrimary_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {primaryHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CreatePrimary_REQUEST

/// <summary>
/// This command is used to create a Primary Object under one of the Primary Seeds or a
/// Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the
/// object to be created. The size of the unique field shall not be checked for consistency
/// with the other object parameters. The command will create and load a Primary Object. The
/// sensitive area is not returned.
/// </summary>
class _DLLEXP_ CreatePrimaryResponse : public RespStructure
{
    /// <summary> handle of type TPM_HT_TRANSIENT for created Primary Object </summary>
    public: TPM_HANDLE handle;
    
    /// <summary>
    /// size of publicArea
    /// NOTE The = will force the TPM to try to unmarshal a TPMT_PUBLIC and check that the
    /// unmarshaled size matches the value of size. If all the required fields of a TPMT_PUBLIC
    /// are not present, the TPM will return an error (generally TPM_RC_SIZE) when attempting
    /// to unmarshal the TPMT_PUBLIC.
    /// </summary>
    protected: mutable UINT16 outPublicSize;
    
    /// <summary> the public portion of the created object </summary>
    public: TPMT_PUBLIC outPublic;
    
    /// <summary> size of the creation data </summary>
    protected: mutable UINT16 creationDataSize;
    
    /// <summary> contains a TPMT_CREATION_DATA </summary>
    public: TPMS_CREATION_DATA creationData;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 creationHashSize;
    
    /// <summary> digest of creationData using nameAlg of outPublic </summary>
    public: ByteVec creationHash;
    
    /// <summary>
    /// ticket used by TPM2_CertifyCreation() to validate that the creation data
    /// was produced by the TPM
    /// </summary>
    public: TPMT_TK_CREATION creationTicket;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nameSize;
    
    /// <summary> the name of the created object </summary>
    public: ByteVec name;

public:
    CreatePrimaryResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CreatePrimaryResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CreatePrimaryResponse

/// <summary>
/// This command enables and disables use of a hierarchy and its associated NV storage. The
/// command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the
/// proper authorization is provided.
/// </summary>
class _DLLEXP_ TPM2_HierarchyControl_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the enable being modified
    /// TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
    /// </summary>
    public: TPM_HANDLE enable;
    
    /// <summary> YES if the enable should be SET, NO if the enable should be CLEAR </summary>
    public: BYTE state;

public:
    TPM2_HierarchyControl_REQUEST() {}
    TPM2_HierarchyControl_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _enable, BYTE _state)
      : authHandle(_authHandle), enable(_enable), state(_state)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_HierarchyControl_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_HierarchyControl_REQUEST

/// <summary>
/// This command allows setting of the authorization policy for the lockout (lockoutPolicy),
/// the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the
/// endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown
/// Timers (ACT), this command may also be used to set the authorization policy for an ACT.
/// </summary>
class _DLLEXP_ TPM2_SetPrimaryPolicy_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authPolicySize;
    
    /// <summary>
    /// an authorization policy digest; may be the Empty Buffer
    /// If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
    /// </summary>
    public: ByteVec authPolicy;
    
    /// <summary>
    /// the hash algorithm to use for the policy
    /// If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    /// </summary>
    public: TPM_ALG_ID hashAlg;

public:
    TPM2_SetPrimaryPolicy_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_SetPrimaryPolicy_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _authPolicy, TPM_ALG_ID _hashAlg)
      : authHandle(_authHandle), authPolicy(_authPolicy), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_SetPrimaryPolicy_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_SetPrimaryPolicy_REQUEST

/// <summary>
/// This replaces the current platform primary seed (PPS) with a value from the RNG and sets
/// platformPolicy to the default initialization value (the Empty Buffer).
/// </summary>
class _DLLEXP_ TPM2_ChangePPS_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;

public:
    TPM2_ChangePPS_REQUEST() {}
    TPM2_ChangePPS_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_ChangePPS_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_ChangePPS_REQUEST

/// <summary>
/// This replaces the current endorsement primary seed (EPS) with a value from the RNG and
/// sets the Endorsement hierarchy controls to their default initialization values: ehEnable
/// is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will
/// flush any resident objects (transient or persistent) in the Endorsement hierarchy and not
/// allow objects in the hierarchy associated with the previous EPS to be loaded.
/// </summary>
class _DLLEXP_ TPM2_ChangeEPS_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;

public:
    TPM2_ChangeEPS_REQUEST() {}
    TPM2_ChangeEPS_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_ChangeEPS_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_ChangeEPS_REQUEST

/// <summary> This command removes all TPM context associated with a specific Owner. </summary>
class _DLLEXP_ TPM2_Clear_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;

public:
    TPM2_Clear_REQUEST() {}
    TPM2_Clear_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_Clear_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_Clear_REQUEST

/// <summary> TPM2_ClearControl() disables and enables the execution of TPM2_Clear(). </summary>
class _DLLEXP_ TPM2_ClearControl_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    
    /// <summary> YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR. </summary>
    public: BYTE disable;

public:
    TPM2_ClearControl_REQUEST() {}
    TPM2_ClearControl_REQUEST(const TPM_HANDLE& _auth, BYTE _disable)
      : auth(_auth), disable(_disable)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ClearControl_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_ClearControl_REQUEST

/// <summary>
/// This command allows the authorization secret for a hierarchy or lockout to be changed
/// using the current authorization value as the command authorization.
/// </summary>
class _DLLEXP_ TPM2_HierarchyChangeAuth_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 newAuthSize;
    
    /// <summary> new authorization value </summary>
    public: ByteVec newAuth;

public:
    TPM2_HierarchyChangeAuth_REQUEST() {}
    TPM2_HierarchyChangeAuth_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _newAuth)
      : authHandle(_authHandle), newAuth(_newAuth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_HierarchyChangeAuth_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HierarchyChangeAuth_REQUEST

/// <summary>
/// This command cancels the effect of a TPM lockout due to a number of successive
/// authorization failures. If this command is properly authorized, the
/// lockout counter is set to zero.
/// </summary>
class _DLLEXP_ TPM2_DictionaryAttackLockReset_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE lockHandle;

public:
    TPM2_DictionaryAttackLockReset_REQUEST() {}
    TPM2_DictionaryAttackLockReset_REQUEST(const TPM_HANDLE& _lockHandle)
      : lockHandle(_lockHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_DictionaryAttackLockReset_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {lockHandle}; }
}; // class TPM2_DictionaryAttackLockReset_REQUEST

/// <summary> This command changes the lockout parameters. </summary>
class _DLLEXP_ TPM2_DictionaryAttackParameters_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_LOCKOUT
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE lockHandle;
    
    /// <summary> count of authorization failures before the lockout is imposed </summary>
    public: UINT32 newMaxTries;
    
    /// <summary>
    /// time in seconds before the authorization failure count is automatically decremented
    /// A value of zero indicates that DA protection is disabled.
    /// </summary>
    public: UINT32 newRecoveryTime;
    
    /// <summary>
    /// time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
    /// A value of zero indicates that a reboot is required.
    /// </summary>
    public: UINT32 lockoutRecovery;

public:
    TPM2_DictionaryAttackParameters_REQUEST() {}
    TPM2_DictionaryAttackParameters_REQUEST(const TPM_HANDLE& _lockHandle, UINT32 _newMaxTries, UINT32 _newRecoveryTime, UINT32 _lockoutRecovery)
      : lockHandle(_lockHandle), newMaxTries(_newMaxTries), newRecoveryTime(_newRecoveryTime), lockoutRecovery(_lockoutRecovery)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_DictionaryAttackParameters_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {lockHandle}; }
}; // class TPM2_DictionaryAttackParameters_REQUEST

/// <summary>
/// This command is used to determine which commands require assertion of Physical Presence
/// (PP) in addition to platformAuth/platformPolicy.
/// </summary>
class _DLLEXP_ TPM2_PP_Commands_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_PLATFORM+PP
    /// Auth Index: 1
    /// Auth Role: USER + Physical Presence
    /// </summary>
    public: TPM_HANDLE auth;
    
    /// <summary> number of commands in the commandCode list; may be 0 </summary>
    protected: mutable UINT32 setListCount;
    
    /// <summary> list of commands to be added to those that will require that Physical Presence be asserted </summary>
    public: vector<TPM_CC> setList;
    
    /// <summary> number of commands in the commandCode list; may be 0 </summary>
    protected: mutable UINT32 clearListCount;
    
    /// <summary> list of commands that will no longer require that Physical Presence be asserted </summary>
    public: vector<TPM_CC> clearList;

public:
    TPM2_PP_Commands_REQUEST() {}
    TPM2_PP_Commands_REQUEST(const TPM_HANDLE& _auth, const vector<TPM_CC>& _setList, const vector<TPM_CC>& _clearList)
      : auth(_auth), setList(_setList), clearList(_clearList)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_PP_Commands_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {auth}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 4}; }
}; // class TPM2_PP_Commands_REQUEST

/// <summary>
/// This command allows the platform to change the set of algorithms that are used by the TPM.
/// The algorithmSet setting is a vendor-dependent value.
/// </summary>
class _DLLEXP_ TPM2_SetAlgorithmSet_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_PLATFORM
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary> a TPM vendor-dependent value indicating the algorithm set selection </summary>
    public: UINT32 algorithmSet;

public:
    TPM2_SetAlgorithmSet_REQUEST() {}
    TPM2_SetAlgorithmSet_REQUEST(const TPM_HANDLE& _authHandle, UINT32 _algorithmSet)
      : authHandle(_authHandle), algorithmSet(_algorithmSet)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_SetAlgorithmSet_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_SetAlgorithmSet_REQUEST

/// <summary>
/// This command uses platformPolicy and a TPM Vendor Authorization Key to
/// authorize a Field Upgrade Manifest.
/// </summary>
class _DLLEXP_ TPM2_FieldUpgradeStart_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_PLATFORM+{PP}
    /// Auth Index:1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE authorization;
    
    /// <summary>
    /// handle of a public area that contains the TPM Vendor Authorization Key that will be used
    /// to validate manifestSignature
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE keyHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 fuDigestSize;
    
    /// <summary> digest of the first block in the field upgrade sequence </summary>
    public: ByteVec fuDigest;
    public: TPM_ALG_ID get_manifestSignatureSigAlg() const { return manifestSignature ? manifestSignature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID manifestSignatureSigAlg;
    
    /// <summary>
    /// signature over fuDigest using the key associated with keyHandle (not optional)
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> manifestSignature;

public:
    TPM2_FieldUpgradeStart_REQUEST() {}
    TPM2_FieldUpgradeStart_REQUEST(const TPM_HANDLE& _authorization, const TPM_HANDLE& _keyHandle, const ByteVec& _fuDigest, const TPMU_SIGNATURE& _manifestSignature)
      : authorization(_authorization), keyHandle(_keyHandle), fuDigest(_fuDigest), manifestSignature(dynamic_cast<TPMU_SIGNATURE*>(_manifestSignature.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_FieldUpgradeStart_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authorization, keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_FieldUpgradeStart_REQUEST

/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
class _DLLEXP_ TPM2_FieldUpgradeData_REQUEST : public ReqStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 fuDataSize;
    
    /// <summary> field upgrade image data </summary>
    public: ByteVec fuData;

public:
    TPM2_FieldUpgradeData_REQUEST() {}
    TPM2_FieldUpgradeData_REQUEST(const ByteVec& _fuData)
      : fuData(_fuData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_FieldUpgradeData_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_FieldUpgradeData_REQUEST

/// <summary>
/// This command will take the actual field upgrade image to be installed on the TPM. The
/// exact format of fuData is vendor-specific. This command is only possible following a
/// successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
/// TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
/// </summary>
class _DLLEXP_ FieldUpgradeDataResponse : public RespStructure
{
    /// <summary>
    /// tagged digest of the next block
    /// TPM_ALG_NULL if field update is complete
    /// </summary>
    public: TPMT_HA nextDigest;
    
    /// <summary> tagged digest of the first block of the sequence </summary>
    public: TPMT_HA firstDigest;

public:
    FieldUpgradeDataResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "FieldUpgradeDataResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class FieldUpgradeDataResponse

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
class _DLLEXP_ TPM2_FirmwareRead_REQUEST : public ReqStructure
{
    /// <summary>
    /// the number of previous calls to this command in this sequence
    /// set to 0 on the first call
    /// </summary>
    public: UINT32 sequenceNumber;

public:
    TPM2_FirmwareRead_REQUEST() {}
    TPM2_FirmwareRead_REQUEST(UINT32 _sequenceNumber)
      : sequenceNumber(_sequenceNumber)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_FirmwareRead_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_FirmwareRead_REQUEST

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
class _DLLEXP_ FirmwareReadResponse : public RespStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 fuDataSize;
    
    /// <summary> field upgrade image data </summary>
    public: ByteVec fuData;

public:
    FirmwareReadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "FirmwareReadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class FirmwareReadResponse

/// <summary>
/// This command saves a session context, object context, or sequence object
/// context outside the TPM.
/// </summary>
class _DLLEXP_ TPM2_ContextSave_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the resource to save
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE saveHandle;

public:
    TPM2_ContextSave_REQUEST() {}
    TPM2_ContextSave_REQUEST(const TPM_HANDLE& _saveHandle)
      : saveHandle(_saveHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_ContextSave_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {saveHandle}; }
}; // class TPM2_ContextSave_REQUEST

/// <summary>
/// This command saves a session context, object context, or sequence object
/// context outside the TPM.
/// </summary>
class _DLLEXP_ ContextSaveResponse : public RespStructure
{
    public: TPMS_CONTEXT context;

public:
    ContextSaveResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ContextSaveResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class ContextSaveResponse

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
class _DLLEXP_ TPM2_ContextLoad_REQUEST : public ReqStructure
{
    /// <summary> the context blob </summary>
    public: TPMS_CONTEXT context;

public:
    TPM2_ContextLoad_REQUEST() {}
    TPM2_ContextLoad_REQUEST(const TPMS_CONTEXT& _context)
      : context(_context)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ContextLoad_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_ContextLoad_REQUEST

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
class _DLLEXP_ ContextLoadResponse : public RespStructure
{
    /// <summary> the handle assigned to the resource after it has been successfully loaded </summary>
    public: TPM_HANDLE handle;

public:
    ContextLoadResponse() {}
    
    virtual const char* TypeName () const { return "ContextLoadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class ContextLoadResponse

/// <summary>
/// This command causes all context associated with a loaded object, sequence object, or session
/// to be removed from TPM memory.
/// </summary>
class _DLLEXP_ TPM2_FlushContext_REQUEST : public ReqStructure
{
    /// <summary>
    /// the handle of the item to flush
    /// NOTE This is a use of a handle as a parameter.
    /// </summary>
    public: TPM_HANDLE flushHandle;

public:
    TPM2_FlushContext_REQUEST() {}
    TPM2_FlushContext_REQUEST(const TPM_HANDLE& _flushHandle)
      : flushHandle(_flushHandle)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_FlushContext_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_FlushContext_REQUEST

/// <summary>
/// This command allows certain Transient Objects to be made persistent or a
/// persistent object to be evicted.
/// </summary>
class _DLLEXP_ TPM2_EvictControl_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    
    /// <summary>
    /// the handle of a loaded object
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE objectHandle;
    
    /// <summary>
    /// if objectHandle is a transient object handle, then this is the persistent handle for the
    /// object
    /// if objectHandle is a persistent object handle, then it shall be the same value
    /// as persistentHandle
    /// </summary>
    public: TPM_HANDLE persistentHandle;

public:
    TPM2_EvictControl_REQUEST() {}
    TPM2_EvictControl_REQUEST(const TPM_HANDLE& _auth, const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _persistentHandle)
      : auth(_auth), objectHandle(_objectHandle), persistentHandle(_persistentHandle)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_EvictControl_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {auth, objectHandle}; }
}; // class TPM2_EvictControl_REQUEST

/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting
/// of Time, Clock, resetCount, and restartCount.
/// </summary>
class _DLLEXP_ TPM2_ReadClock_REQUEST : public ReqStructure
{
public:
    TPM2_ReadClock_REQUEST() {}
    
    virtual const char* TypeName () const { return "TPM2_ReadClock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_ReadClock_REQUEST

/// <summary>
/// This command reads the current TPMS_TIME_INFO structure that contains the current setting
/// of Time, Clock, resetCount, and restartCount.
/// </summary>
class _DLLEXP_ ReadClockResponse : public RespStructure
{
    public: TPMS_TIME_INFO currentTime;

public:
    ReadClockResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "ReadClockResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class ReadClockResponse

/// <summary>
/// This command is used to advance the value of the TPMs Clock. The command will fail if
/// newTime is less than the current value of Clock or if the new time is greater than
/// FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of
/// these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
/// </summary>
class _DLLEXP_ TPM2_ClockSet_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    
    /// <summary> new Clock setting in milliseconds </summary>
    public: UINT64 newTime;

public:
    TPM2_ClockSet_REQUEST() {}
    TPM2_ClockSet_REQUEST(const TPM_HANDLE& _auth, UINT64 _newTime)
      : auth(_auth), newTime(_newTime)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ClockSet_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_ClockSet_REQUEST

/// <summary>
/// This command adjusts the rate of advance of Clock and Time to provide a better
/// approximation to real time.
/// </summary>
class _DLLEXP_ TPM2_ClockRateAdjust_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Handle: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE auth;
    
    /// <summary> Adjustment to current Clock update rate </summary>
    public: TPM_CLOCK_ADJUST rateAdjust;

public:
    TPM2_ClockRateAdjust_REQUEST() {}
    TPM2_ClockRateAdjust_REQUEST(const TPM_HANDLE& _auth, TPM_CLOCK_ADJUST _rateAdjust)
      : auth(_auth), rateAdjust(_rateAdjust)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ClockRateAdjust_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_ClockRateAdjust_REQUEST

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
class _DLLEXP_ TPM2_GetCapability_REQUEST : public ReqStructure
{
    /// <summary> group selection; determines the format of the response </summary>
    public: TPM_CAP capability;
    
    /// <summary> further definition of information </summary>
    public: UINT32 property;
    
    /// <summary> number of properties of the indicated type to return </summary>
    public: UINT32 propertyCount;

public:
    TPM2_GetCapability_REQUEST() {}
    TPM2_GetCapability_REQUEST(TPM_CAP _capability, UINT32 _property, UINT32 _propertyCount)
      : capability(_capability), property(_property), propertyCount(_propertyCount)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_GetCapability_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_GetCapability_REQUEST

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
class _DLLEXP_ GetCapabilityResponse : public RespStructure
{
    /// <summary> flag to indicate if there are more values of this type </summary>
    public: BYTE moreData;
    public: TPM_CAP get_capabilityDataCapability() const { return capabilityData->GetUnionSelector(); }
    
    /// <summary> the capability </summary>
    protected: mutable TPM_CAP capabilityDataCapability;
    
    /// <summary>
    /// the capability data
    /// (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
    /// TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
    /// TPML_TAGGED_POLICY, TPML_ACT_DATA])
    /// </summary>
    public: shared_ptr<TPMU_CAPABILITIES> capabilityData;

public:
    GetCapabilityResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "GetCapabilityResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class GetCapabilityResponse

/// <summary>
/// This command is used to check to see if specific combinations of algorithm
/// parameters are supported.
/// </summary>
class _DLLEXP_ TPM2_TestParms_REQUEST : public ReqStructure
{
    public: TPM_ALG_ID get_parametersType() const { return parameters->GetUnionSelector(); }
    
    /// <summary> the algorithm to be tested </summary>
    protected: mutable TPM_ALG_ID parametersType;
    
    /// <summary>
    /// algorithm parameters to be validated
    /// (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS,
    /// TPMS_ECC_PARMS, TPMS_ASYM_PARMS])
    /// </summary>
    public: shared_ptr<TPMU_PUBLIC_PARMS> parameters;

public:
    TPM2_TestParms_REQUEST() {}
    TPM2_TestParms_REQUEST(const TPMU_PUBLIC_PARMS& _parameters)
      : parameters(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_TestParms_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2_TestParms_REQUEST

/// <summary>
/// This command defines the attributes of an NV Index and causes the TPM to reserve space to
/// hold the data associated with the NV Index. If a definition already exists at the NV Index, the
/// TPM will return TPM_RC_NV_DEFINED.
/// </summary>
class _DLLEXP_ TPM2_NV_DefineSpace_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authSize;
    
    /// <summary> the authorization value </summary>
    public: ByteVec auth;
    
    /// <summary> size of nvPublic </summary>
    protected: mutable UINT16 publicInfoSize;
    
    /// <summary> the public parameters of the NV area </summary>
    public: TPMS_NV_PUBLIC publicInfo;

public:
    TPM2_NV_DefineSpace_REQUEST() {}
    TPM2_NV_DefineSpace_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _auth, const TPMS_NV_PUBLIC& _publicInfo)
      : authHandle(_authHandle), auth(_auth), publicInfo(_publicInfo)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_NV_DefineSpace_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_DefineSpace_REQUEST

/// <summary> This command removes an Index from the TPM. </summary>
class _DLLEXP_ TPM2_NV_UndefineSpace_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index to remove from NV space
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;

public:
    TPM2_NV_UndefineSpace_REQUEST() {}
    TPM2_NV_UndefineSpace_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    virtual const char* TypeName () const { return "TPM2_NV_UndefineSpace_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_UndefineSpace_REQUEST

/// <summary>
/// This command allows removal of a platform-created NV Index that has
/// TPMA_NV_POLICY_DELETE SET.
/// </summary>
class _DLLEXP_ TPM2_NV_UndefineSpaceSpecial_REQUEST : public ReqStructure
{
    /// <summary>
    /// Index to be deleted
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary>
    /// TPM_RH_PLATFORM + {PP}
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE platform;

public:
    TPM2_NV_UndefineSpaceSpecial_REQUEST() {}
    TPM2_NV_UndefineSpaceSpecial_REQUEST(const TPM_HANDLE& _nvIndex, const TPM_HANDLE& _platform)
      : nvIndex(_nvIndex), platform(_platform)
    {}
    
    virtual const char* TypeName () const { return "TPM2_NV_UndefineSpaceSpecial_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {nvIndex, platform}; }
}; // class TPM2_NV_UndefineSpaceSpecial_REQUEST

/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of
/// an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
class _DLLEXP_ TPM2_NV_ReadPublic_REQUEST : public ReqStructure
{
    /// <summary>
    /// the NV Index
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;

public:
    TPM2_NV_ReadPublic_REQUEST() {}
    TPM2_NV_ReadPublic_REQUEST(const TPM_HANDLE& _nvIndex)
      : nvIndex(_nvIndex)
    {}
    
    virtual const char* TypeName () const { return "TPM2_NV_ReadPublic_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {nvIndex}; }
}; // class TPM2_NV_ReadPublic_REQUEST

/// <summary>
/// This command is used to read the public area and Name of an NV Index. The public area of
/// an Index is not privacy-sensitive and no authorization is required to read this data.
/// </summary>
class _DLLEXP_ NV_ReadPublicResponse : public RespStructure
{
    /// <summary> size of nvPublic </summary>
    protected: mutable UINT16 nvPublicSize;
    
    /// <summary> the public area of the NV Index </summary>
    public: TPMS_NV_PUBLIC nvPublic;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 nvNameSize;
    
    /// <summary> the Name of the nvIndex </summary>
    public: ByteVec nvName;

public:
    NV_ReadPublicResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "NV_ReadPublicResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class NV_ReadPublicResponse

/// <summary>
/// This command writes a value to an area in NV memory that was previously
/// defined by TPM2_NV_DefineSpace().
/// </summary>
class _DLLEXP_ TPM2_NV_Write_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index of the area to write
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 dataSize;
    
    /// <summary> the data to write </summary>
    public: ByteVec data;
    
    /// <summary> the octet offset into the NV Area </summary>
    public: UINT16 offset;

public:
    TPM2_NV_Write_REQUEST() {}
    TPM2_NV_Write_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const ByteVec& _data, UINT16 _offset)
      : authHandle(_authHandle), nvIndex(_nvIndex), data(_data), offset(_offset)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_NV_Write_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_Write_REQUEST

/// <summary>
/// This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
/// attribute. The data value of the NV Index is incremented by one.
/// </summary>
class _DLLEXP_ TPM2_NV_Increment_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index to increment
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;

public:
    TPM2_NV_Increment_REQUEST() {}
    TPM2_NV_Increment_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    virtual const char* TypeName () const { return "TPM2_NV_Increment_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_Increment_REQUEST

/// <summary>
/// This command extends a value to an area in NV memory that was previously
/// defined by TPM2_NV_DefineSpace.
/// </summary>
class _DLLEXP_ TPM2_NV_Extend_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index to extend
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 dataSize;
    
    /// <summary> the data to extend </summary>
    public: ByteVec data;

public:
    TPM2_NV_Extend_REQUEST() {}
    TPM2_NV_Extend_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const ByteVec& _data)
      : authHandle(_authHandle), nvIndex(_nvIndex), data(_data)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_NV_Extend_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_Extend_REQUEST

/// <summary>
/// This command is used to SET bits in an NV Index that was created as a bit field. Any
/// number of bits from 0 to 64 may be SET. The contents of bits are ORed with the
/// current contents of the NV Index.
/// </summary>
class _DLLEXP_ TPM2_NV_SetBits_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// NV Index of the area in which the bit is to be set
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary> the data to OR with the current contents </summary>
    public: UINT64 bits;

public:
    TPM2_NV_SetBits_REQUEST() {}
    TPM2_NV_SetBits_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, UINT64 _bits)
      : authHandle(_authHandle), nvIndex(_nvIndex), bits(_bits)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_NV_SetBits_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_SetBits_REQUEST

/// <summary>
/// If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET,
/// then this command may be used to inhibit further writes of the NV Index.
/// </summary>
class _DLLEXP_ TPM2_NV_WriteLock_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index of the area to lock
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;

public:
    TPM2_NV_WriteLock_REQUEST() {}
    TPM2_NV_WriteLock_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    virtual const char* TypeName () const { return "TPM2_NV_WriteLock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_WriteLock_REQUEST

/// <summary>
/// The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
/// TPMA_NV_GLOBALLOCK attribute SET.
/// </summary>
class _DLLEXP_ TPM2_NV_GlobalWriteLock_REQUEST : public ReqStructure
{
    /// <summary>
    /// TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;

public:
    TPM2_NV_GlobalWriteLock_REQUEST() {}
    TPM2_NV_GlobalWriteLock_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    virtual const char* TypeName () const { return "TPM2_NV_GlobalWriteLock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_NV_GlobalWriteLock_REQUEST

/// <summary>
/// This command reads a value from an area in NV memory previously defined
/// by TPM2_NV_DefineSpace().
/// </summary>
class _DLLEXP_ TPM2_NV_Read_REQUEST : public ReqStructure
{
    /// <summary>
    /// the handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index to be read
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary> number of octets to read </summary>
    public: UINT16 size;
    
    /// <summary>
    /// octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    /// </summary>
    public: UINT16 offset;

public:
    TPM2_NV_Read_REQUEST() {}
    TPM2_NV_Read_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, UINT16 _size, UINT16 _offset)
      : authHandle(_authHandle), nvIndex(_nvIndex), size(_size), offset(_offset)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_NV_Read_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_Read_REQUEST

/// <summary>
/// This command reads a value from an area in NV memory previously defined
/// by TPM2_NV_DefineSpace().
/// </summary>
class _DLLEXP_ NV_ReadResponse : public RespStructure
{
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 dataSize;
    
    /// <summary> the data read </summary>
    public: ByteVec data;

public:
    NV_ReadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "NV_ReadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class NV_ReadResponse

/// <summary>
/// If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
/// further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
/// </summary>
class _DLLEXP_ TPM2_NV_ReadLock_REQUEST : public ReqStructure
{
    /// <summary>
    /// the handle indicating the source of the authorization value
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// the NV Index to be locked
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;

public:
    TPM2_NV_ReadLock_REQUEST() {}
    TPM2_NV_ReadLock_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    virtual const char* TypeName () const { return "TPM2_NV_ReadLock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_ReadLock_REQUEST

/// <summary> This command allows the authorization secret for an NV Index to be changed. </summary>
class _DLLEXP_ TPM2_NV_ChangeAuth_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the entity
    /// Auth Index: 1
    /// Auth Role: ADMIN
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 newAuthSize;
    
    /// <summary> new authorization value </summary>
    public: ByteVec newAuth;

public:
    TPM2_NV_ChangeAuth_REQUEST() {}
    TPM2_NV_ChangeAuth_REQUEST(const TPM_HANDLE& _nvIndex, const ByteVec& _newAuth)
      : nvIndex(_nvIndex), newAuth(_newAuth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_NV_ChangeAuth_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_ChangeAuth_REQUEST

/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or
/// portion of an NV Index.
/// </summary>
class _DLLEXP_ TPM2_NV_Certify_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the key used to sign the attestation structure
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE signHandle;
    
    /// <summary>
    /// handle indicating the source of the authorization value for the NV Index
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// Index for the area to be certified
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE nvIndex;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 qualifyingDataSize;
    
    /// <summary> user-provided qualifying data </summary>
    public: ByteVec qualifyingData;
    public: TPM_ALG_ID get_inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> scheme selector </summary>
    protected: mutable TPM_ALG_ID inSchemeScheme;
    
    /// <summary>
    /// signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
    /// (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
    /// TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
    /// </summary>
    public: shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /// <summary> number of octets to certify </summary>
    public: UINT16 size;
    
    /// <summary>
    /// octet offset into the NV area
    /// This value shall be less than or equal to the size of the nvIndex data.
    /// </summary>
    public: UINT16 offset;

public:
    TPM2_NV_Certify_REQUEST() {}
    TPM2_NV_Certify_REQUEST(const TPM_HANDLE& _signHandle, const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme, UINT16 _size, UINT16 _offset)
      : signHandle(_signHandle), authHandle(_authHandle), nvIndex(_nvIndex), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), size(_size), offset(_offset)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_NV_Certify_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {signHandle, authHandle, nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_Certify_REQUEST

/// <summary>
/// The purpose of this command is to certify the contents of an NV Index or
/// portion of an NV Index.
/// </summary>
class _DLLEXP_ NV_CertifyResponse : public RespStructure
{
    /// <summary> size of the attestationData structure </summary>
    protected: mutable UINT16 certifyInfoSize;
    
    /// <summary> the structure that was signed </summary>
    public: TPMS_ATTEST certifyInfo;
    public: TPM_ALG_ID get_signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /// <summary> selector of the algorithm used to construct the signature </summary>
    protected: mutable TPM_ALG_ID signatureSigAlg;
    
    /// <summary>
    /// the asymmetric signature over certifyInfo using the key referenced by signHandle
    /// (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
    /// TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
    /// TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
    /// </summary>
    public: shared_ptr<TPMU_SIGNATURE> signature;

public:
    NV_CertifyResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "NV_CertifyResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class NV_CertifyResponse

/// <summary>
/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
/// </summary>
class _DLLEXP_ TPM2_AC_GetCapability_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle indicating the Attached Component
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE ac;
    
    /// <summary> starting info type </summary>
    public: TPM_AT capability;
    
    /// <summary> maximum number of values to return </summary>
    public: UINT32 count;

public:
    TPM2_AC_GetCapability_REQUEST() {}
    TPM2_AC_GetCapability_REQUEST(const TPM_HANDLE& _ac, TPM_AT _capability, UINT32 _count)
      : ac(_ac), capability(_capability), count(_count)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_AC_GetCapability_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {ac}; }
}; // class TPM2_AC_GetCapability_REQUEST

/// <summary>
/// The purpose of this command is to obtain information about an Attached Component
/// referenced by an AC handle.
/// </summary>
class _DLLEXP_ AC_GetCapabilityResponse : public RespStructure
{
    /// <summary> flag to indicate whether there are more values </summary>
    public: BYTE moreData;
    
    /// <summary> number of values in the acCapabilities list; may be 0 </summary>
    protected: mutable UINT32 capabilitiesDataCount;
    
    /// <summary> list of capabilities </summary>
    public: vector<TPMS_AC_OUTPUT> capabilitiesData;

public:
    AC_GetCapabilityResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "AC_GetCapabilityResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class AC_GetCapabilityResponse

/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM
/// to an Attached Component.
/// </summary>
class _DLLEXP_ TPM2_AC_Send_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle of the object being sent to ac
    /// Auth Index: 1
    /// Auth Role: DUP
    /// </summary>
    public: TPM_HANDLE sendObject;
    
    /// <summary>
    /// the handle indicating the source of the authorization value
    /// Auth Index: 2
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE authHandle;
    
    /// <summary>
    /// handle indicating the Attached Component to which the object will be sent
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE ac;
    
    /// <summary> size of the buffer </summary>
    protected: mutable UINT16 acDataInSize;
    
    /// <summary> Optional non sensitive information related to the object </summary>
    public: ByteVec acDataIn;

public:
    TPM2_AC_Send_REQUEST() {}
    TPM2_AC_Send_REQUEST(const TPM_HANDLE& _sendObject, const TPM_HANDLE& _authHandle, const TPM_HANDLE& _ac, const ByteVec& _acDataIn)
      : sendObject(_sendObject), authHandle(_authHandle), ac(_ac), acDataIn(_acDataIn)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_AC_Send_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {sendObject, authHandle, ac}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_AC_Send_REQUEST

/// <summary>
/// The purpose of this command is to send (copy) a loaded object from the TPM
/// to an Attached Component.
/// </summary>
class _DLLEXP_ AC_SendResponse : public RespStructure
{
    /// <summary> May include AC specific data or information about an error. </summary>
    public: TPMS_AC_OUTPUT acDataOut;

public:
    AC_SendResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "AC_SendResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class AC_SendResponse

/// <summary>
/// This command allows qualification of the sending (copying) of an Object to an Attached
/// Component (AC). Qualification includes selection of the receiving AC and the method of
/// authentication for the AC, and, in certain circumstances, the Object to
/// be sent may be specified.
/// </summary>
class _DLLEXP_ TPM2_Policy_AC_SendSelect_REQUEST : public ReqStructure
{
    /// <summary>
    /// handle for the policy session being extended
    /// Auth Index: None
    /// </summary>
    public: TPM_HANDLE policySession;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 objectNameSize;
    
    /// <summary> the Name of the Object to be sent </summary>
    public: ByteVec objectName;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 authHandleNameSize;
    
    /// <summary> the Name associated with authHandle used in the TPM2_AC_Send() command </summary>
    public: ByteVec authHandleName;
    
    /// <summary> size of the Name structure </summary>
    protected: mutable UINT16 acNameSize;
    
    /// <summary> the Name of the Attached Component to which the Object will be sent </summary>
    public: ByteVec acName;
    
    /// <summary> if SET, objectName will be included in the value in policySessionpolicyDigest </summary>
    public: BYTE includeObject;

public:
    TPM2_Policy_AC_SendSelect_REQUEST() {}
    TPM2_Policy_AC_SendSelect_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _objectName, const ByteVec& _authHandleName, const ByteVec& _acName, BYTE _includeObject)
      : policySession(_policySession), objectName(_objectName), authHandleName(_authHandleName), acName(_acName), includeObject(_includeObject)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Policy_AC_SendSelect_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Policy_AC_SendSelect_REQUEST

/// <summary>
/// This command is used to set the time remaining before an Authenticated
/// Countdown Timer (ACT) expires.
/// </summary>
class _DLLEXP_ TPM2_ACT_SetTimeout_REQUEST : public ReqStructure
{
    /// <summary>
    /// Handle of the selected ACT
    /// Auth Index: 1
    /// Auth Role: USER
    /// </summary>
    public: TPM_HANDLE actHandle;
    
    /// <summary> the start timeout value for the ACT in seconds </summary>
    public: UINT32 startTimeout;

public:
    TPM2_ACT_SetTimeout_REQUEST() {}
    TPM2_ACT_SetTimeout_REQUEST(const TPM_HANDLE& _actHandle, UINT32 _startTimeout)
      : actHandle(_actHandle), startTimeout(_startTimeout)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_ACT_SetTimeout_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual const vector<TPM_HANDLE> getHandles() const { return {actHandle}; }
}; // class TPM2_ACT_SetTimeout_REQUEST

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
class _DLLEXP_ TPM2_Vendor_TCG_Test_REQUEST : public ReqStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 inputDataSize;
    
    /// <summary> dummy data </summary>
    public: ByteVec inputData;

public:
    TPM2_Vendor_TCG_Test_REQUEST() {}
    TPM2_Vendor_TCG_Test_REQUEST(const ByteVec& _inputData)
      : inputData(_inputData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TPM2_Vendor_TCG_Test_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Vendor_TCG_Test_REQUEST

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
class _DLLEXP_ Vendor_TCG_TestResponse : public RespStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 outputDataSize;
    
    /// <summary> dummy data </summary>
    public: ByteVec outputData;

public:
    Vendor_TCG_TestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "Vendor_TCG_TestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class Vendor_TCG_TestResponse

/// <summary> Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
typedef TPMS_SIG_SCHEME_RSASSA TPMS_SCHEME_RSASSA;

/// <summary> Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
typedef TPMS_SIG_SCHEME_RSAPSS TPMS_SCHEME_RSAPSS;

/// <summary>
/// Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition
/// and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they
/// are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
typedef TPMS_SIG_SCHEME_ECDSA TPMS_SCHEME_ECDSA;

/// <summary>
/// Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition
/// and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they
/// are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
typedef TPMS_SIG_SCHEME_SM2 TPMS_SCHEME_SM2;

/// <summary>
/// Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition
/// and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they
/// are typed to be TPMS_SCHEME_ECDAA.
/// </summary>
typedef TPMS_SIG_SCHEME_ECSCHNORR TPMS_SCHEME_ECSCHNORR;

/// <summary>
/// Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as
/// a controlling parameter.
/// </summary>
typedef TPMS_ENC_SCHEME_OAEP TPMS_SCHEME_OAEP;

/// <summary>
/// Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as
/// a controlling parameter.
/// </summary>
typedef TPMS_ENC_SCHEME_RSAES TPMS_SCHEME_RSAES;

/// <summary> Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
typedef TPMS_KEY_SCHEME_ECDH TPMS_SCHEME_ECDH;

/// <summary> Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
typedef TPMS_KEY_SCHEME_ECMQV TPMS_SCHEME_ECMQV;

/// <summary>
/// Underlying type comment: These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
typedef TPMS_KDF_SCHEME_MGF1 TPMS_SCHEME_MGF1;

/// <summary>
/// Underlying type comment: These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
typedef TPMS_KDF_SCHEME_KDF1_SP800_56A TPMS_SCHEME_KDF1_SP800_56A;

/// <summary>
/// Underlying type comment: These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
typedef TPMS_KDF_SCHEME_KDF2 TPMS_SCHEME_KDF2;

/// <summary>
/// Underlying type comment: These structures are used to define the key derivation for symmetric secret sharing using
/// asymmetric methods. A secret sharing scheme is required in any asymmetric key
/// with the decrypt attribute SET.
/// </summary>
typedef TPMS_KDF_SCHEME_KDF1_SP800_108 TPMS_SCHEME_KDF1_SP800_108;

/// <summary> Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object) </summary>
class _DLLEXP_ TssObject : public TpmStructure
{
    /// <summary> Public part of key </summary>
    public: TPMT_PUBLIC Public;
    
    /// <summary> Sensitive part of key </summary>
    public: TPMT_SENSITIVE Sensitive;
    
    /// <summary> Private part is the encrypted sensitive part of key </summary>
    public: TPM2B_PRIVATE Private;

public:
    TssObject() {}
    TssObject(const TPMT_PUBLIC& _Public, const TPMT_SENSITIVE& _Sensitive, const TPM2B_PRIVATE& _Private)
      : Public(_Public), Sensitive(_Sensitive), Private(_Private)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "TssObject"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TssObject

/// <summary> Contains a PCR index and associated hash(pcr-value) [TSS] </summary>
class _DLLEXP_ PcrValue : public TpmStructure
{
    /// <summary> PCR Index </summary>
    public: UINT32 index;
    
    /// <summary> PCR Value </summary>
    public: TPMT_HA value;

public:
    PcrValue() {}
    PcrValue(UINT32 _index, const TPMT_HA& _value)
      : index(_index), value(_value)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "PcrValue"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class PcrValue

/// <summary> Structure representing a session block in a command buffer [TSS] </summary>
class _DLLEXP_ SessionIn : public TpmStructure
{
    /// <summary> Session handle </summary>
    public: TPM_HANDLE handle;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceCallerSize;
    
    /// <summary> Caller nonce </summary>
    public: ByteVec nonceCaller;
    
    /// <summary> Session attributes </summary>
    public: TPMA_SESSION attributes;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authSize;
    
    /// <summary> AuthValue (or HMAC) </summary>
    public: ByteVec auth;

public:
    SessionIn() {}
    SessionIn(const TPM_HANDLE& _handle, const ByteVec& _nonceCaller, TPMA_SESSION _attributes, const ByteVec& _auth)
      : handle(_handle), nonceCaller(_nonceCaller), attributes(_attributes), auth(_auth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "SessionIn"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class SessionIn

/// <summary> Structure representing a session block in a response buffer [TSS] </summary>
class _DLLEXP_ SessionOut : public TpmStructure
{
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 nonceTpmSize;
    
    /// <summary> TPM nonce </summary>
    public: ByteVec nonceTpm;
    
    /// <summary> Session attributes </summary>
    public: TPMA_SESSION attributes;
    
    /// <summary> size in octets of the buffer field; may be 0 </summary>
    protected: mutable UINT16 authSize;
    
    /// <summary> HMAC value </summary>
    public: ByteVec auth;

public:
    SessionOut() {}
    SessionOut(const ByteVec& _nonceTpm, TPMA_SESSION _attributes, const ByteVec& _auth)
      : nonceTpm(_nonceTpm), attributes(_attributes), auth(_auth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "SessionOut"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class SessionOut

/// <summary> Command header [TSS] </summary>
class _DLLEXP_ CommandHeader : public TpmStructure
{
    /// <summary> Command tag (sessions, or no sessions) </summary>
    public: TPM_ST Tag;
    
    /// <summary> Total command buffer length </summary>
    public: UINT32 CommandSize;
    
    /// <summary> Command code </summary>
    public: TPM_CC CommandCode;

public:
    CommandHeader() {}
    CommandHeader(TPM_ST _Tag, UINT32 _CommandSize, TPM_CC _CommandCode)
      : Tag(_Tag), CommandSize(_CommandSize), CommandCode(_CommandCode)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "CommandHeader"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class CommandHeader

/// <summary> Contains the public and private part of a TPM key </summary>
class _DLLEXP_ _TSS_KEY : public TpmStructure
{
    /// <summary> Public part of key </summary>
    public: TPMT_PUBLIC publicPart;
    
    protected: mutable UINT16 privatePartSize;
    
    /// <summary> Private part is the encrypted sensitive part of key </summary>
    public: ByteVec privatePart;

public:
    _TSS_KEY() {}
    _TSS_KEY(const TPMT_PUBLIC& _publicPart, const ByteVec& _privatePart)
      : publicPart(_publicPart), privatePart(_privatePart)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void fromTpm(TpmBuffer& buf);
    
    virtual const char* TypeName () const { return "_TSS_KEY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(ISerializer& buf) const;
    void Deserialize(ISerializer& buf);
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class _TSS_KEY

#include "Extensions/TSS_KEY.h"

/// <summary> Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation </summary>
class _DLLEXP_ TPM2B_DIGEST_SYMCIPHER : public TPM2B_DIGEST
{
public:
    TPM2B_DIGEST_SYMCIPHER() {}
    TPM2B_DIGEST_SYMCIPHER(const ByteVec& _buffer)
      : TPM2B_DIGEST(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SYMCIPHER; }
    
    virtual const char* TypeName () const { return "TPM2B_DIGEST_SYMCIPHER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_DIGEST_SYMCIPHER

/// <summary> Auto-derived from TPM2B_DIGEST </summary>
class _DLLEXP_ TPM2B_DIGEST_KEYEDHASH : public TPM2B_DIGEST
{
public:
    TPM2B_DIGEST_KEYEDHASH() {}
    TPM2B_DIGEST_KEYEDHASH(const ByteVec& _buffer)
      : TPM2B_DIGEST(_buffer)
    {}
    
    /// <summary> TpmUnion method </summary>
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    virtual const char* TypeName () const { return "TPM2B_DIGEST_KEYEDHASH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const;
    virtual TpmTypeId GetTypeId() const;

protected:
    virtual void* ElementInfo(int elementIndex, int arrayIndex, int& arraySize, TpmStructure*& pElem, int newArraySize);
}; // class TPM2B_DIGEST_KEYEDHASH

_TPMCPP_END
